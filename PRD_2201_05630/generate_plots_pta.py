"""
generate_plots_pta.py is a Python routine  that can be used to generate
the plots of A. Roper Pol, C. Caprini, A. Neronov, D. Semikoz,
"The gravitational wave signal from primordial magnetic fields in the Pulsar
Timing Array frequency band," https://arxiv.org/abs/2201.05630 (2022)

It reads the pickle run variables that can be generated by the routine
initialize_pta.py.

The function run() executes the code.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
import pandas as pd

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'
os.chdir(HOME)

from dirs import read_dirs as rd
import plot_sets
import run as r
import interferometry as inte
import cosmoGW
import spectra as sp
import pta
import GW_analytical as an
import analysis_PTA as an_pta
import magnetic_lims as mag

os.chdir(dir0)

def run():

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = rd('pta')
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)
    os.chdir(dir0)

    return runs

def generate_table_runs(runs, save=True, print_tex=False):

    """
    Function that generates the Table I of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630, that contains the parameters of the runs.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the table in tableI.csv
                (default True)
        print_tex -- option to print out text to generate the table in LaTeX
                     (default False)
    """

    nms = []; OmM = []; kM = []
    te = []; dtfin = []; tend = []
    OmGW_num = []; rat_OmGW = []
    L = []; eta = []; n = []

    for i in runs:
        nms.append(i)
        run = runs.get(i)
        OmM.append(run.OmMmax)
        kM.append(run.kfM)
        te.append(run.teM)
        tend.append(run.spectra.get('t_mag')[-1])
        dtfin.append(run.dtfin)
        OmGW_num.append(run.OmGW_num)

        # compute GW analytical envelope from model Pi spectrum, which is
        # computed from the numerical magnetic spectrum, by fitting it to a
        # broken smoothed power law and assuming Gaussianity
        rat_OmGW.append(run.OmGW_num/run.OmGW_env)
        L.append(int(np.round(run.L/np.pi)))
        eta.append(run.eta)
        n.append(run.n)

    te = np.array(te)
    name = np.array(nms)
    OmM = np.array(OmM)
    kM = np.array(kM)
    dtfin = np.array(dtfin)
    tend = np.array(tend)
    OmGW_num = np.array(OmGW_num)
    rat_OmGW = np.array(rat_OmGW)
    L = np.array(L)
    eta = np.array(eta)
    n = np.array(n)

    df = pd.DataFrame({'name': name, 'OmegaM': OmM, 'kM': kM,
                       'dte': te, 'dtfin': dtfin, 'OmegaGW_num': OmGW_num,
                       'ratio_OmegaGW': rat_OmGW, 'n': n, 'L': L,
                       'tend': tend, 'eta': eta})

    if save: df.to_csv('tableI.csv')

    if print_tex:
        for i in range(0, len(name)):

            hl = ''
            if abs(np.round(kM[i]) - kM[i]) < 0.1: kf = '%.0f'%kM[i]
            else: kf = '%.1f'%kM[i]
            exp_OmM = np.floor(np.log10(OmM[i]))
            bas_OmM = OmM[i]/10**exp_OmM
            OmegaM = "$%.1f \\times 10^{%i}$"%(bas_OmM, exp_OmM)
            exp_OmGW = np.floor(np.log10(OmGW_num[i]))
            bas_OmGW = OmGW_num[i]/10**exp_OmGW
            OmegaGW = "$%.1f \\times 10^{%i}$"%(bas_OmGW, exp_OmGW)
            rat_Om = '%.3f'%rat_OmGW[i]
            teM = '%.3f'%te[i]
            dtf = dtfin[i]
            dtf = '%.2f'%dtf
            if '1' in name[i] or 'B' in name[i]:
                hl = '\\hline' + '\n'
            else:
                kf = '--'; OmegaM = '--'; teM = '--'
                dtf = '--'; OmegaGW = '--'; rat_Om = '--'

            exp_eta = np.floor(np.log10(eta[i]))
            bas_eta = eta[i]/10**exp_eta
            if bas_eta == 1: etas = "$10^{%i}$"%exp_eta
            else: etas = "$%.0f \\times 10^{%i}$"%(bas_eta, exp_eta)

            print(hl, name[i], '&', OmegaM, '&', kf, '&', teM, '&', dtf,
                  '&', OmegaGW, '&', rat_Om, '&', n[i], '&', '$%i\pi$'%L[i],
                  '&', '%.0f'%tend[i], '&', etas, '\\\\')

    return df

def plot_OmGW_vs_k(run, g=10, Axf83=1., Ayf83=1., Axf3=1., Ayf3=1.,
                   Axf=1., Ayf=1., Aykbr=1., Aykp=1., dtfin=0, onlynum=False,
                   colnum='blue', compf=1., alp=1., alp_env=.2, tt=.5, ff=.4,
                   kkstar=2.6, save=True):

    """
    Function that plots the spectrum of GWs Omega_GW as a function of the
    normalized wave number kH_*.
    It plots the numerical GW spectrum and the analytical envelope of the GW
    spectrum.

    It is used to generate the figure 1 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    Arguments:
        g -- number of relativistic degrees of freedom at the time of
             generation (default 10 for the QCD)
        Axf83, Ayf83 -- factors to position the k^(-8/3) text (default 1, 1)
        Axf3, Ayf3 -- factors to position the k^3 text (default 1, 1)
        Axf, Ayf -- factors to position the k text (default 1, 1)
        Aykbr -- factor to position the krb text (default 1)
        Aykp -- factor to move the y-location of the kGW and k_* text
                (default 1)
        dtfin -- delta tfin used to compute the analytical envelope of the GW
                 spectrum (default dtfin = 0)
        onlynum -- option to plot only the numerical GW spectrum (default False)
        colnum -- color of the numerical GW spectrum in the plot (default
                  'blue')
        compf -- factor to compensate the numerical GW spectrum in the plot
                 (default 1)
        alp -- alpha parameter for the plot of the numerical GW spectrum
               (default 1)
        alp_env -- alpha parameter for the plot of the analytical envelope
                   of the GW spectrum (default 0.2)
        tt -- parameter to separate the output data on the right of the plot
              (default 0.5)
        ff -- parameter to locate the output data on the right of the plot
              (default 0.4)
        kkstar -- option to move the x-position of the k_* text (default 2.6)
        save -- option to save the figure in plots/Omega_GW_'name_run'.pdf
                (default True)
    """

    tini = run.tini
    t = run.spectra.get('t_EGW')
    k = run.spectra.get('k')[1:]

    # fit magnetic field spectrum to get amplitude and kpeak
    ks = run.spectra.get('ks_Pi_model')
    PiM = run.spectra.get('Pi_model')

    # numerical GW spectrum (maximum over oscillations)
    OmGW_k = run.spectra.get('OmGW_max_sp')*1
    OmGW = cosmoGW.shift_onlyOmGW_today(OmGW_k, g)

    factOmGW = run.OmMmax**2/run.kf**2*(g/10)**(-1/3)
    yl0 = factOmGW*10**(-8.5)*(g/10)**(-1/3)
    yl1 = factOmGW*1e-3*(g/10)**(-1/3)

    if not onlynum:

        plt.figure(figsize=(12, 8))
        dtfin = run.dtfin
        tfin = tini + dtfin
        ###### analytical envelopes of the GW spectrum
        # omitting the overshoot parameter and using tfin
        _, OmGW_env_k, k_br = an.OmGW_from_Pi0_env(PiM, ks, tini=tini,
                                                   tfin=tfin, FF=1, A=1.)
        OmGW_env = cosmoGW.shift_onlyOmGW_today(OmGW_env_k, g)
        _, OmGW_tfin_k = an.OmGW_from_Pi0(PiM, ks, tfin, tfin=tfin, tini=tini)
        OmGW_tfin = cosmoGW.shift_onlyOmGW_today(OmGW_tfin_k, g)
        plt.plot(ks, OmGW_env, color='black', lw=2, ls='-.', alpha=1)
        plt.plot(ks, OmGW_tfin[-1, :], color='black', alpha=alp_env)

        # GW spectral peak
        _ = sp.max_E_kf(ks, PiM, exp=1)
        kGW = _[0]
        # position of the break (omitting overshoot)
        plt.vlines(k_br, yl0/100, yl1*100, color='black',
                   lw=.7, ls='-.')
        plt.text(k_br*1.2, Aykbr*factOmGW*1e-6,
                 r'$k_{\rm br} {\cal H}_*^{-1}$', fontsize=24,
                 bbox=dict(facecolor='white', edgecolor='none',
                           boxstyle='round,pad=.2'))
        plt.vlines(kGW, yl0/100, yl1*100, color='black',
                   lw=.7, ls='-.')
        plt.text(kGW*1.2, Aykp*factOmGW*10**(-3.6),
                 r'$k_{\rm GW} {\cal H}_*^{-1}$', fontsize=24)
        # magnetic spectral peak
        plt.vlines(run.kfM, yl0/100, yl1*100, color='black',
                   lw=.7, ls='-.')
        plt.text(run.kfM/kkstar, Aykp*factOmGW*10**(-3.6),
                 r'$k_* {\cal H}_*^{-1}$', fontsize=24)
        # text indicating f^3, f, and f^{-8/3} slopes
        ind_f3 = np.argmin(abs(ks - .7))
        plt.text(Axf3*.9, Ayf3*OmGW_env[ind_f3]*1.1, r'$\sim\!k^3$',
                 fontsize=24)
        ind_kbr = np.argmin(abs(ks - k_br))
        plt.text(Axf*k_br*2, Ayf*OmGW_env[ind_kbr], r'$\sim\!k$',
                 bbox=dict(facecolor='white', edgecolor='none',
              boxstyle='round,pad=.15'), fontsize=24)
        plt.text(Axf83*kGW*8, Ayf83*factOmGW*10**(-6.1),
                 r'$\sim\!k^{-8/3}$', fontsize=24)

        # print text to the right of the plot with specific information of
        # the run and the analytical model parameters compared to the
        # numerical results
        exp_OmM = np.floor(np.log10(run.OmMmax))
        bas_OmM = run.OmMmax/10**exp_OmM
        OmM_string = "%.1f \\times 10^{%i}"%(bas_OmM, exp_OmM)
        if abs(np.round(run.kfM) - run.kfM) < 0.1:
            kf_string = '%.0f'%run.kfM
        else: kf_string = '%.1f'%run.kfM
        ff *= (g/10)**(-1/3)
        plt.text(1.3e3, 10**(-7.4)*ff,
                 r'$\Omega_{\rm M}^* = %s$'%OmM_string)
        plt.text(1.3e3, 10**(-7.4 - tt)*ff,
                 r'$k_* {\cal H}_*^{-1} = %s$'%(kf_string))
        plt.text(1.3e3, 10**(-7.4 - 2*tt)*ff,
                 r'${\cal H}_* \delta t_{\rm e} = %.2f$'%(run.teM))
        plt.text(1.3e3, 10**(-7.4 - 3*tt)*ff,
                 r'${\cal H}_* \delta t_{\rm fin} = %.2f$'%(run.dtfin))

        exp = np.floor(np.log10(max(OmGW)))
        bas = max(OmGW)/10**exp
        plt.text(1.3e3, 10**(-7.4 - 4.5*tt)*ff,
                 r'$\Omega_{\rm GW}^{\rm num} (k_{\rm GW}) \, = $')
        plt.text(2e3, 10**(-7.4 - 5.25*tt)*ff,
                 r' $%.1f \times 10^{%i}$'%(bas, exp))

        exp = np.floor(np.log10(max(OmGW_env)))
        bas = max(OmGW_env)/10**exp
        plt.text(1.3e3, 10**(-7.4 - 6.5*tt)*ff,
                 r'$\Omega_{\rm GW}^{\rm env} (k_{\rm GW}) \, = $')
        plt.text(2e3, 10**(-7.4 - 7.25*tt)*ff,
                 r' $%.1f \times 10^{%i}$'%(bas, exp))

    plt.plot(k, compf*OmGW, '.', color=colnum, alpha=alp)
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel(r'$k {\cal H}_*^{-1}$')
    plt.ylabel(r'$h^2 \Omega_{\rm GW}^0 (k) \, \bigl(g_*/%i\bigr)^{1/3}$'%g)
    plt.ylim(yl0, yl1)
    plt.xlim(1e-1, 1e3)
    plot_sets.axes_lines()

    if save: plt.savefig('plots/Omega_GW_' + run.name_run + '.pdf',
                         bbox_inches='tight')

def OmGW_k_runs(runs, A='A', g=10, save=True, debug=False, warn=True):

    """
    Function that plots the numerical and analytical (envelope) GW spectra
    of the runs of series A.

    It generates the plots of figure 1 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630
    The runs are described in their table I.

    Arguments:
        A -- series of runs to be shown (default 'A', other options are 'B',
             'C', 'D' and 'E')
        g -- number of relativistic degrees of freedom at the time of
             generation (default 10 for the QCD)
        save -- option to save the figure in plots/Omega_GW_runs'A'.pdf
                (default True)
        debug -- option to print some debugging options (default False)
        warn -- option to deactivate the warnings (default True)
    """

    # omit warnings generated from factM function while fitting the magnetic
    # spectra of two runs.
    if warn:
        import warnings
        warnings.filterwarnings("ignore")

    alp = 1.
    ff = (g/10)**(-1/3)
    if A == 'A':
        RR = ['A1', 'A2']
        cols = ['blue', 'red']
        Axf3 = .6; Ayf3 = .2; Axf = 4; Ayf = 25; Aykbr = 1.
        Axf83 = 1.2; Ayf83 = .7; Aykp = 1.
    if A == 'B':
        RR = ['B']
        cols = ['blue']
        Axf3 = .6; Ayf3 = .2; Axf = 3; Ayf = 16; Aykbr = 1.5
        Axf83 = 1.7; Ayf83 = .3; Aykp = 1.
    if A == 'C':
        RR = ['C1', 'C2']
        cols = ['blue', 'red']
        Axf3 = .6; Ayf3 = .2; Axf = 3; Ayf = 18; Aykbr = 1.
        Axf83 = 1.7; Ayf83 = .3; Aykp = 1.
    if A == 'D':
        RR = ['D1', 'D2']
        cols = ['blue', 'red']
        Axf3 = .6; Ayf3 = .2; Axf = 2.6; Ayf = 16; Aykbr = 1.
        Axf83 = 1.7; Ayf83 = .3; Aykp = .6
    if A == 'E':
        RR = ['E1', 'E2', 'E3', 'E4', 'E5']
        cols = ['blue', 'red', 'purple', 'darkorange', 'orange']
        Axf3 = .08; Ayf3 = .001; Axf = 8; Ayf = 120; Aykbr = .01
        Axf83 = 2; Ayf83 = .2; Aykp = 1.
        alp = .3

    run = runs.get(RR[0])
    k1 = run.spectra.get('k')
    mag1 = run.spectra.get('mag')
    if A != 'E':
        plot_OmGW_vs_k(run, onlynum=False, save=False, alp=1,
                       colnum=cols[0], Axf3=Axf3, Ayf3=Ayf3, Axf=Axf,
                       Ayf=Ayf, Axf83=Axf83, Ayf83=Ayf83, Aykp=Aykp,
                       g=g)
    else:
        plot_OmGW_vs_k(run, onlynum=False, save=False, alp=1,
                       colnum=cols[0], Axf3=Axf3, Ayf3=Ayf3, Axf=Axf,
                       Aykbr=Aykbr, Ayf=Ayf, Axf83=Axf83, Aykp=Aykp,
                       Ayf83=Ayf83, ff=.005, tt=.65, dtfin=2.9, kkstar=3,
                       g=g)

    if debug: print(run.dir_run, run.OmMmax, run.kfM)

    for i in range(1, len(RR)):
        run = runs.get(RR[i])
        k2 = run.spectra.get('k')
        mag2 = run.spectra.get('mag')
        factM = an.factM(k1, k2, mag1, mag2)
        if debug: print(factM)

        plot_OmGW_vs_k(run, onlynum=True, colnum=cols[i],
                       compf=1/factM**2, save=False, alp=alp, g=g)

    ax0 = plt.gca()
    handles = []
    if len(RR) > 1:
        for i in range(0, len(RR)):
            line_A, = ax0.plot([], [], 'o', color=cols[i], lw=2,
                               label=r'run %s%s'%(A, i+1))
            handles.append(line_A,)
        plt.title('Runs %s'%A, pad=15)
    else: plt.title('Run %s'%A, pad=15)
    plt.legend(handles=handles, fontsize=24, frameon=False)
    if A != 'E': plt.ylim(1e-13*ff, 1e-7*ff)
    else:
        plt.ylim(1e-16*ff, 2e-9*ff)
        plt.xlim(3e-2, 1e3)
        int_y0 = int(np.log10(1e-16*ff))
        int_y1 = int(np.log10(1e-9*ff))
        plt.yticks(np.logspace(int_y0, int_y1, int_y1 - int_y0 + 1))

    if save: plt.savefig('plots/Omega_GW_' + 'runs%s'%A + '.pdf',
                         bbox_inches='tight')

def OmGW_k_runs_all(runs, g=10, alp=.3, save=True, debug=False, warn=True):

    """
    Function that plots the numerical and analytical (envelope) GW spectrum
    of all the runs.

    It generates the plots of figure 2 (lower panel) of A. Roper Pol,
    C. Caprini, A. Neronov, D. Semikoz, "The gravitational wave signal from
    primordial magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630
    The runs are described in their table I.

    Arguments:
        g -- number of relativistic degrees of freedom at the time of
             generation (default 10 for the QCD)
        alp -- alpha parameter for the plot of the numerical GW spectrum
               (default 0.3)
        save -- option to save the figure in plots/Omega_GW_runs_model.pdf
                (default True)
        debug -- option to print some debugging options
        warn -- option to deactivate the warnings (default True)
    """

    # omit warnings generated from factM function while fitting the magnetic
    # spectra of two runs.
    if warn:
        import warnings
        warnings.filterwarnings("ignore")

    plt.figure(figsize=(12, 8))

    RR0 = [['E1', 'E3', 'E4'], ['C1', 'C2'],
           ['D1', 'D2'], ['B'], ['A1', 'A2']]
    cols0 = [['blue', 'purple', 'darkorange'], ['blue', 'red'], ['blue', 'red'],
             ['blue'], ['blue', 'red']]

    m = 0
    for i in RR0:
        run = runs.get(i[0])
        plot_OmGW_vs_k(run, g=g, onlynum=True, save=False, alp=alp)
        if debug: print(run.OmMmax, run.kfM)
        k1 = run.spectra.get('k')
        mag1 = run.spectra.get('mag')
        ks = run.spectra.get('ks_Pi_model')
        PiM = run.spectra.get('Pi_model')
        dte = run.teM
        dtfin = an.dtfin_dte(dte)
        Af = an.Af_dte(dte)
        _, OmGW_env_k, k_br = an.OmGW_from_Pi0_env(PiM, ks, tini=run.tini,
                                                   tfin=run.tini + dtfin,
                                                   FF=1., A=Af)
        OmGW_env = cosmoGW.shift_onlyOmGW_today(OmGW_env_k, g)

        _, OmGW_env_k2, _ = an.OmGW_from_Pi0_env(PiM, ks, tini=run.tini,
                                                 tfin=run.tini + dtfin,
                                                 FF=1., A=1.)
        OmGW_env2 = cosmoGW.shift_onlyOmGW_today(OmGW_env_k2, g)
        plt.plot(ks, OmGW_env, color='black')
        plt.plot(ks, OmGW_env2, color='black', ls='-.')
        n = 1
        for j in i[1:]:
            run = runs.get(j)
            k2 = run.spectra.get('k')
            mag2 = run.spectra.get('mag')
            factM = an.factM(k1, k2, mag1, mag2)
            if debug: print(factM)
            plot_OmGW_vs_k(run, g=g, onlynum=True, colnum=cols0[m][n],
                           compf=1/factM**2, save=False, alp=alp)
            n += 1
        m += 1

    plt.text(3.6e1, 1e-11, 'E1', color='blue')
    plt.text(1.3e1, 1e-11, 'E3', color='purple')
    plt.text(5, 1e-11, 'E4', color='darkorange')
    plt.text(14, 6e-10, 'A1', color='blue')
    plt.text(8, 4e-10, 'A2', color='red')
    plt.text(10, 1.25e-9, 'B', color='blue')
    plt.text(25, 5e-9, 'C1,', color='blue')
    plt.text(38, 5e-9, 'C2', color='red')
    plt.text(4, 8e-9, 'D1', color='blue')
    plt.text(2, 5e-9, 'D2', color='red')
    plt.ylim(1e-13, 1e-7)
    plt.xlim(1e-1, 5e2)
    plt.yticks(np.logspace(-13, -7, 7))

    if save: plt.savefig('plots/Omega_GW_runs_model.pdf',
                         bbox_inches='tight')

def plot_dte_dtf_fit(runs, dtf=[], Af=[], run_names=[],
                     save=True):

    """
    Function that generates the plots of the empirical fits obtained from
    the numerical simulations for the analytical parameters dtfin and G.
    It generates the plots of figure 2 (upper and middle panels) of A. Roper
    Pol, C. Caprini, A. Neronov, D. Semikoz, "The gravitational wave signal from
    primordial magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    Arguments:
        dtfin -- array of dtfinal (by default it takes the run.dtfin
                 parameters)
        Af -- array of ratios of numerical to analytical values of the GW
              spectral peak (by default it takes the run.rat_OmGW values)
        run_names -- array of run identifiers to be plot (by default it takes
                     all of the runs in 'runs')
        save -- option to save the figure in plots/dte_dtf_fit.pdf and
                plots/dte_ratio_fit.pdf (default True)
    """

    import scipy.optimize as opt

    def fit_l(x, b, c):
        y = c + b*x
        return y

    j = 0
    te_arr = []
    dtfinal = False
    ratio = False
    if len(dtf) > 0: dtfinal = True
    if len(Af) > 0: ratio = True

    if not dtfinal and not ratio:
        run_names = ['A1', 'B', 'C1', 'D1', 'E1']
        #run_names = runs
        dtf = []
        Af = []
        for i in run_names:
            run = runs.get(i)
            dtf.append(run.dtfin)
            Af.append(run.OmGW_num/run.OmGW_env)
        dtf = np.array(dtf)
        Af = np.array(Af)
        dtfinal = True
        ratio = True

    if dtfinal or ratio: plt.figure(1, figsize=(8,5))
    if dtfinal and ratio: plt.figure(2, figsize=(8,5))

    if len(run_names) == 0: run_names = runs

    for i in run_names:
        run = runs.get(i)
        te = run.teM
        te_arr.append(te)
        if dtfinal:
            plt.figure(1)
            plt.plot(te, dtf[j], '.', color='black')
        if ratio:
            if dtfinal: plt.figure(2)
            else: plt.figure(1)
            plt.plot(te, Af[j], '.', color='black')
        j += 1

    te = np.array(te_arr)

    txx = np.linspace(0, 2)
    if dtfinal:
        popt_tf, pcov = opt.curve_fit(fit_l, te, dtf,
                                      p0=(1.6888, .228))
        plt.figure(1)
        plt.plot(txx, popt_tf[0]*txx + popt_tf[1], color='black',
                 ls='-.', lw=.6)

        plt.xlim(0, 2)
        plt.ylim(0.1, 4)
        plot_sets.axes_lines()
        plt.xlabel(r'${\cal H}_* \delta t_{\rm e} $')
        plt.ylabel(r'${\cal H}_* \delta t_{\rm fin}$')
        plt.gca().tick_params(axis='y', pad=10)
        plt.text(1.1, 2, '$y = %.3f + %.3fx$'%(popt_tf[1], popt_tf[0]),
                 fontsize=20)
        plt.text(.12, .67, 'A', fontsize=20)
        plt.text(.25, .34, 'B', fontsize=20)
        plt.text(.25, .82, 'C', fontsize=20)
        plt.text(.38, .61, 'D', fontsize=20)
        plt.text(1.35, 3, 'E', fontsize=20)

        if save: plt.savefig('plots/dte_dtf_fit.pdf',
                             bbox_inches='tight')

    if ratio:
        popt_Af, pcov = opt.curve_fit(fit_l, te, Af,
                                      p0=(-1.5, 1.5))

        if dtfinal: plt.figure(2)
        else: plt.figure(1)
        plt.plot(txx, popt_Af[0]*txx + popt_Af[1], color='black',
                 ls='-.', lw=.6)

        plt.xlim(0, 2)
        plt.ylim(1.15, 1.4)
        plot_sets.axes_lines()
        plt.xlabel(r'${\cal H}_* \delta t_{\rm e}$')
        plt.ylabel(r'${\cal G}$', labelpad=10)
        plt.text(1., 1.32, '$y = %.3f %.3fx$'%(popt_Af[1], popt_Af[0]),
                 fontsize=20)
        plt.text(.08, 1.365, 'A', fontsize=20)
        plt.text(.18, 1.26, 'B', fontsize=20)
        plt.text(.32, 1.225, 'C', fontsize=20)
        plt.text(.38, 1.315, 'D', fontsize=20)
        plt.text(1.45, 1.19, 'E', fontsize=20)

        if save: plt.savefig('plots/dte_ratio_fit.pdf',
                             bbox_inches='tight')

def plot_PTA(beta_b=True, Omega_b=True, fref=0, show=False,
                       return_all=False, save=True):

    """
    Function that plots the results reported by NANOGrav, PPTA, EPTA, and IPTA.

    It generates the plot of figure 3 (upper panel) of A. Roper
    Pol, C. Caprini, A. Neronov, D. Semikoz, "The gravitational wave signal from
    primordial magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    It plots the amplitude of the GW background for 1-sigma and 2-sigma
    confidence as a function of the amplitude beta of the Omega_GW spectrum.
    The amplitude is defined such that the characteristic amplitude spectrum is

    h_c(f) = A (f/fyr)^alpha

    The references for the NANOGrav, PPTA, EPTA, and IPTA (DR2) results are:
        - [NANOGrav], "The NANOGrav 12.5 yr data set: Search for an isotropic
        stochastic gravitational-wave background," Astrophys. J. Lett. 905,
        L34 (2020), https://arxiv.org/pdf/2009.04496.pdf
        - B. Goncharov et al., "On the evidence for a common-spectrum process
        in the search for the nanohertz gravitational-wave background with the
        Parkes Pulsar Timing Array," Astrophys. J. Lett. 917, L19 (2021),
        https://arxiv.org/pdf/2107.12112.pdf
        - S. Chen et al., "Common-red-signal analysis with 24-yr high-precision
        timing of the European Pulsar Timing Array: Inferences in the stochastic
        gravitational-wave background search," Mon. Not. Royal Astron. Soc.
        508, 4970 (2021), https://arxiv.org/pdf/2110.13184.pdf
        - J. Antoniadis et al., "The International Pulsar Timing Array second
        data release: Search for an isotropic Gravitational Wave Background,"
        Mon. Not. Royal Astron. Soc. 510, 4873 (2022),
        https://arxiv.org/pdf/2201.03980.pdf


    Arguments:
        beta_b -- option to plot the amplitude as a function of the
                  slope of the GW background beta (default True)
                  If this is set to False, then it plots as a function of original
                  parameter gamma, which refers to the slope of the power spectral
                  density. Both are related as gamma = 5 - beta
        Omega_b -- option to plot the amplitude referring to a GW energy
                   density spectrum OmGW = OmGW_ampl (f/fref)^beta
        fref -- frequency of reference to define the amplitude (default is the
                frequency of 1 year, fyr)
        show -- option to show text in the plot (default False)
        return_all -- option to return all functions as an output
        save -- option to save the plot in plots/PTA_'AA'_vs_'bb'.pdf
                where 'AA' is 'A' (if Omega_b = False) or 'Om'
                (if Omega_b = True) and 'bb' is 'gamma' (if beta_b = False) or
                'beta' (if beta_b = True) (default True)
    """

    fig, ax = plt.subplots(figsize=(12,8))

    # Read data from PTA collaborations
    _ = pta.read_PTA_data(beta_b=beta_b, Omega_b=Omega_b, fref=fref,
                          return_all=True, plot=True,
                          fill_1s=False, fill_2s=True)

    plot_sets.axes_lines()
    plt.yscale('log')
    yl1 = 5e-14
    yl0 = 5e-17
    bb = 'gamma'
    AA = 'A'
    if fref != 0:
        b = np.floor(np.log10(fref.value))
        a = fref.value/10**b
        save = False
    if Omega_b:
        yl0 = cosmoGW.Omega_A(A=yl0)
        yl1 = cosmoGW.Omega_A(A=yl1)
        AA = 'Om'
        if fref==0:
            plt.ylim(yl0, yl1)
            plt.ylabel(r'$h^2 \Omega_{\rm yr}$')
        else:
            b = np.floor(np.log10(fref.value))
            plt.ylabel(r'$\Omega_{\rm ref}$')
            plt.title(r'$f_{\rm ref} = %.2f \cdot 10^{%i}$ Hz'%(a, b),
                      pad=15)
    if not Omega_b:
        if fref==0:
            plt.ylim(yl0, yl1)
            plt.ylabel(r'$A_{\rm yr}$')
        else:
            plt.ylabel(r'$A_{\rm ref}$')
            plt.title(r'$f_{\rm ref} = %.2f \cdot 10^{%i}$ Hz'%(a, b),
                      pad=15)
    if beta_b:
        bb = 'beta'
        plt.xlim(-2, 5)
        plt.xlabel(r'$\beta$')
    if not beta_b:
        plt.xlim(0, 7)
        plt.xlabel(r'$\gamma$')

    if show and fref == 0:
        yp0 = 1e-16
        yp1 = 2e-15
        yp2 = 6.5e-15
        yp3 = 7e-15
        yp4 = 4e-15
        bep0 = -1.1
        bep1 = 1.5
        bep2 = 3.3
        bep3 = -.4
        bep4 = -.7
        beta0 = 1
        beta1 = 3
        if Omega_b:
            yp0 = cosmoGW.Omega_A(A=yp0)
            yp1 = cosmoGW.Omega_A(A=yp1)
            yp2 = cosmoGW.Omega_A(A=yp2)
            yp3 = cosmoGW.Omega_A(A=yp3)
            yp4 = cosmoGW.Omega_A(A=yp4)
        if not beta_b:
            show = False
            beta0 = 5 - beta0
            beta1 = 5 - beta1
            bep0 = 5 - bep0 - 1.4
            bep1 = 5 - bep1 - .2
            bep2 = 5 - bep2 - 1.7
            bep3 = 5 - bep3 - 1.7
            bep4 = 5 - bep4 - 1.7
        plt.vlines(beta0, yl0, yl1, color='black', ls='dashed', lw=.8)
        plt.vlines(beta1, yl0, yl1, color='black', ls='dashed', lw=.8)
        plt.fill_between(np.linspace(beta0, beta1), yl0, yl1,
                         color='gray', alpha=.2)
        plt.text(bep0, yp0, 'NANOGrav broken PL', color='blue', fontsize=14)
        plt.text(bep1, yp1, 'PPTA single PL', color='red', fontsize=14)
        plt.text(bep2, yp2, 'NANOGrav single PL',
                 color='darkgreen', fontsize=14)
        plt.text(bep3, yp3, 'EPTA single PL', color='purple', fontsize=14)
        plt.text(bep4, yp4, 'IPTA single PL', color='black', fontsize=14)

    if save: plt.savefig('plots/PTA_' + AA + '_vs_' + bb + \
                         '.pdf', bbox_inches='tight')

# def plot_CP_delay(betas, colors=[], obs='NANOGrav_brokenPL_2s', alpha=.1):
#
#     plt.figure(figsize=(12,8))
#     if len(colors) == 0: colors=['blue']*len(betas)
#     _ = pta.CP_delay(betas, colors=colors, obs=obs, alpha=alpha, plot=True,)
#     plt.xscale('log')
#     plt.yscale('log')
#     plot_sets.axes_lines()
#     plt.xlabel('$f$ [Hz]')
#     plt.ylabel('CP delay [s]')
#     plt.xlim(2e-9, 7e-8)
#     plt.ylim(1e-9, 1e-6)

def plot_PTA_all(ff='tdel', betas=[], lines=True, alp_bl=0.3, alp_E=0.2):

    """
    Function that overplots the GW spectra Omega_GW (f) = Omyr (f/fyr)^beta
    for the values of beta and Omyr reported by the PTA collaborations.

    Arguments:
        ff -- option to chose what function to plot (default 'tdel' for time
              delay in seconds, 'Sf' for power spectral density, 'hc' for
              characteristic amplitude spectrum, and 'Om' for GW energy density
              spectrum, from -2 to 5)
        betas -- range of slopes considered for the plot (default is all
                 possible values)
        lines -- option to explicitly plot the boundaring lines on top of the
                 allowed region.
    """

    if len(betas) == 0: betas = np.linspace(-2, 5, 100)

    if ff == 'tdel': ff2 = 'Sf'
    else: ff2 = ff

    (f_bPL_NG, min_OmGW_bPL_NG, max_OmGW_bPL_NG, f_sPL_NG, min_OmGW_sPL_NG,
    max_OmGW_sPL_NG, f_sPL_P, min_OmGW_sPL_P, max_OmGW_sPL_P, f_sPL_E_old,
    min_OmGW_sPL_E_old, max_OmGW_sPL_E_old, f_sPL_E, min_OmGW_sPL_E,
    max_OmGW_sPL_E, f_sPL_I, min_OmGW_sPL_I, max_OmGW_sPL_I) = \
                    pta.OmGW_PTA(betas, ff=ff2)

    # duration of observations for NANOGrav
    T_NG = 12.5*u.yr
    T_NG = T_NG.to(u.s)
    # duration of observations for PPTA
    T_P = 15*u.yr
    T_P = T_P.to(u.s)
    # duration of observations for EPTA
    T_E = 24*u.yr
    T_E = T_E.to(u.s)
    # duration of observations for IPTA
    T_I = 31*u.yr
    T_I = T_I.to(u.s)

    if ff == 'tdel':
        min_OmGW_bPL_NG = np.sqrt(min_OmGW_bPL_NG/T_NG)
        max_OmGW_bPL_NG = np.sqrt(max_OmGW_bPL_NG/T_NG)
        min_OmGW_sPL_NG = np.sqrt(min_OmGW_sPL_NG/T_NG)
        max_OmGW_sPL_NG = np.sqrt(max_OmGW_sPL_NG/T_NG)
        min_OmGW_sPL_P = np.sqrt(min_OmGW_sPL_P/T_P)
        max_OmGW_sPL_P = np.sqrt(max_OmGW_sPL_P/T_P)
        min_OmGW_sPL_E_old = np.sqrt(min_OmGW_sPL_E_old/T_E)
        max_OmGW_sPL_E_old = np.sqrt(max_OmGW_sPL_E_old/T_E)
        min_OmGW_sPL_E = np.sqrt(min_OmGW_sPL_E/T_E)
        max_OmGW_sPL_E = np.sqrt(max_OmGW_sPL_E/T_E)
        min_OmGW_sPL_I = np.sqrt(min_OmGW_sPL_I/T_I)
        max_OmGW_sPL_I = np.sqrt(max_OmGW_sPL_I/T_I)

    flim = 1.25e-8*u.Hz
    good = np.where(f_bPL_NG.value < flim.value)
    plt.fill_between(f_sPL_NG, min_OmGW_sPL_NG, max_OmGW_sPL_NG,
                     color='darkgreen', alpha=.1)
    if lines:
        plt.plot(f_sPL_NG, min_OmGW_sPL_NG, color='darkgreen', lw=2)
        plt.plot(f_sPL_NG, max_OmGW_sPL_NG, color='darkgreen', lw=2)
    plt.fill_between(f_bPL_NG[good], min_OmGW_bPL_NG[good],
                     max_OmGW_bPL_NG[good], color='blue', alpha=alp_bl,
                     label='NG bPL')
    if lines:
        plt.plot(f_bPL_NG[good], min_OmGW_bPL_NG[good], color='blue', lw=2)
        plt.plot(f_bPL_NG[good], max_OmGW_bPL_NG[good], color='blue', lw=2)
    plt.fill_between(f_sPL_P, min_OmGW_sPL_P, max_OmGW_sPL_P,
                     color='red', alpha=.1)
    if lines:
        plt.plot(f_sPL_P, min_OmGW_sPL_P, color='red', lw=2)
        plt.plot(f_sPL_P, max_OmGW_sPL_P, color='red', lw=2)
    plt.fill_between(f_sPL_E, min_OmGW_sPL_E, max_OmGW_sPL_E,
                     color='purple', alpha=alp_E)
    if lines:
        plt.plot(f_sPL_E, min_OmGW_sPL_E, color='purple', lw=2)
        plt.plot(f_sPL_E, max_OmGW_sPL_E, color='purple', lw=2)
    plt.fill_between(f_sPL_I, min_OmGW_sPL_I, max_OmGW_sPL_I,
                     color='black', alpha=alp_E)
    if lines:
        plt.plot(f_sPL_I, min_OmGW_sPL_I, color='black', lw=2)
        plt.plot(f_sPL_I, max_OmGW_sPL_I, color='black', lw=2)

    return (f_bPL_NG, min_OmGW_bPL_NG, max_OmGW_bPL_NG, f_sPL_NG,
            min_OmGW_sPL_NG, max_OmGW_sPL_NG, f_sPL_P, min_OmGW_sPL_P,
            max_OmGW_sPL_P, f_sPL_E_old, min_OmGW_sPL_E_old, max_OmGW_sPL_E_old,
            f_sPL_E, min_OmGW_sPL_E, max_OmGW_sPL_E, f_sPL_I, min_OmGW_sPL_I,
            max_OmGW_sPL_I)

def plot_PTA_CP_delay(betas=[], ff='tdel', save=True, exclude=False):

    """
    Function that plots the common-process (CP) time delay (in seconds) as
    a function of frequency for the different amplitudes and slopes of the
    stochastic GW background reported by the PTA collaborations
    using a single PL or a broken PL.

    It generates the plot of figure 3 (lower panel) of A. Roper
    Pol, C. Caprini, A. Neronov, D. Semikoz, "The gravitational wave signal from
    primordial magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    Arguments:
        betas -- array of slopes of the GW energy density spectrum considered
                (default beta in the range from -2 to 5)
        ff -- option to chose what function to plot (default 'tdel' for time
              delay in seconds, 'Sf' for power spectral density, 'hc' for
              characteristic amplitude spectrum, and 'Om' for GW energy density
              spectrum)
        save -- option to save the plot in plots/'ff'_PTA_f.pdf
                (default True)
        exclude -- option to plot the upper limit lines of the 2sigma values
                   of the PTA observations (default False)
    """

    if len(betas) != 0: save = False

    plt.figure(figsize=(12, 8))

    (f_bPL_NG, min_OmGW_bPL_NG, max_OmGW_bPL_NG, f_sPL_NG, min_OmGW_sPL_NG,
    max_OmGW_sPL_NG, f_sPL_P, min_OmGW_sPL_P, max_OmGW_sPL_P, f_sPL_E_old,
    min_OmGW_sPL_E_old, max_OmGW_sPL_E_old, f_sPL_E, min_OmGW_sPL_E,
    max_OmGW_sPL_E, f_sPL_I, min_OmGW_sPL_I, max_OmGW_sPL_I) = \
                    plot_PTA_all(ff=ff, betas=betas)

    # duration of observations for NANOGrav
    T_NG = 12.5*u.yr
    T_NG = T_NG.to(u.s)
    # duration of observations for PPTA
    T_P = 15*u.yr
    T_P = T_P.to(u.s)
    # duration of observations for EPTA
    T_E = 24*u.yr
    T_E = T_E.to(u.s)
    # duration of observations for IPTA
    T_I = 31*u.yr
    T_I = T_I.to(u.s)

    if exclude:

        # read files
        cwd = os.getcwd()
        os.chdir('../detector_sensitivity/PTA/')
        fil_NG = pd.read_csv('excluded_max_NG12p5yr.csv')
        fil_EPTA = pd.read_csv('excluded_max_EPTA24yr.csv')
        fil_PPTA = pd.read_csv('excluded_max_PPTA15yr.csv')
        fil_IPTA = pd.read_csv('excluded_max_IPTA_DR2.csv')
        os.chdir(cwd)

        # observations excluded by NG
        ff_NG = np.array(fil_NG['f'])*u.Hz
        PP_NG = np.array(fil_NG['CP'])
        inds_NG = np.argsort(ff_NG)

        # observations excluded by EPTA
        ff_EPTA = np.array(fil_EPTA['f'])*u.Hz
        PP_EPTA = np.array(fil_EPTA['CP'])
        inds_EPTA = np.argsort(ff_EPTA)

        # observations excluded by PPTA
        ff_PPTA = np.array(fil_PPTA['f'])*u.Hz
        PP_PPTA = np.array(fil_PPTA['Sf'])
        inds_PPTA = np.argsort(ff_PPTA)

        # observations excluded by IPTA
        ff_IPTA = np.array(fil_IPTA['f'])*u.Hz
        PP_IPTA = np.array(fil_IPTA['CP'])
        inds_IPTA = np.argsort(ff_IPTA)

        if ff == 'Sf' or ff == 'Om':
            PP_NG = PP_NG**2*T_NG
            PP_EPTA = PP_EPTA**2*T_E
            PP_IPTA = PP_IPTA**2*T_I
            if ff == 'Om':
                hc_NG = cosmoGW.hc_Sf(ff_NG, PP_NG)
                PP_NG = cosmoGW.hc_OmGW(ff_NG, hc_NG, d=-1)
                hc_EPTA = cosmoGW.hc_Sf(ff_EPTA, PP_EPTA)
                PP_EPTA = cosmoGW.hc_OmGW(ff_EPTA, hc_EPTA, d=-1)
                hc_PPTA = cosmoGW.hc_Sf(ff_PPTA, PP_PPTA)
                PP_PPTA = cosmoGW.hc_OmGW(ff_PPTA, hc_PPTA, d=-1)
                hc_IPTA = cosmoGW.hc_Sf(ff_IPTA, PP_IPTA)
                PP_IPTA = cosmoGW.hc_OmGW(ff_IPTA, hc_IPTA, d=-1)

        elif ff == 'tdel':
            PP_PPTA = np.sqrt(PP_PPTA/T_P)
            PP_EPTA = np.sqrt(PP_EPTA/T_E)
            PP_NG = np.sqrt(PP_NG/T_NG)
            PP_IPTA = np.sqrt(PP_IPTA/T_I)

        plt.plot(ff_NG[inds_NG], PP_NG[inds_NG], '--', color='blue')
        plt.plot(ff_PPTA[inds_PPTA], PP_PPTA[inds_PPTA], '--', color='red')
        plt.plot(ff_EPTA[inds_EPTA], PP_EPTA[inds_EPTA], '--', color='purple')
        plt.plot(ff_IPTA[inds_IPTA], PP_EPTA[inds_IPTA], '--', color='black')

    yxPP = 2e-10
    ffPP = 2e-8
    yxNGb = 2.7e-9
    ffNGb = 3e-9
    yxNGs = 1.3e-7
    ffNGs = 1e-8
    yxEE = 6.5e-8
    ffEE = 1.5e-9
    yxII = 1.2e-7
    ffII = 1.25e-9
    if ff == 'Sf' or ff == 'hc' or ff == 'Om':
        yxNGb = yxNGb**2*T_NG.value
        yxNGs = yxNGs**2*T_NG.value
        yxPP = yxPP**2*T_P.value
        yxEE = yxEE**2*T_E.value
        yxII = yxII**2*T_I.value
        if ff == 'hc' or ff == 'Om':
            yxPP = cosmoGW.hc_Sf(ffPP, yxPP)*3
            yxEE = cosmoGW.hc_Sf(ffEE, yxEE)*1.1
            yxNGb = cosmoGW.hc_Sf(ffNGb, yxNGb)*5
            yxNGs = cosmoGW.hc_Sf(ffNGs, yxNGs)/55
            ffNGs = ffNGs/6
            ffNGb = ffNGb*2
            yxII = cosmoGW.hc_Sf(ffII, yxII)*1.1
            if ff == 'Om':
                yxPP = cosmoGW.hc_OmGW(ffPP*u.Hz, yxPP, d=-1)*3
                ffPP = ffPP*1.7
                yxEE = cosmoGW.hc_OmGW(ffEE*u.Hz, yxEE, d=-1)*10
                yxII = cosmoGW.hc_OmGW(ffII*u.Hz, yxII, d=-1)*3
                yxNGb = cosmoGW.hc_OmGW(ffNGb*u.Hz, yxNGb, d=-1)*2.7
                yxNGs = cosmoGW.hc_OmGW(ffNGs*u.Hz, yxNGs, d=-1)*10
                ffNGs = ffNGs*2.3
                ffII = ffII/1.3
                ffEE = ffEE/1.3
    plt.text(ffNGb, yxNGb, 'NANOGrav broken PL', color='blue', fontsize=14,
             bbox=dict(facecolor='white', edgecolor='none',
                       boxstyle='round,pad=.2'))
    plt.text(ffNGs, yxNGs, 'NANOGrav single PL', color='darkgreen', fontsize=14,
             bbox=dict(facecolor='white', edgecolor='none',
                       boxstyle='round,pad=.2'))
    plt.text(ffPP, yxPP, 'PPTA single PL', color='red', fontsize=14)
    plt.text(ffEE, yxEE, 'EPTA single PL', color='purple', fontsize=14)
    plt.text(ffII, yxII, 'IPTA single PL', color='black', fontsize=14)

    plt.xscale('log')
    plt.yscale('log')
    plot_sets.axes_lines()
    plt.xlabel('$f$ [Hz]')
    if ff == 'tdel': ylab = 'CP delay $(f)$ [s]'
    if ff == 'Sf': ylab = r'$P (f) \ \Bigl[{\rm s}^3\Bigr]$'
    if ff == 'hc': ylab = r'$h_{\rm c} (f)$'
    if ff == 'Om': ylab = r'$h^2 \Omega_{\rm GW}^0 (f)$'
    plt.ylabel(ylab)
    yl0 = 5e-11
    yl1 = 2e-6
    ff0 = 8e-10
    ff1 = 1e-7
    if ff == 'Sf' or ff == 'hc' or ff == 'Om':
        yl0 = yl0**2*T_P.value
        yl1 = yl1**2*T_P.value
        if ff == 'hc' or ff == 'Om':
            yl0 = cosmoGW.hc_Sf(ff0, yl0)*1000
            yl1 = cosmoGW.hc_Sf(ff1, yl1)/600
            if ff == 'Om':
                yl0 = cosmoGW.hc_OmGW(ff0*u.Hz, yl0, d=-1)*30
                yl1 = cosmoGW.hc_OmGW(ff1*u.Hz, yl1, d=-1)
                plt.yticks(np.logspace(-12, -4, 9))
    plt.ylim(yl0, yl1)
    plt.xlim(ff0, ff1)
    f1yr = 1/u.yr
    f1yr = f1yr.to(u.Hz)
    plt.vlines(f1yr.value, yl0/1000, yl1*1000, color='black', ls='-.', lw=.8)
    plt.text(3.4e-8, 1e-11, r'$f_{\rm yr}$', fontsize=18)

    if save: plt.savefig('plots/' + ff + '_PTA_f.pdf',
                         bbox_inches='tight')
#
# def plot_PTA_freq(ff='Om', betas=[], flim=1.25e-8, exclude=True, save=True):
#
#     import pandas as pd
#
#     plot_nanograv_PPTA_CP_delay(betas=betas, ff=ff, exclude=exclude, save=False)
#
#     plt.vlines(flim, 1e-13, 1e-3, color='black', ls='-.', lw=.8)
#     plt.text(3.4e-8, 1e-11, r'$f_{\rm yr}$', fontsize=18)
#     plt.text(1.3e-8, 2e-12, r'$f = 1.25 \times 10^{-8}$\,Hz', fontsize=14)
#
#     if save: plt.savefig('plots/CP_NANOGrav_PPTA_' + ff + '.pdf',
#                          bbox_inches='tight')

def plot_upper_lower_Omega(obs='NG_bPL', T='150', g=15, ss='2s', col='blue',
                           plot=True):

    """
    Function that plots the limiting regions of the SGWB spectrum (upper and
    lower limits at each frequency) generated by MHD turbulence produced by
    a primordial magnetic fields, compatible with the PTA results from one of
    the observatories at a fixed temperature T_*.

    It reads the results from the analysis performed using analysis_PTA,
    which generates pickle variables with the required results under the
    directory results_analysis (check first if these are already available)

    Arguments:
        obs -- choose PTA observatory (default is 'NG_bPL', other options are
               'NG_sPL', 'EPTA', 'PPTA', and 'IPTA')
        T -- temperature T_* expressed as a string in MeV (default '150')
        g -- relativistic dof at the time of generation (default 15)
        ss -- choose level of confidence of the resaults (default is '2s',
              other option is '1s' if it is previously computed)
        col -- color of the plot (default 'blue')
        plot -- option to plot the lines (default True)

    Returns:
        f -- array of frequencies
        min_OmGW, max_OmGW -- minimum and maximum limits of the superposition
                              of the SGWB spectra at each frequency
    """

    import pickle

    f = open('results_analysis/pos_PTA/pos_' + obs + '_' + ss + '_T' + \
                    T + '.pckl', 'rb')
    k, Om, pos = pickle.load(f)
    f.close()

    ks = np.logspace(-3, 3, 1000)
    T = float(T)*u.MeV
    fs = cosmoGW.shift_frequency_today(ks, T, g)

    tini = 1
    _, OmGW_env_k, _ = an.OmGW_from_OmM_kM_env_tfin_fit(Om, k, ks,
                                                        tini=tini, FF=1,
                                                        A=1, multi=True)
    OmGW_env = cosmoGW.shift_onlyOmGW_today(OmGW_env_k, g)

    max_OmGW = np.zeros(len(fs))
    min_OmGW = np.zeros(len(fs)) + 1

    for i in range(0, len(k)):
        for j in range(0, len(Om)):
            if pos[i, j]:
                if Om[j] <= 0.1 and k[i] >= 2*np.pi:
                    min_OmGW = np.minimum(min_OmGW, OmGW_env[:, i, j])
                    max_OmGW = np.maximum(max_OmGW, OmGW_env[:, i, j])

    obs_s = ''
    if obs == 'NG_bPL': obs_s = 'NANOGrav broken PL'
    elif obs == 'NG_sPL': obs_s = 'NANOGrav single PL'
    else: obs_s = obs

    if plot:
        plt.plot(fs, min_OmGW, color=col, ls='--', lw=2)
        plt.plot(fs, max_OmGW, color=col, label=obs_s, lw=2)

    return fs, min_OmGW, max_OmGW

def plot_upper_lower_Omega_PTA(T='150', ss='2s', g=15, save=True, plot=True):

    """
    Function that plots the limiting regions of the SGWB spectrum (upper and
    lower limits at each frequency) generated by MHD turbulence produced by
    a primordial magnetic field, compatible with the PTA results (NANOGrav bPL
    and sPL, EPTA, PPTA and IPTA) at a fixed temperature T_*.

    It generates the plots of figure 4 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    It reads the results from the analysis performed using analysis_PTA,
    which generates pickle variables with the required results under the
    directory results_analysis (check first if these are already available).

    Arguments:
        obs -- choose PTA observatory (default is 'NG_bPL', other options are
               'NG_sPL', 'EPTA', 'PPTA', and 'IPTA')
        T -- temperature T_* expressed as a string in MeV (default '150')
        g -- relativistic dof at the time of generation (default 15)
        ss -- choose level of confidence of the results (default is '2s',
              other option is '1s' if it is previously computed)
        plot -- option to plot the contour (default True)
        save -- option to save the plot in plots/OmGW_compatible_'T'.pdf
                (default True)
    """

    if plot: plt.figure(figsize=(12, 8))

    betas = np.linspace(1, 3, 100)

    (f_bPL_NG, min_OmGW_bPL_NG, max_OmGW_bPL_NG, f_sPL_NG, min_OmGW_sPL_NG,
    max_OmGW_sPL_NG, f_sPL_P, min_OmGW_sPL_P, max_OmGW_sPL_P, f_sPL_E_old,
    min_OmGW_sPL_E_old, max_OmGW_sPL_E_old, f_sPL_E, min_OmGW_sPL_E,
    max_OmGW_sPL_E, f_sPL_I, min_OmGW_sPL_I, max_OmGW_sPL_I) = \
                    plot_PTA_all(ff='Om', betas=betas, lines=False)

    fs_NG_bPL, min_OmGW_NG_bPL, max_OmGW_NG_bPL = \
            plot_upper_lower_Omega(obs='NG_bPL', T=T, ss=ss, g=g, col='blue',
                                   plot=True)
    fs_NG_sPL, min_OmGW_NG_sPL, max_OmGW_NG_sPL = \
            plot_upper_lower_Omega(obs='NG_sPL', T=T, ss=ss, g=g,
                                   col='darkgreen', plot=True)
    fs_P, min_OmGW_P, max_OmGW_P = \
            plot_upper_lower_Omega(obs='PPTA', T=T, ss=ss, g=g, col='red',
                                   plot=True)
    fs_E, min_OmGW_E, max_OmGW_E = \
            plot_upper_lower_Omega(obs='EPTA', T=T, ss=ss, g=g, col='purple',
                                   plot=True)
    fs_I, min_OmGW_I, max_OmGW_I = \
            plot_upper_lower_Omega(obs='IPTA', T=T, ss=ss, g=g, col='black',
                                   plot=True)

    if plot:
        plot_sets.axes_lines()
        plt.xscale('log')
        plt.yscale('log')
        plt.xlabel('$f$ [Hz]')
        plt.ylabel(r'$h^2 \Omega_{\rm GW}^0 (f)$')
        ymin = 1e-12
        ymax = 1e-7
        xmin = 3e-10
        xmax = 2e-7
        plt.xlim(xmin, xmax)
        plt.ylim(ymin, ymax)

        #plt.legend(loc='upper left', frameon=False, fontsize=18)
        plt.title('$T_* = %s$ MeV, $g_* = %s$'%(T, g), pad=15)
        plt.vlines(1.25e-8, 1e-12, 1e-7, color='black', ls='-.')
        plt.vlines(9e-9, 1e-12, 1e-7, color='black', ls='-.', lw=.8)

    ax = plt.gca()
    line_EPTA, = ax.fill(np.nan, np.nan, color='purple', alpha=.2,
                         label='EPTA')
    line_PPTA, = ax.fill(np.nan, np.nan, color='red', alpha=.1,
                         label='PPTA')
    line_NG_sPL, = ax.fill(np.nan, np.nan, color='darkgreen', alpha=.1,
                           label='NANOGrav single PL')
    line_NG_bPL, = ax.fill(np.nan, np.nan, color='blue', alpha=.3,
                           label='NANOGrav broken PL')
    line_IPTA, = ax.fill(np.nan, np.nan, color='black', alpha=.2,
                           label='IPTA')
    handles = [line_NG_bPL, line_NG_sPL, line_PPTA, line_EPTA, line_IPTA,]
    plt.legend(handles=handles, fontsize=18, frameon=False)

    if save: plt.savefig('plots/OmGW_compatible_T%s.pdf'%T,
                         bbox_inches='tight')


def plot_contour_PTA(obs='NG_bPL', T='150', ss='2s', text=True,
                     plot=True, ret=False, col='blue', alp=.8):

    """
    Function that plots the contours of k_* and OmM parameters of the magnetic
    field that are compatible with the PTA results from one of the
    observatories at a fixed temperature T_*.

    It reads the results from the analysis performed using analysis_PTA,
    which generates pickle variables with the required results under the
    directory results_analysis (check first if these are already available)

    Arguments:
        obs -- choose PTA observatory (default is 'NG_bPL', other options are
               'NG_sPL', 'EPTA', 'PPTA', and 'IPTA')
        T -- temperature T_* expressed as a string in MeV (default '150')
        ss -- choose level of confidence of the resaults (default is '2s',
              other option is '1s' if it is previously computed)
        plot -- option to plot the contour (default True)
        ret -- option to return the 2D space parameters kij, OmMij, and the
               2D array of the allowed region pos (default False)
        col -- color of the plot (default 'blue')
        alp -- option to change the transparecy of the filled contours
               (default 0.8)

    Returns (if ret is True):
        kij -- 2d array of characteristic scales of the magnetic field
        OmMij -- 2d array of magnetic energy density amplitudes
        pos -- 2d boolean array for the possible parameters compatible with
               the PTA results from 'obs' (1 or 0)
    """

    import pickle

    f = open('results_analysis/pos_PTA/pos_' + obs + '_' + ss + '_T' + \
                    T + '.pckl', 'rb')

    k, Om, pos = pickle.load(f)
    f.close()

    kij, Omij = np.meshgrid(k, Om, indexing='ij')
    if plot:
        plt.contour(kij, Omij, pos, levels=[.5, 1],
                    colors=[col, 'red'])
        plt.contourf(kij, Omij, pos, levels=[.5, 1],
                     colors=[col, 'red'], alpha=alp)

        if text:
            print(obs, T, ' MeV', '\n', 'range of k_*: (',
                  np.min(kij[np.where(pos)]), ',', np.max(kij[np.where(pos)]),
                  ')', '\n', 'range of OmM: (', np.min(Omij[np.where(pos)]),
                  ',', np.max(Omij[np.where(pos)]), ') \n')

    if ret: return kij, Omij, pos

def plot_contour_all(T='150', g=15, ss='2s', save=True, ret=False, plot=True,
                     text=False, comp_txt=True):

    """
    Function that plots the contours of k_* and OmM parameters of the magnetic
    field that are compatible with the PTA results from all the PTA
    observatories (NANOGrav bPL and sPL, EPTA, PPTA and IPTA) at a fixed
    temperature T_*.

    It generates the plots of figure 5 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    It reads the results from the analysis performed using analysis_PTA,
    which generates pickle variables with the required results under the
    directory results_analysis (check first if these are already available).

    Arguments:
        T -- temperature T_* expressed as a string in MeV (default '150')
        ss -- choose level of confidence of the resaults (default is '2s',
              other option is '1s' if it is previously computed)
        plot -- option to plot the contour (default True)
        ret -- option to return the 2D space parameters kij, OmMij, and the
               2D array of the allowed region pos (default False)
        save -- option to save the plot in plots/pars_compatible_'T'.pdf
                (default True)
        text -- option to print text with the limits of k_* and Omega_M^* that
                are compatible at each T_* for each PTA observatory
                (default False)
        comp_txt -- option to omit warning text when the resulting SGWB is not
                    compatible with a PTA observatory at T_* (default True)

    Returns (only if ret is set to True):
        ret_NG_bPL, ret_NG_sPL, ret_EPTA, ret_PPTA, ret_IPTA --
                    objects that contain the following information for NG bPL,
                    NG sPL, EPTA, PPTA, and IPTA:

                        kij -- 2d array of characteristic scales of the
                               magnetic field
                        OmMij -- 2d array of magnetic energy density amplitudes
                        pos -- 2d boolean array for the possible parameters
                               compatible with the PTA results from 'obs'
                               (1 or 0)
    """

    if plot: plt.figure(figsize=(8,5))
    OmM_LPE = np.logspace(-3, 0, 100)
    kLPE = 2*np.pi/np.sqrt(3/2*OmM_LPE)
    if plot: plt.plot(kLPE, OmM_LPE, color='black', ls='-.')

    obss = np.array(['NG_bPL', 'NG_sPL', 'EPTA', 'PPTA', 'IPTA'])
    alps = np.array([.3, .2, .2, .1, .1])
    cols = np.array(['blue', 'darkgreen', 'purple', 'red', 'black'])
    for j in range(0, len(obss)):
        if obss[j] == 'NG_bPL': obs_s = 'NANOGrav bPL'
        elif obss[j] == 'NG_sPL': obs_s = 'NANOGrav sPL'
        else: obs_s = obss[j]
        try:
            ret = plot_contour_PTA(obs=obss[j], T=T, ss=ss, ret=ret, text=text,
                                   plot=plot, alp=alps[j], col=cols[j])
            if obss[j] == 'NG_bPL': ret_NG_bPL = ret
            elif obss[j] == 'NG_sPL': ret_NG_sPL = ret
            elif obs_s == 'EPTA': ret_EPTA = ret
            elif obs_s == 'PPTA': ret_PPTA = ret
            elif obs_s == 'IPTA': ret_IPTA = ret
        except:
            if comp_txt:
                print('T = %s MeV is not compatible with %s'%(T, obs_s))
            if obss[j] == 'NG_bPL': ret_NG_bPL = [[], [], []]
            elif obss[j] == 'NG_sPL': ret_NG_sPL = [[], [], []]
            elif obs_s == 'EPTA': ret_EPTA = [[], [], []]
            elif obs_s == 'PPTA': ret_PPTA = [[], [], []]
            elif obs_s == 'IPTA': ret_IPTA = [[], [], []]

    if plot:
        plt.vlines(2*np.pi, 1e-3, .1, color='black', ls='-.')
        plt.hlines(.1, 2*np.pi, 3000, color='black', ls='-.')
        plt.yscale('log')
        plt.xlim(1, 2e2)
        if float(T) < 1: plt.xlim(1, 1e3)
        plt.ylim(3e-3, 1)
        plot_sets.axes_lines()
        plt.xlabel('$k_* {\cal H}_*^{-1}$')
        plt.ylabel(r'$\Omega_{\rm M}^*$')
        plt.title('$T_* = %s$ MeV, $g_* = %i$'%(T, g), pad=15)
        plt.text(42, 2e-2, r'$k_{\rm LPE} {\cal H}_*^{-1}$', fontsize=24,
                 color='black')
        plt.text(6.8, 4.5e-3, r'$k_* = 2\pi {\cal H}_*$', fontsize=24,
                 color='black')
        plt.text(50, 5.5e-2, r'$\Omega_{\rm M}^* = 0.1$', fontsize=24,
                 color='black')
        plt.xscale('log')

    if save: plt.savefig('plots/pars_compatible_T%s.pdf'%T,
                         bbox_inches='tight')

    if ret: return ret_NG_bPL, ret_NG_sPL, ret_EPTA, ret_PPTA, ret_IPTA

def plot_kbr(T='100', g=10, col='blue', obs='NG_bPL', text=True, plot=True):

    """
    Function that plots the positions of the break frequencies at a fixed
    temperature for one of the PTA collaborations.

    Arguments:
        T -- temperature scale in MeV as a string (default '100')
        g -- relativistic degrees of freedom (default 10)
        col -- color of the plot (default 'blue')
        obs -- choose PTA observatory (default is 'NG_bPL', other options are
               'NG_sPL', 'EPTA', 'PPTA', and 'IPTA')
        text -- option to print out limits of fbr (default True)
        plot -- option to plot the values of the break frequencies
                (default True)
    """

    ret_NG_bPL, ret_NG_sPL, ret_EPTA, ret_PPTA, ret_IPTA = \
            plot_contour_all(T=T, ret=True, plot=False,
                             comp_txt=text)
    #ret_NG_bPL, ret_PPTA = \
    if obs == 'NG_bPL':
        kij, Omij, pos = ret_NG_bPL
        obss = 'NANOGrav broken PL'
        alp = .7
    elif obs == 'NG_sPL':
        kij, Omij, pos = ret_NG_sPL
        obss = 'NANOGrav single PL'
        alp = 1.
    elif obs == 'EPTA':
        kij, Omij, pos = ret_EPTA
        obss = 'EPTA single PL'
        alp = .2
    elif obs == 'PPTA':
        kij, Omij, pos = ret_PPTA
        obss = 'PPTA single PL'
        alp = .4
    elif obs == 'IPTA':
        kij, Omij, pos = ret_IPTA
        obss = 'IPTA single PL'
        alp = .4
    comp = True
    if kij != []: kbrs = an_pta.kbr_pos(kij, Omij, pos)
    else: comp = False
    try: TT = int(T)
    except: TT = float(T)
    if comp:
        fbrs = cosmoGW.shift_frequency_today(kbrs, TT*u.MeV, g)
        if plot:
            plt.figure(1)
            plt.plot(kbrs, TT*kbrs**0, '.', color=col, alpha=alp)
            plt.figure(2)
            plt.plot(fbrs, TT*kbrs**0, '.', color=col, alpha=alp)
        if len(kbrs) and text:
                print(obs, T, 'MeV: (', np.min(fbrs.value), ',', np.max(fbrs.value),
                      ') Hz')
        return fbrs
    else:
        return []

def plot_all_kbr(T='100', g=10, text=True, plot=True):

    """
    Function that plots the positions of the break frequencies at a fixed
    temperature for all the PTA collaborations (NANOGrav bPL and sPL, EPTA,
    PPTA, and IPTA).

    Arguments:
        T -- temperature scale in MeV as a string (default '100')
        g -- relativistic degrees of freedom (default 10)
        text -- option to print out limits of fbr (default True)
        plot -- option to plot the values of the break frequencies
                (default True)
    """

    fbrs_PPTA = plot_kbr(T=T, col='red', obs='PPTA', text=text, plot=plot)
    fbrs_EPTA = plot_kbr(T=T, col='purple', obs='EPTA', text=text, plot=plot)
    fbrs_NG_bPL = plot_kbr(T=T, col='blue', obs='NG_bPL', text=text, plot=plot)
    fbrs_NG_sPL = plot_kbr(T=T, col='darkgreen', obs='NG_sPL', text=text,
                           plot=plot)
    fbrs_IPTA = plot_kbr(T=T, col='black', obs='IPTA', text=text, plot=plot)

    if plot:
        plt.figure(1)
        plot_sets.axes_lines()
        plt.xlabel(r'$k_{\rm br} {\cal H}_*^{-1}$')
        plt.ylabel('$T_*$ [MeV]')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim(3e-1, 5)

        plt.figure(2)
        plot_sets.axes_lines()
        plt.xlabel(r'$f_{\rm br}$ [Hz]')
        plt.ylabel('$T_*$ [MeV]')
        plt.xscale('log')
        plt.yscale('log')

    return fbrs_PPTA, fbrs_EPTA, fbrs_NG_bPL, fbrs_NG_sPL, fbrs_IPTA

def plot_all_kbr_all_T(save=True, text=True, interp=True, plot_all=True):

    """
    Function that plots the positions of the break frequencies at all
    temperatures for all the PTA collaborations (NANOGrav bPL and sPL, EPTA,
    PPTA, and IPTA).

    It generates the plot of figure 6 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    Arguments:
        save -- option to save the plot in plots/fbr_T.pdf
                (default True)
        text -- option to print out limits of fbr (default True)
        interp -- option to interpolate the results for the missing T_* and
                  generate the regions of f_br and T_* compatible with PTA
                  (default True)
        plot_all -- option to generate 2 additional plots, with the x-axis
                    being the discretized values of the normalized wave numbers
                    of the break position and the frequencies (default True)
    """

    if text: print('Range of break frequencies: \n')

    if plot_all:
        plt.figure(1, figsize=(12,8))
        plt.figure(2, figsize=(12,8))
        if interp: plt.figure(3, figsize=(12,8))
    else: plt.figure(figsize=(12,8))

    TT = ['0.1', '0.2', '0.3', '0.5', '0.7', '0.8', '1', '1.2', '1.4', '1.6',
          '2', '3', '3.5', '4', '5', '7', '10', '12', '15', '20', '30', '38',
          '50', '60', '75', '100', '125', '150', '160', '175', '200', '225',
          '250', '275', '300', '325']
    fbrs_all = [[], [], [], [], []]
    for i in TT:
        fbrs_PPTA, fbrs_EPTA, fbrs_NG_bPL, fbrs_NG_sPL, fbrs_IPTA = \
                    plot_all_kbr(T=i, text=text, plot=plot_all)
        fbrs_all[0].append(fbrs_PPTA)
        fbrs_all[1].append(fbrs_EPTA)
        fbrs_all[2].append(fbrs_NG_bPL)
        fbrs_all[3].append(fbrs_NG_sPL)
        fbrs_all[4].append(fbrs_IPTA)
    fbrs_all = np.array(fbrs_all, dtype='object')
    ax = plt.gca()
    line_EPTA, = ax.fill(np.nan, np.nan, color='purple', alpha=.3,
                         label='EPTA')
    line_PPTA, = ax.fill(np.nan, np.nan, color='red', alpha=.3,
                         label='PPTA')
    line_NG_sPL, = ax.fill(np.nan, np.nan, color='darkgreen', alpha=.3,
                           label='NANOGrav single PL')
    line_NG_bPL, = ax.fill(np.nan, np.nan, color='blue', alpha=.3,
                           label='NANOGrav broken PL')
    line_IPTA, = ax.fill(np.nan, np.nan, color='black', alpha=.3,
                           label='IPTA')
    handles = [line_NG_bPL, line_NG_sPL, line_PPTA, line_EPTA, line_IPTA,]
    plt.legend(handles=handles, fontsize=18, frameon=False)

    #handles = [line_NG_bPL, line_NG_sPL, line_PPTA, line_EPTA, line_IPTA,]

    if plot_all:
        plt.figure(2)
        #plt.legend(handles=handles, fontsize=18, frameon=False)
        if save: plt.savefig('plots/fbr_T.pdf',
                             bbox_inches='tight')

    if interp:
        if plot_all: plt.figure(3)
        plot_sets.axes_lines()
        plt.xlabel(r'$f_{\rm br}$ [Hz]')
        plt.ylabel('$T_*$ [MeV]')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim(3e-11, 6e-9)
        plt.ylim(.5, 300)
        plt.legend(handles=handles, fontsize=18, frameon=False,
                   loc='lower right')
        NN = np.shape(fbrs_all)
        fbrs_min = np.zeros(NN)*u.Hz
        fbrs_max = np.zeros(NN)*u.Hz
        T = np.array(TT, dtype='float')
        for i in range(0, NN[1]):
            min_fbrs = 1*u.Hz
            max_fbrs = 0*u.Hz
            for j in range(0, NN[0]):
                if np.size(fbrs_all[j][i]) != 0:
                    fbrs_min[j, i] = min(fbrs_all[j][i])
                    fbrs_max[j, i] = max(fbrs_all[j][i])
                    min_fbrs = min(min_fbrs, fbrs_min[j, i])
                    max_fbrs = max(max_fbrs, fbrs_max[j, i])
            if min_fbrs.value < 1:
                plt.hlines(T[i], min_fbrs.value, max_fbrs.value,
                           color='black', lw=.4, ls='-.')

        alps = np.array([.3, .3, .3, .3, .3])
        cols = np.array(['red', 'purple', 'blue', 'darkgreen', 'black'])
        T00 = np.array([1.6, 1.2, 2, 3.5, .8])
        T11 = np.array([175, 150, 150, 150, 150])
        for i in range(0, NN[0]):
            T2 = np.logspace(np.log10(T00[i]), np.log10(T11[i]), 1000)
            fbrs_min2 = np.interp(T2, T, fbrs_min[i, :])
            fbrs_max2 = np.interp(T2, T, fbrs_max[i, :])
            plt.fill_betweenx(T2, fbrs_min2, fbrs_max2,
                              alpha=alps[i], color=cols[i])
            plt.plot(fbrs_min2, T2, color=cols[i], lw=2)
            plt.plot(fbrs_max2, T2, color=cols[i], lw=2)
        if save: plt.savefig('plots/fbr_T_interp.pdf',
                             bbox_inches='tight')

    return TT, fbrs_all

def plot_SGWB_comparison(OmM=0.1, OmM_infl=0.04, kM=10, T=100, g=10,
                         text=True, save=True):

    """
    Function that plots the SGWB produced by the analytical model derived
    and validated by numerical simulations in A. Roper Pol, C. Caprini,
    A. Neronov, D. Semikoz, "The gravitational wave signal from primordial
    magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630 (2022).
    It corresponds to their figure 8.

    This model assumes that the initial magnetic field is present and omits
    the magnetogenesis dynamics.

    The plot compares the resulting SGWB with that of:

        - A driven field from MHD turbulence at the QCD phase transition, using
        the results from A. Brandenburg, E. Clarke, Y. He, T. Kahniashvili,
        "Can we observe the QCD phase transition-generated gravitational waves
        through pulsar timing arrays?," Phys. Rev. D 104, 043513 (2021),
        https://arxiv.org/abs/2102.12428

        - An inflationary magnetogenesis scenario with a SGWB produced during
        the reheating era, with an end-of-reheating scale of the order of the
        QCD phase transition, using the results from Y. He, A. Roper Pol,
        A. Brandenburg, "Leading-order nonlinear gravitational waves from
        reheating magnetogeneses", https://arxiv.org/abs/2110.14456 (2021).

    Arguments:
        OmM -- value of the magnetic field energy density of the SGWB used
               in the current model, of that from Clarke et al 21 and of the
               helical one from He et al 21 (default 0.1)
        OmM_infl -- value of the magnetic field energy density of the
                    non-helical SGWB from He et al 21 (default 0.04)
        kM -- value of the magnetic spectral peak of the SGWB used
              in the current model and that from Clarke et al 21 (default 10)
        T -- temperature scale in MeV at the time of generation of the SGWB used
              in the current model and that from Clarke et al 21 (default 100)
        g -- relativistic dof at the time of generation of the SGWB used
              in the current model and that from Clarke et al 21 (default 10)
        text -- option to print the details of the SGWB resulting from the
                inflationary model of He et al 21 (default True)
        save -- option to save the plot in plots/SGWB_comparison.pdf
                (default True)
    """

    os.chdir(HOME)

    # Read the results from the QCD PT runs of Clarke et al. 2021
    print('Reading run from Clarke et al. 2021 \n')
    dirs_QCD = {}
    dirs_QCD = rd('GW_QCD_Clarke_2021', dirs_QCD)
    R = [s for s in dirs_QCD]
    # read the runs stored in the pickle variables
    runs_QCD = r.load_runs(R, HOME + '/GW_QCD_Clarke_2021/', dirs_QCD,
                           quiet=False)

    # Read the results from the inflationary magnetogenesis scenario of He
    # et al. 2021
    print('\nReading runs from He et al. 2021 \n')
    dirs_mem = {}
    dirs_mem = rd('memory_toff_b27_01_linear', dirs_mem)
    R = [s for s in dirs_mem]
    runs_memory = r.load_runs(R, HOME + '/memory_effect/', dirs_mem,
                              quiet=False)

    os.chdir(dir0)

    # Obtain SGWB from Clarke et al data
    run = runs_QCD.get('QCD_run7')
    k = run.spectra.get('k')[1:]
    EGW = run.spectra.get('EGW')[:, 1:]
    t = run.spectra.get('t_EGW')
    EGW_stat = np.trapz(EGW[-20:-1, :], t[-20:-1], axis=0)/(t[-1] - t[-20])
    comp_M = OmM/run.OmMmax
    comp_k = kM/run.kfM
    EGW_comp = EGW_stat*comp_M**2/comp_k**2
    f_QCD, OmGW_QCD = cosmoGW.shift_OmGW_today(k*comp_k, EGW_comp*k,
                                               T*u.MeV, g)

    # Obtain SGWBs from He et al data
    run = runs_memory.get('D2_l_toff')
    TD = run.pars[0]*u.GeV
    gD = run.pars[1]
    betD = run.pars[3]
    gamD = run.pars[2]
    kD = cosmoGW.ks_infla(betD, gamD)
    t = run.ts.get('t')
    indt = np.argmin(abs(t - 1.))
    EEMD = run.ts.get('EEEM')[indt]
    hh = 'helical'
    if gamD == 0: hh = 'non-helical'
    if text:
        print('\nInflationary', hh,  'run, k:', kD, ', OmM:', EEMD, ', T:',
              TD)
    k = run.spectra.get('k')[1:]
    EGW_stat = run.spectra.get('EGW_stat')[1:]
    f_D, OmGW_D = cosmoGW.shift_OmGW_today(k, EGW_stat*k, TD, gD)

    run = runs_memory.get('B2_l_toff')
    TB = run.pars[0]*u.GeV
    gB = run.pars[1]
    betB = run.pars[3]
    gamB = run.pars[2]
    kB = cosmoGW.ks_infla(betB, gamB)
    t = run.ts.get('t')
    indt = np.argmin(abs(t - 1.))
    EEMB = run.ts.get('EEEM')[indt]
    hh = 'helical'
    if gamB == 0: hh = 'non-helical'
    if text:
        print('\nInflationary', hh,  'run, k:', kB, ', OmM:', EEMB, ', T:',
              TB)
    k = run.spectra.get('k')[1:]
    EGW_stat = run.spectra.get('EGW_stat')[1:]
    f_B, OmGW_B = cosmoGW.shift_OmGW_today(k, EGW_stat*k, TB, gB)

    plt.figure(figsize=(12, 8))
    plot_sets.axes_lines()
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('$f$ [Hz]')
    plt.ylabel(r'$h^2 \Omega_{\rm GW}^0 (f)$')
    ymin = 1e-12
    ymax = 1.5e-6
    xmin = 3e-10
    xmax = 2e-7
    plt.xlim(xmin, xmax)
    plt.ylim(ymin, ymax)

    ks = np.logspace(-3, 3, 1000)
    _, OmGW_mod, _ = an.OmGW_from_OmM_kM_env_tfin_fit(0.1, 10, ks, FF=1)
    fs, OmGW_mod = cosmoGW.shift_OmGW_today(ks, OmGW_mod, T*u.MeV, g)

    betas = np.linspace(1, 3, 100)
    _ = plot_PTA_all(ff='Om', betas=betas, lines=False, alp_bl=.1, alp_E=.1)

    #plt.plot(fs, OmGW_mod)
    plt.plot(fs, OmGW_mod, color='black', lw=2,
             label='QCD decaying turbulence')
    plt.plot(f_QCD, OmGW_QCD, color='black', ls='-.',
             lw=2, label='QCD driven turbulence')
    OmM_inf = .04
    comp_OmM = OmM_inf/.1
    plt.plot(f_B, OmGW_B*comp_OmM**2, color='black', ls='dotted', lw=2,
             label=r'inflationary')
    plt.plot(f_D, OmGW_D, color='black', ls='dotted', lw=2)

    plt.legend(loc='upper left', fontsize=20, frameon=False)
    TTB = TB.to(u.MeV)
    TTD = TD.to(u.MeV)
    plt.text(1.4e-9, 2.7e-8, r'\hspace{-7mm} non-helical ($T_* = ' + \
                             r'%i$'%TTB.value + r' MeV) \\ $\Omega_{\rm M}^*' + \
                             r'= %.2f$, $k_* = '%OmM_inf + \
                             r'%.1f \, {\cal H}_*$'%kB,
             fontsize=16, bbox=dict(facecolor='white', boxstyle='round,pad=.2'))
    plt.text(1.5e-8, 8e-8, r'\hspace{-7mm} helical ($T_* = %i$'%TTD.value + \
                           r' MeV) \\ $\Omega_{\rm M}^* = %.1f$'%EEMD + \
                           r', $k_* = %.1f \, {\cal H}_*$'%kD, fontsize=16,
             bbox=dict(facecolor='white', boxstyle='round,pad=.2'))
    plt.text(1.1e-8, 2.6e-10, r'\hspace{-7mm} $T_* = 100\,$MeV \\' + \
                             r' \\ $\Omega_{\rm M}^* = 0.1$ \\ \\ $k_* = 10' + \
                             r' \, {\cal H}_*$', fontsize=18,
             bbox=dict(facecolor='white', edgecolor='black',
                       boxstyle='round,pad=.5'))

    # Text of PTA collaborations
    fss = 14
    plt.text(2.5e-9, 8e-11, 'NANOGrav broken PL', color='blue', fontsize=fss)
    plt.text(2e-9, 1.2e-11, 'NANOGrav single PL', color='green', fontsize=fss)
    plt.text(1.7e-9, 3e-11, 'PPTA', color='red', fontsize=fss)
    plt.text(1e-9, 1.7e-9, 'EPTA', color='purple', fontsize=fss)
    plt.text(6.7e-10, 6e-10, 'IPTA', color='black', fontsize=fss)

    if save: plt.savefig('plots/SGWB_comparison.pdf', bbox_inches='tight')

    return runs_QCD, runs_memory

def plot_B_vs_l(save=True, txt=False):

    """
    Function that plots the comoving strength of the magnetic field in cgs
    units (Gauss) as a function of its characteristic length scale in Mpc.

    It plots the results from the PTA analysis, a similar analysis applied
    to the power law sensitivity of LISA, the evolutionary path following
    non-helical MHD turbulence from the time of generation (~QCD) down to
    recombination.

    It also shows limits on the magnetic field parameters from Fermi, CTA,
    Faraday rotation, UHECR and CMB.

    It generates the plot of figure 7 of A. Roper Pol, C. Caprini, A. Neronov,
    D. Semikoz, "The gravitational wave signal from primordial magnetic fields
    in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630

    Arguments:
        save -- option to save the plot in plots/B_vs_l.pdf
                (default True)
    """

    plt.figure(figsize=(14,10))
    plt.xscale('log')
    plt.yscale('log')

    plot_sets.axes_lines()
    yl0 = 1e-13
    yl1 = 2e-5
    xl0 = 1e-14
    xl0 = 5e-15
    xl1 = 1e2
    plt.xlim(xl0, xl1)
    plt.ylim(yl0, yl1)
    plt.xticks(np.logspace(-14, 2, 9))
    plt.xlabel('$l$ [Mpc]')
    plt.ylabel('$B$ [G]')

    xx = np.logspace(np.log10(xl0), np.log10(xl1), 1000)

    # magnetic field strength at recombination
    B_rec = cosmoGW.B_vs_ll_rec(xx*u.Mpc)
    plt.plot(xx, B_rec, color='black', ls='-.')
    plt.text(3.5e-5, 2e-13, 'recombination', rotation=54)
    # magnetic field of the LPE scale at the QCD
    B_lpe_QCD = cosmoGW.B_vs_ll_LPE(xx*u.Mpc, T=100, g=10)
    plt.plot(xx, B_lpe_QCD, color='black', ls='-.')
    plt.text(1e-8, 1.7e-8, r'$B_{\rm LPE}^{\rm QCD}$')
    # magnetic field at BBN
    # B_BBN = cosmoGW.B_vs_ll_LPE(xx*u.Mpc, T=0.1, g=3.4)
    # #plt.plot(xx, B_BBN, color='black', ls='-.')
    # BBN_lim = cosmoGW.mag_BBN()
    # ind_BBN = B_BBN <= BBN_lim
    # plt.plot(xx[ind_BBN], B_BBN[ind_BBN], color='black', ls='-.')

    ###### value of the magnetic field that corresponds to OmM = 0.1 and 1
    ###### at the QCD and EW phase transitions
    Om01 = cosmoGW.OmM_to_B_G(.1, g=10)
    Om1 = cosmoGW.OmM_to_B_G(1, g=10)
    plt.fill_between(xx, xx**0*Om01.value, xx**0*Om1.value,
                     color='gainsboro', alpha=.3)
    plt.fill_between(xx, xx**0*Om1.value, xx**0*yl1,
                     color='gainsboro')
    plt.hlines(Om01.value, xl0, xl1, color='black', ls='-.')
    plt.hlines(Om1.value, xl0, xl1, color='black', ls='-.')
    plt.text(1.5e-2, Om1.value*1.6, r'$\Omega_{\rm M}^{\rm QCD} \geq 1$')
    plt.text(1.5e-2, Om01.value*.35, r'$\Omega_{\rm M}^{\rm QCD} \geq 0.1$')
    # QCD
    # Om01_QCD = cosmoGW.OmM_to_B_G(.1, T=100, g=10)
    # Om1_QCD = cosmoGW.OmM_to_B_G(1, T=100, g=10)
    # xx_QCD = np.logspace(np.log10(2e-8), np.log10(1e-4), 1000)
    # plt.fill_between(xx_QCD, xx_QCD**0*Om01_QCD.value, xx_QCD**0*Om1_QCD.value,
    #                  color='gainsboro', alpha=.3)
    # plt.fill_between(xx_QCD, xx_QCD**0*Om1_QCD.value, xx_QCD**0*yl1,
    #                  color='gainsboro')
    # plt.hlines(Om01_QCD.value, 2e-8, 1e-4, color='black', ls='-.')
    # plt.hlines(Om1_QCD.value, 2e-8, 1e-4, color='black', ls='-.')

    # plt.text(1.5e-4, Om1_QCD.value*1.4, r'$\Omega_{\rm M}^{\rm QCD} \geq 1$')
    # plt.text(1.5e-4, Om01_QCD.value*1.3, r'$\Omega_{\rm M}^{\rm QCD} \geq 0.1$')
             #bbox=dict(facecolor='gainsboro', edgecolor='gainsboro',
            #                       boxstyle='round,pad=.2'))
    # EWPT
    # Om01_EW = cosmoGW.OmM_to_B_G(.1, T=1e5, g=106)
    # plt.hlines(Om01_EW.value, xl0, 5e-9, color='black', ls='-.')
    # plt.hlines(Om01_EW.value*np.sqrt(10), xl0, 5e-9, color='black', ls='-.')
    # xx_EW = np.logspace(np.log10(xl0), np.log10(5e-9), 1000)
    # plt.fill_between(xx_EW, xx_EW**0*Om01_EW.value,
    #                  xx_EW**0*Om01_EW.value*np.sqrt(10),
    #                  color='gainsboro', alpha=.3)
    # plt.fill_between(xx_EW, xx_EW**0*Om01_EW.value*np.sqrt(10),
    #                  xx_EW**0*yl1, color='gainsboro')
    # plt.text(7e-10, Om01_EW.value/2.5, r'$\Omega_{\rm M}^{\rm EW} \geq 0.1$')
    # plt.text(1e-10, Om01_EW.value*np.sqrt(10)*1.7,
    #          r'$\Omega_{\rm M}^{\rm EW} \geq 1$')

    # read the minima and maxima of the magnetic field strength from the
    # PTA analysis
    lambdas_1, min_NG_bPL_1, max_NG_bPL_1 , min_NG_sPL_1 , \
            max_NG_sPL_1, min_EPTA_1, max_EPTA_1, \
            min_PPTA_1, max_PPTA_1, min_IPTA_1, max_IPTA_1 = \
                    an_pta.read_mins_maxs_reg_PTA(OmMlim=1)
    lambdas_01, min_NG_bPL_01, max_NG_bPL_01 , min_NG_sPL_01 , \
            max_NG_sPL_01, min_EPTA_01, max_EPTA_01, \
            min_PPTA_01, max_PPTA_01, min_IPTA_01, max_IPTA_01 = \
                    an_pta.read_mins_maxs_reg_PTA(OmMlim=0.1)

    NN = 20
    lambdas_NG_bPL_1, min_NG_bPL_1, max_NG_bPL_1 = \
            an_pta.filter_Bs(lambdas_1, min_NG_bPL_1, max_NG_bPL_1, N=NN,
                             plot=False, txt=False)
    lambdas_NG_sPL_1, min_NG_sPL_1, max_NG_sPL_1 = \
            an_pta.filter_Bs(lambdas_1, min_NG_sPL_1, max_NG_sPL_1, N=NN,
                             plot=False, txt=False)
    lambdas_EPTA_1, min_EPTA_1, max_EPTA_1 = \
            an_pta.filter_Bs(lambdas_1, min_EPTA_1, max_EPTA_1, N=NN,
                             plot=False, txt=False)
    lambdas_PPTA_1, min_PPTA_1, max_PPTA_1 = \
            an_pta.filter_Bs(lambdas_1, min_PPTA_1, max_PPTA_1, N=NN,
                             plot=False, txt=False)
    lambdas_IPTA_1, min_IPTA_1, max_IPTA_1 = \
            an_pta.filter_Bs(lambdas_1, min_IPTA_1, max_IPTA_1, N=NN,
                             plot=False, txt=False)

    # plot range of PTA results and search for minimum and maximum l of
    # the results compatible with PTA results limited by OmM <= 0.1
    min_l = 1
    max_l = 0
    min_l_1 = 1
    max_l_1 = 0
    min_G = 1
    # EPTA
    # good = np.where(min_EPTA_1 < 1)
    # good2 = np.where(max_EPTA_1[good] > 0)
    #plt.fill_between(lambdas_1[good][good2], min_EPTA_1[good][good2],
    #                 max_EPTA_1[good][good2], alpha=.4, color='purple')
    plt.fill_between(lambdas_EPTA_1, min_EPTA_1,
                     max_EPTA_1, alpha=.4, color='purple')
    good = np.where(min_EPTA_01 < 1)
    good2 = np.where(max_EPTA_01[good] > 0)
    min_l = min(min_l, np.min(lambdas_01[good][good2]))
    max_l = max(max_l, np.max(lambdas_01[good][good2]))
    good = np.where(min_EPTA_1 < 1)
    good2 = np.where(max_EPTA_1[good] > 0)
    min_l_1 = min(min_l_1, np.min(lambdas_EPTA_1[good][good2]))
    max_l_1 = max(max_l_1, np.max(lambdas_EPTA_1[good][good2]))
    min_G = min(min_G, np.min(min_EPTA_1[good][good2]))
    # PPTA
    # good = np.where(min_PPTA_1 < 1)
    # good2 = np.where(max_PPTA_1[good] > 0)
    # plt.fill_between(lambdas_1[good][good2], min_PPTA_1[good][good2],
    #                  max_PPTA_1[good][good2], alpha=.4, color='red')
    plt.fill_between(lambdas_PPTA_1, min_PPTA_1,
                     max_PPTA_1, alpha=.4, color='red')
    good = np.where(min_PPTA_01 < 1)
    good2 = np.where(max_PPTA_01[good] > 0)
    min_l = min(min_l, np.min(lambdas_01[good][good2]))
    max_l = max(max_l, np.max(lambdas_01[good][good2]))
    good = np.where(min_PPTA_1 < 1)
    good2 = np.where(max_PPTA_1[good] > 0)
    min_l_1 = min(min_l_1, np.min(lambdas_PPTA_1[good][good2]))
    max_l_1 = max(max_l_1, np.max(lambdas_PPTA_1[good][good2]))
    min_G = min(min_G, np.min(min_PPTA_1[good][good2]))
    # IPTA
    plt.fill_between(lambdas_IPTA_1, min_IPTA_1,
                     max_IPTA_1, alpha=.4, color='black')
    good = np.where(min_IPTA_01 < 1)
    good2 = np.where(max_IPTA_01[good] > 0)
    min_l = min(min_l, np.min(lambdas_01[good][good2]))
    max_l = max(max_l, np.max(lambdas_01[good][good2]))
    good = np.where(min_IPTA_1 < 1)
    good2 = np.where(max_IPTA_1[good] > 0)
    min_l_1 = min(min_l_1, np.min(lambdas_IPTA_1[good][good2]))
    max_l_1 = max(max_l_1, np.max(lambdas_IPTA_1[good][good2]))
    min_G = min(min_G, np.min(min_IPTA_1[good][good2]))
    # NG bPL
    # good = np.where(min_NG_bPL_1 < 1)
    # good2 = np.where(max_NG_bPL_1[good] > 0)
    # plt.fill_between(lambdas_1[good][good2], min_NG_bPL_1[good][good2],
    #                  max_NG_bPL_1[good], alpha=.6, color='blue')
    plt.fill_between(lambdas_NG_bPL_1, min_NG_bPL_1,
                     max_NG_bPL_1, alpha=.6, color='blue')
    good = np.where(min_NG_bPL_01 < 1)
    good2 = np.where(max_NG_bPL_01[good] > 0)
    min_l = min(min_l, np.min(lambdas_01[good][good2]))
    max_l = max(max_l, np.max(lambdas_01[good][good2]))
    good = np.where(min_NG_bPL_1 < 1)
    good2 = np.where(max_NG_bPL_1[good] > 0)
    min_l_1 = min(min_l_1, np.min(lambdas_NG_bPL_1[good][good2]))
    max_l_1 = max(max_l_1, np.max(lambdas_NG_bPL_1[good][good2]))
    min_G = min(min_G, np.min(min_NG_bPL_1[good][good2]))
    # NG sPL
    # good = np.where(min_NG_sPL_1 < 1)
    # good2 = np.where(max_NG_sPL_1[good] > 0)
    # plt.fill_between(lambdas_1[good][good2], min_NG_sPL_1[good][good2],
    #                  max_NG_sPL_1[good][good2], alpha=.6, color='green')
    plt.fill_between(lambdas_NG_sPL_1, min_NG_sPL_1,
                     max_NG_sPL_1, alpha=.6, color='green')
    good = np.where(min_NG_sPL_01 < 1)
    good2 = np.where(max_NG_sPL_01[good] > 0)
    min_l = min(min_l, np.min(lambdas_01[good][good2]))
    max_l = max(max_l, np.max(lambdas_01[good][good2]))
    good = np.where(min_NG_sPL_1 < 1)
    good2 = np.where(max_NG_sPL_1[good] > 0)
    min_l_1 = min(min_l_1, np.min(lambdas_NG_sPL_1[good][good2]))
    max_l_1 = max(max_l_1, np.max(lambdas_NG_sPL_1[good][good2]))
    min_G = min(min_G, np.min(min_NG_sPL_1[good][good2]))

    if txt:
        print('Min, max l_* (for OmM <= 0.1): ', min_l, max_l)
        print('Min, max l_* (for OmM <= 1): ', min_l_1, max_l_1)
        print('Min B: ', min_G)

    plt.annotate('PTA', xy=(2e-5, 8e-7), xytext=(1.3e-4, 3e-7),
                 arrowprops=dict(facecolor='black', shrink=.07))

    # read the minima and maxima of the magnetic field strength from the
    # LISA analysis
    lambdas, min_Bs_LISA, max_Bs_LISA = inte.read_mins_maxs_reg_LISA(OmMlim=1)
    # plot range of LISA results
    lambdas2, min_Bs_LISA, max_Bs_LISA = \
            an_pta.filter_Bs(lambdas, min_Bs_LISA, max_Bs_LISA, N=35,
                             plot=False, txt=False)
    plt.fill_between(lambdas2, min_Bs_LISA, max_Bs_LISA, alpha=.4, color='blue')

    lambdas_01, min_Bs_LISA_01, max_Bs_LISA_01 = \
            inte.read_mins_maxs_reg_LISA(OmMlim=0.1)
    # plot range of LISA results
    lambdas_01, min_Bs_LISA_01, max_Bs_LISA_01 = \
            an_pta.filter_Bs(lambdas_01, min_Bs_LISA_01, max_Bs_LISA_01, N=35,
                             plot=False, txt=False)
    plt.text(1e-12, 3.5e-8, 'LISA', color='blue')

    if txt:
        print('Min, max l_* with LISA (for OmM <= 0.1): ', min(lambdas_01),
              max(lambdas_01))
        print('Min, max l_* with LISA (for OmM <= 1): ', min(lambdas2),
              max(lambdas2))
        print('Min B with LISA: ', min(min_Bs_LISA))

    ##### plot evolutionary paths following non-helical MHD turbulent decay
    ##### B ~ l^(-1.5) and B ~ l^(-2.5) for the range of PTA results
    # l^(-1.5)
    # f_min_r = Om01_QCD*(xx/min_l)**(-1.5)
    # f_max_r = Om01_QCD*(xx/max_l)**(-1.5)
    f_min_r = Om01*(xx/min_l)**(-1.5)
    f_max_r = Om01*(xx/max_l)**(-1.5)
    good_min = np.where(f_min_r > B_rec)
    good_max = np.where(f_max_r > B_rec)
    #good2_min = np.where(f_min_r[good_min] < Om01_QCD)
    #good2_max = np.where(f_max_r[good_max] < Om01_QCD)
    good2_min = np.where(f_min_r[good_min] < Om01)
    good2_max = np.where(f_max_r[good_max] < Om01)
    plt.plot(xx[good_max][good2_max], f_max_r[good_max][good2_max],
             color='red', ls='-.')
    plt.text(4e-4, 2e-8, r'$B \sim l^{-1.5}$', color='red')
    # l^(-2.5)
    #f_min_r = Om01_QCD*(xx/min_l)**(-2.5)
    #f_max_r = Om01_QCD*(xx/max_l)**(-2.5)
    f_min_r = Om01*(xx/min_l)**(-2.5)
    f_max_r = Om01*(xx/max_l)**(-2.5)
    good_min = np.where(f_min_r > B_rec)
    good_max = np.where(f_max_r > B_rec)
    # good2_min = np.where(f_min_r[good_min] < Om01_QCD)
    # good2_max = np.where(f_max_r[good_max] < Om01_QCD)
    good2_min = np.where(f_min_r[good_min] < Om01)
    good2_max = np.where(f_max_r[good_max] < Om01)
    plt.plot(xx[good_min][good2_min], f_min_r[good_min][good2_min],
             color='darkred', ls='-.')
    plt.text(6e-8, 2e-9, r'$B \sim l^{-2.5}$', color='darkred',
             bbox=dict(facecolor='white', edgecolor='white', alpha=.2,
                                   boxstyle='round,pad=.2'))

    #### magnetic field and coherence length for QCD phase transition in the
    #### case with OmM = 0.1 and k_* = 2pi
    # We use 2 points: QCD_1 using T_* = 150, g = 15
    #                  QCD_2 using T_* = 100, g = 10
    BB_QCD_1 = cosmoGW.OmM_to_B_G(.1, g=15)
    ll_QCD_1 = cosmoGW.k_to_ll_Mpc(2*np.pi, T=150, g=15)
    plt.plot(ll_QCD_1, BB_QCD_1, 'o', color='red')
    BB_QCD_2 = cosmoGW.OmM_to_B_G(.1, g=10)
    ll_QCD_2 = cosmoGW.k_to_ll_Mpc(2*np.pi, T=100, g=10)
    plt.plot(ll_QCD_2, BB_QCD_2, 'o', color='red')

    ##### evolved down to recombination from QCD_1
    # following l^(-1.5)
    f_QCD_1 = BB_QCD_1*(xx/ll_QCD_1)**(-1.5)
    good_1 = np.where(f_QCD_1.value > B_rec.value)
    good2_1 = np.where(f_QCD_1[good_1].value < BB_QCD_1.value)
    plt.plot(xx[good_1][good2_1], f_QCD_1[good_1][good2_1], color='red')
    f_QCD_2 = BB_QCD_1*(xx/ll_QCD_2)**(-1.5)
    good_2 = np.where(f_QCD_2.value > B_rec.value)
    good2_2 = np.where(f_QCD_2[good_2].value < BB_QCD_2.value)
    plt.plot(xx[good_2][good2_2], f_QCD_2[good_2][good2_2], color='red')
    # following l^(-2.5)
    f_QCD_1 = BB_QCD_1*(xx/ll_QCD_1)**(-2.5)
    good_1 = np.where(f_QCD_1.value > B_rec.value)
    good2_1 = np.where(f_QCD_1[good_1].value < BB_QCD_1.value)
    plt.plot(xx[good_1][good2_1], f_QCD_1[good_1][good2_1], color='darkred')
    f_QCD_2 = BB_QCD_1*(xx/ll_QCD_2)**(-2.5)
    good_2 = np.where(f_QCD_2.value > B_rec.value)
    good2_2 = np.where(f_QCD_2[good_2].value < BB_QCD_2.value)
    plt.plot(xx[good_2][good2_2], f_QCD_2[good_2][good2_2], color='darkred')

    ##### plot limits from Fermi
    y_Fermi1, y_Fermi2 = mag.Fermi_limits(xx*u.Mpc)
    plt.plot(xx, y_Fermi1, color='black')
    plt.plot(xx, y_Fermi2, color='black')
    plt.fill_between(xx, y_Fermi1, y_Fermi2, color='gray', alpha=.1)
    plt.fill_between(xx, xx**0*yl0, y_Fermi1, color='gray', alpha=.2)
    plt.text(4e-13, 5e-13, r'Fermi $B \sim l^{-0.5}$', color='black')

    # #### plot sensitivity from CTA
    y_CTA = mag.CTA_sens(xx*u.Mpc)
    plt.plot(xx, y_CTA, color='blue', alpha=.7)
    plt.text(4e-7, 8e-11, 'CTA', color='blue')

    ##### plot limits from Faraday rotation
    good = np.where(xx > 0.01)
    y_FR = mag.Faraday_lims(xx[good]*u.Mpc)
    plt.plot(xx[good], y_FR, color='black')
    plt.text(3, 1.3e-9, 'FR')

    #### plot observations from UHECR in Perseus-Pisces region
    y_UHECR = mag.UHECR_obs(xx[good]*u.Mpc)
    plt.plot(xx[good], y_UHECR, color='royalblue')
    plt.fill_between(xx[good], y_UHECR, y_FR, color='royalblue', alpha=.4)
    plt.text(8e-2, 3e-10, 'UHECR', color='royalblue')

    ##### CMB upper and lower limits from Galli et al.
    BBcmb_up, BBcmb_low = mag.CMB_mag_Galli()
    # divide by 6 lower limit to include scale-invariant fields in the
    # interval
    BBcmb_low /= 6
    plt.plot(xx[np.where(B_rec < BBcmb_up)],
             B_rec[np.where(B_rec < BBcmb_up)], color='green', lw=5)
    # plot interval between lower and upper limits
    ll_cmb_up = cosmoGW.B_vs_ll_rec(BBcmb_up, d=-1)
    ll_cmb_low = cosmoGW.B_vs_ll_rec(BBcmb_low, d=-1)
    ll_cmb = np.linspace(ll_cmb_low/1.5,  ll_cmb_low*1.5)
    plt.plot(ll_cmb, BBcmb_low*(ll_cmb/ll_cmb_low)**(-.6), color='green',
             lw=3)
    ll_cmb = np.linspace(ll_cmb_up/1.5,  ll_cmb_up*1.5)
    plt.plot(ll_cmb, BBcmb_up*(ll_cmb/ll_cmb_up)**(-.6), color='green',
             lw=3)
    plt.text(5e-3, 6e-11/3, r'Galli et al.~2021', color='green')

    if save: plt.savefig('plots/B_vs_l.pdf', bbox_inches='tight')

########################## UNPUBLISHED #######################################

def plot_contour_LISA(T='100', g=100, col = 'blue',
                      plot=True, ret=False, save=False):

    """
    Function that plots the contours of k_* and OmM parameters of the magnetic
    field that are compatible with the LISA PLS at a fixed temperature T_*.

    It reads the results from the analysis performed using analysis_LISA in
    the Python library interferometry, which generates pickle variables with
    the required results under the directory results_analysis/pos_LISA
    (check first if these are already available)

    Arguments:
        T -- temperature T_* expressed as a string in GeV (default '150')
        plot -- option to plot the contour (default True)
        ret -- option to return the 2D space parameters kij, OmMij, and the
               2D array of the allowed region pos (default False)

    Returns:
        kij -- 2d array of characteristic scales of the magnetic field
        OmMij -- 2d array of magnetic energy density amplitudes
        pos -- 2d boolean array for the possible parameters compatible with
               the PTA results from 'obs' (1 or 0)
    """

    import pickle

    f = open('results_analysis/pos_LISA/pos_T' + T + 'GeV.pckl', 'rb')
    k, Om, pos = pickle.load(f)
    f.close()

    kij, Omij = np.meshgrid(k, Om, indexing='ij')
    if plot:
        plt.figure(figsize=(8,5))
        plt.contour(kij, Omij, pos, levels=[.5, 1],
                    colors=[col, 'red'])
        plt.contourf(kij, Omij, pos, levels=[.5, 1],
                     colors=[col, 'red'], alpha=.3)

        print(T, ' GeV', '\n', 'range of k_*: (',
              np.min(kij[np.where(pos)]), ',', np.max(kij[np.where(pos)]), ')',
              '\n', 'range of OmM: (', np.min(Omij[np.where(pos)]), ',',
              np.max(Omij[np.where(pos)]), ') \n')

    OmM_LPE = np.logspace(-3, 0, 100)
    kLPE = 2*np.pi/np.sqrt(3/2*OmM_LPE)
    if plot: plt.plot(kLPE, OmM_LPE, color='black', ls='-.')

    if plot:
        plt.vlines(2*np.pi, 1e-4, .1, color='black', ls='-.')
        plt.hlines(.1, 2*np.pi, 3e4, color='black', ls='-.')
        plt.yscale('log')
        plt.xlim(1, 2e4)
        plt.ylim(8e-4, 1)
        plot_sets.axes_lines()
        plt.xlabel('$k_* {\cal H}_*^{-1}$')
        plt.ylabel(r'$\Omega_{\rm M}^*$')
        plt.title('$T_* = %s$ GeV, $g_* = %i$'%(T, g), pad=15)
        plt.text(42, 2e-2, r'$k_{\rm LPE} {\cal H}_*^{-1}$', fontsize=24,
                 color='black')
        plt.text(6.8, 4.5e-3, r'$k_* = 2\pi {\cal H}_*$', fontsize=24,
                 color='black')
        plt.text(50, 5.5e-2, r'$\Omega_{\rm M}^* = 0.1$', fontsize=24,
                 color='black')
        plt.xscale('log')

    if save: plt.savefig('plots/pars_compatible_LISA_T%s.pdf'%T,
                         bbox_inches='tight')

    if ret: return kij, Omij, pos

def plot_kbr_LISA(T='100', g=100, col='blue', text=True):

    """
    Function that plots the positions of the break frequencies at a fixed
    temperature for LISA.

    Arguments:
        T -- temperature scale in GeV as a string (default '100')
        g -- relativistic degrees of freedom (default 100)
        col -- color of the plot (default 'blue')
        text -- option to print out limits of fbr (default True)
    """

    kij, Omij, pos = plot_contour_LISA(T=T, ret=True, plot=False)
    alp = .6
    kbrs = an_pta.kbr_pos(kij, Omij, pos)
    plt.figure(1)
    try: TT = int(T)
    except: TT = float(T)
    plt.plot(kbrs, TT*kbrs**0, '.', color=col, alpha=alp)
    plt.figure(2)
    fbrs = cosmoGW.shift_frequency_today(kbrs, TT*u.GeV, g)
    plt.plot(fbrs, TT*kbrs**0, '.', color=col, alpha=alp)
    if len(kbrs) and text:
        print(T, 'GeV: (', np.min(fbrs.value), ',', np.max(fbrs.value),
              ') Hz')

    plt.figure(1)
    plot_sets.axes_lines()
    plt.xlabel(r'$k_{\rm br} {\cal H}_*^{-1}$')
    plt.ylabel('$T_*$ [GeV]')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlim(3e-2, 10)

    plt.figure(2)
    plot_sets.axes_lines()
    plt.xlabel(r'$f_{\rm br}$ [Hz]')
    plt.ylabel('$T_*$ [GeV]')
    plt.xscale('log')
    plt.yscale('log')

    plt.figure(3)
    plot_sets.axes_lines()
    plt.xlabel(r'$f_{\rm br}$ [Hz]')
    plt.ylabel('$T_*$ [GeV]')
    plt.xscale('log')
    plt.yscale('log')

    return fbrs

def plot_kbr_LISA_all_T(save=True, text=True):

    """
    Function that plots the positions of the break frequencies at all
    temperatures for LISA.

    Arguments:
        save -- option to save the plot in plots/fbr_T_LISA.pdf
                (default True)
        text -- option to print out limits of fbr (default True)
    """

    print('Range of break frequencies: \n')

    plt.figure(1, figsize=(12,8))
    plt.figure(2, figsize=(12,8))
    plt.figure(3, figsize=(12,8))

    T = ['4', '5', '10', '20', '30', '35', '38', '50', '70', '100', '150', '200', '300', '500', '700',
         '1000', '1500', '2000', '3000', '5000', '7000', '10000', '15000',
         '20000', '30000', '50000', '70000', '100000', '150000', '200000',
         '300000', '500000', '700000', '1000000', '1500000', '2000000', '2300000',
         '3000000', '5000000', '7000000']
    fbrs_all = []
    for i in T:
        fbrs_LISA = plot_kbr_LISA(T=i, g=100, col='blue', text=True)
        fbrs_all.append(fbrs_LISA)
    fbrs_all = np.array(fbrs_all, dtype='object')

    plt.figure(2)
    if save: plt.savefig('plots/fbr_T_LISA.pdf',
                bbox_inches='tight')

    plt.figure(3)
    NN = len(fbrs_all)
    min_fbrs = np.zeros(NN)*u.Hz
    max_fbrs = np.zeros(NN)*u.Hz
    T = np.array(T, dtype='float')
    for i in range(0, NN):
        if len(fbrs_all[i]):
            min_fbrs[i] = min(fbrs_all[i])
            max_fbrs[i] = max(fbrs_all[i])
            #print('test')
            plt.hlines(float(T[i]), min_fbrs[i].value, max_fbrs[i].value,
                       color='black', lw=.4, ls='-.')
        #except: tst = True

    T2 = np.logspace(np.log10(38), np.log10(2.3e6), 1000)
    fbrs_min2 = np.interp(T2, T, min_fbrs)
    fbrs_max2 = np.interp(T2, T, max_fbrs)
    plt.fill_betweenx(T2, fbrs_min2, fbrs_max2, color='b', alpha=.3)
    plt.plot(fbrs_min2, T2, color='b', lw=2)
    plt.plot(fbrs_max2, T2, color='b', lw=2)
    if save: plt.savefig('plots/fbr_T_LISA_interp.pdf',
                bbox_inches='tight')

    return T, fbrs_all
