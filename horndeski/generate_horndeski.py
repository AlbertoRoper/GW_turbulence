"""
generate_horndeski.py is a Python routine  that can be used to generate
the plots and compute the postprocessing results of Y. He, A. Roper Pol,
A. Brandenburg, "Modified propagation of gravitational waves from the early
radiation era," submitted to JCAP (2022).

It reads the pickle run variables that can be generated by the routine
initialize_horndeski.py.

The function run() executes the code.

Author: Alberto Roper Pol
created: 01/12/2022
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
import pandas as pd

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'

# import GW_turbulence routines that are relevant for the project
os.chdir(HOME)
from dirs import read_dirs as rd
import plot_sets
import run as r
import interferometry as inte
import cosmoGW
import spectra as spec
import GW_analytical as an
import horndeski as ho
import cosmology as co
import pta
os.chdir(dir0)

# variables that are used globally
alpsM0_g = np.array([-0.5, -0.3, -0.1, -0.01, 0.1, 0.3])
cols_g = np.array(['blue', 'green', 'red', 'magenta', 'purple', 'orange'])
runs_ng = np.array(['A', 'B', 'C', 'D', 'E', 'F'])
alpsM02_g = np.array([-0.5, -0.3, -0.1,0.1, 0.3])
cols2_g = np.array(['blue', 'green', 'red', 'purple', 'orange'])
runs_n2g = np.array(['A', 'B', 'C', 'D', 'E'])
k = np.logspace(-7, 3, 2000)

# reference values and constants
Tref = 100*u.GeV
h0_ref = 0.6372
  
def read_cosmology_results():
    
    """
    Function that reads the cosmology results from the Friedmann solver
    that have already been computed using the routines under the project
    directory cosmology.
    """
    
    #### Read the results from the Friedmann solution
    os.chdir(HOME)
    fl = 'cosmology/friedmann/a_vs_eta.dat'
    df = pd.read_csv(fl, skiprows=1, header=None, names=['eta', 'a', 'HH', 'app_a', 'd'], delimiter=' ')
    a = np.array(df['a'])
    eta = np.array(df['eta'])
    ap_a = np.array(df['HH'])
    app_a = np.array(df['app_a'])
    os.chdir(dir0)
    
    return a, eta, ap_a, app_a
  
def cosmology_normalized_vars(a, eta, ap_a, app_a, T=Tref, h0=h0_ref):
    
    """
    Function that computes the normalized variables in terms of the solutions to
    the Friedmann solver for a specific temperature scale.
    
    Arguments:
        a -- scale factor
        eta -- conformal time
        ap_a -- conformal Hubble rate HH = a'/a
        app_a -- conformal acceleration a''/a
        T -- temperature scale (default is 100 GeV, EWPT)
        h0 -- Hubble rate at present time (default is CMB observation 67.32 km/s/Mpc)
        
    Returns:
        a_n -- normalized scale factor a/a_*
        eta_n -- normalized conformal time eta/eta_*
        HH_n -- normalized conformal Hubble rate HH/HH_*
        app_a_n -- normalized conformal acceleration (a''/a)/HH_*^2
        Omega -- ratio of energy density to critical energy at present time
        w -- equation of state
        eta_n_0 -- normalized conformal present time eta_0/eta_*
        aEQ_n -- normalized scale factor at equipartition aEQ/a_*
        aL_n -- id at dark-energy domination
        a_acc_n -- id at beginning of accelerated universe
        eta_n_EQ -- normalized conformal time at equipartition eta_EQ/eta_*
        eta_n_L -- id at dark-energy domination
        eta_n_acc -- id at beginning of accelerated universe
    """

    os.chdir(HOME)
    # choice of the initial time and computation of scale factor and Hubble rate
    g = co.thermal_g(T=T, s=0)
    ast = co.as_a0_rat(T=T, g=g)
    Hs = co.Hs_val(T=T, g=g)

    # computation of normalized variables
    a_n, eta_n, HH_n, app_a_n, Omega, w, eta_n_0, aEQ_n, \
        aL_n, a_acc_n, eta_n_EQ, eta_n_L, eta_n_acc = \
            co.normalized_variables(a, eta, ap_a, app_a, T=T, h0=h0)
    
    os.chdir(dir0)
    
    return a_n, eta_n, HH_n, app_a_n, Omega, w, eta_n_0, aEQ_n, \
           aL_n, a_acc_n, eta_n_EQ, eta_n_L, eta_n_acc
  
def plot_parameterizations_alpM(eta_n, a, Omega, Om_mat, HH_n, eta_n_EQ, eta_n_L, eta_n_0, OmM0,
                                comp_exp=1, compp=1, nn_exp=1, save=True, primes=False,
                                n2=False, n04=False, n1=True, figg=1):
    
    """
    Function that plots the cosmological time evolution of the alphaM parameterizations.
    
    It generates the plots corresponding to figure 1 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/alphaM_params_EWPT.pdf' and 'plots/params_WKB_lims_EWPT.pdf'
    """
    
    ### parameterizations
    alpM_0, alpM_prime_0 = ho.parameterizations_alpM(eta_n, choice='0')
    alpM_I_2, alpM_prime_I_2 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=2)
    alpM_I, alpM_prime_I = ho.parameterizations_alpM(eta_n, a=a, choice='I')
    alpM_I_04, alpM_prime_I_04 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=0.4)
    alpM_II, alpM_prime_II = ho.parameterizations_alpM(eta_n, a=a, choice='II', Omega=Omega)
    alpM_III, alpM_prime_III = ho.parameterizations_alpM(eta_n, choice='III', OmM0=OmM0,
                                                         Omega_mat=Om_mat, Omega=Omega)
    
    if figg == 1:
        primes = False
        ins = True
    else:
        primes = True
        ins = False
        comp_exp = 2
        compp = 1/2
        nn_exp = 1/2
        alpM_0 = alpM_0*(1+.5*alpM_0)
        alpM_I = alpM_I*(1+.5*alpM_I)
        alpM_I_2 = alpM_I_2*(1+.5*alpM_I_2)
        alpM_I_04 = alpM_I_04*(1+.5*alpM_I_04)
        alpM_II = alpM_II*(1+.5*alpM_II)
        alpM_III = alpM_III*(1+.5*alpM_III)

    fig, ax = plt.subplots(figsize=(8, 5))

    comp = compp*HH_n**comp_exp

    if primes:
        if n1:
            plt.plot(eta_n, (comp*abs(alpM_prime_I))**nn_exp,
                 color='purple', ls='dashed',  lw=2)
        if n2:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_2))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        if n04:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_04))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_II))**nn_exp,
                     color='red', ls='dashed',   lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_III))**nn_exp,
                 color='cyan', ls='dashed',   lw=2)
      
    plt.plot(eta_n, (alpM_0*comp)**nn_exp, lw=2, color='darkblue')
    if n1:
        plt.plot(eta_n, (alpM_I*comp)**nn_exp, color='purple',  lw=2)
    if n2:
        plt.plot(eta_n, (alpM_I_2*comp)**nn_exp, color='purple',  lw=2)
    if n04:
        plt.plot(eta_n, (alpM_I_04*comp)**nn_exp, color='purple',  lw=2)
    plt.plot(eta_n, (alpM_II*comp)**nn_exp, lw=2,  color='red')
    plt.plot(eta_n, (alpM_III*comp)**nn_exp,  lw=2,  color='cyan')
    
    plt.loglog()
    plt.xlim(1, eta_n_0)
    if figg == 1:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 1e-14, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-34, 'II', color='red')
        plt.ylim(1e-60, 1e1)
        plt.text(1e10, 1e-6, 'RD', color='black')
        plt.text(3e11, 1e-6, 'MD', color='black')
        plt.title(r'$\Bigl(\alpha_{\rm M}/\alpha_{{\rm M}, 0}\Bigr) \, {\cal H}$',
                  pad = 15)
    else:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 3e-15, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-21, 'II', color='red')
        plt.plot([], [], color='black',
                 label=r"$k_{{\rm lim}, \alpha_{\rm M}} \, c_{\rm T}" + \
                       r" \, \alpha_{{\rm M}, 0}^{-{1\over2}}$")
        plt.plot([], [], ls='dashed', color='black',
                 label=r"$k_{{\rm lim}, \alpha'_{\rm M}} \, c_{\rm T}" + \
                       r" \, {\alpha_{{\rm M}, 0}^{-{1\over2}}}$")
        plt.legend(fontsize=16, framealpha=1, edgecolor='white')
        plt.ylim(1e-28, 2)
        plt.text(1e10, 1e-26, 'RD', color='black')
        plt.text(1e12, 1e-26, 'MD', color='black')

    plt.xlabel(r'$\eta/\eta_*$')

    plt.vlines(eta_n_EQ, 1e-70, 1e3, color='black')
    plt.vlines(eta_n_L, 1e-70, 1e3, color='black')

    inds = np.where(eta_n < eta_n_EQ)
    inds2 = np.where(eta_n > eta_n_EQ)
    inds3 = np.where(eta_n[inds2] < eta_n_L)
    inds4 = np.where(eta_n[inds2] > eta_n_L)
    plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
    plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                     eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
    plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                     eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)

    plot_sets.axes_lines()

    if ins:
        from mpl_toolkits.axes_grid1.inset_locator import inset_axes
        iax = inset_axes(ax, width="40%", height=1.4, loc=4)
        iax.xaxis.tick_top()
        plt.plot(eta_n, (alpM_I*comp*(1+.5*alpM_I))**nn_exp, color='purple',  lw=2)
        plt.plot(eta_n, (alpM_III*comp*(1+.5*alpM_III))**nn_exp,  lw=2,  color='cyan')
        plt.plot(eta_n, (alpM_0*comp*(1+.5*alpM_0))**nn_exp, lw=2,  color='darkblue')
        plt.plot(eta_n, (alpM_II*comp*(1+.5*alpM_II))**nn_exp, lw=2,  color='red')
        plt.loglog()
        plt.xlim(1e11, eta_n_0)
        plt.ylim(1e-24, 1e-9)
        inds = np.where(eta_n < eta_n_EQ)
        inds2 = np.where(eta_n > eta_n_EQ)
        inds3 = np.where(eta_n[inds2] < eta_n_L)
        inds4 = np.where(eta_n[inds2] > eta_n_L)
        plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
        plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                         eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
        plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                         eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)
        for i in iax.get_xticklabels() + iax.get_yticklabels():
            i.set_fontsize(16)
        plt.xticks([1e12, 1e13])
        plot_sets.axes_lines()
        plt.text(8.5e12, 1e-20, r'$\Lambda$D')

    if save:
        if figg == 1: lsave = 'alphaM_params_EWPT'
        else: lsave = 'params_WKB_lims_EWPT'
        plt.savefig('plots/' + lsave + '.pdf',
                    bbox_inches='tight')
  
def run(rsd='all', dirs={}):
    
    """
    Function that loads the pickle variables of the runs after they have
    been read by the initialize_horndeski.py routine.
    """

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = {}
    if rs == 'all': dirs = rd('horndeski', dirs={})
    if rs == 'M0': dirs = rd('horndeski_M0', dirs={})
    if rs == 'M1': dirs = rd('horndeski_M1', dirs={})
    if rs == 'M2': dirs = rd('horndeski_M2', dirs={})
    if rs == 'M3': dirs = rd('horndeski_M3', dirs={})
    if rs == 'lowk': dirs = rd('horndeski_lowk', dirs={})
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)
    os.chdir(dir0)

    return runs
