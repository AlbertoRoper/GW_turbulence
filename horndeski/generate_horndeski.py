"""
generate_horndeski.py is a Python routine  that can be used to generate
the plots and compute the postprocessing results of Y. He, A. Roper Pol,
A. Brandenburg, "Modified propagation of gravitational waves from the early
radiation era," submitted to JCAP (2022).

It reads the pickle run variables that can be generated by the routine
initialize_horndeski.py.

The function run() executes the code.

Author: Alberto Roper Pol
created: 01/12/2022
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
import pandas as pd

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'

# import GW_turbulence routines that are relevant for the project
os.chdir(HOME)
from dirs import read_dirs as rd
import plot_sets
import run as r
import interferometry as inte
import cosmoGW
import spectra as spec
import GW_analytical as an
import horndeski as ho
import cosmology as co
import pta
os.chdir(dir0)

# variables that are used globally
alpsM0_g = np.array([-0.5, -0.3, -0.1, -0.01, 0.1, 0.3])
cols_g = np.array(['blue', 'green', 'red', 'magenta', 'purple', 'orange'])
runs_ng = np.array(['A', 'B', 'C', 'D', 'E', 'F'])
alpsM02_g = np.array([-0.5, -0.3, -0.1,0.1, 0.3])
cols2_g = np.array(['blue', 'green', 'red', 'purple', 'orange'])
runs_n2g = np.array(['A', 'B', 'C', 'D', 'E'])
k = np.logspace(-7, 3, 2000)

# reference values and constants
Tref = 100*u.GeV
gref = 100
h0_ref = 0.6372

def read_cosmology_results():
    
    """
    Function that reads the cosmology results from the Friedmann solver
    that have already been computed using the routines under the project
    directory cosmology.
    """
    
    #### Read the results from the Friedmann solution
    os.chdir(HOME)
    fl = 'cosmology/friedmann/a_vs_eta.dat'
    df = pd.read_csv(fl, skiprows=1, header=None, names=['eta', 'a', 'HH', 'app_a', 'd'], delimiter=' ')
    a = np.array(df['a'])
    eta = np.array(df['eta'])
    ap_a = np.array(df['HH'])
    app_a = np.array(df['app_a'])
    os.chdir(dir0)
    
    return a, eta, ap_a, app_a

def plot_parameterizations_alpM(eta_n, a, Omega, Om_mat, HH_n, eta_n_EQ, eta_n_L, eta_n_0, OmM0,
                                comp_exp=1, compp=1, nn_exp=1, save=True, primes=False,
                                n2=False, n04=False, n1=True, figg=1):
    
    """
    Function that plots the cosmological time evolution of the alphaM parameterizations.
    
    It generates the plots corresponding to figure 1 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/alphaM_params_EWPT.pdf' and 'plots/params_WKB_lims_EWPT.pdf'
    """
    
    ### parameterizations
    alpM_0, alpM_prime_0 = ho.parameterizations_alpM(eta_n, choice='0')
    alpM_I_2, alpM_prime_I_2 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=2)
    alpM_I, alpM_prime_I = ho.parameterizations_alpM(eta_n, a=a, choice='I')
    alpM_I_04, alpM_prime_I_04 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=0.4)
    alpM_II, alpM_prime_II = ho.parameterizations_alpM(eta_n, a=a, choice='II', Omega=Omega)
    alpM_III, alpM_prime_III = ho.parameterizations_alpM(eta_n, choice='III', OmM0=OmM0,
                                                         Omega_mat=Om_mat, Omega=Omega)
    
    if figg == 1:
        primes = False
        ins = True
    else:
        primes = True
        ins = False
        comp_exp = 2
        compp = 1/2
        nn_exp = 1/2
        alpM_0 = alpM_0*(1+.5*alpM_0)
        alpM_I = alpM_I*(1+.5*alpM_I)
        alpM_I_2 = alpM_I_2*(1+.5*alpM_I_2)
        alpM_I_04 = alpM_I_04*(1+.5*alpM_I_04)
        alpM_II = alpM_II*(1+.5*alpM_II)
        alpM_III = alpM_III*(1+.5*alpM_III)

    fig, ax = plt.subplots(figsize=(8, 5))

    comp = compp*HH_n**comp_exp

    if primes:
        if n1:
            plt.plot(eta_n, (comp*abs(alpM_prime_I))**nn_exp,
                 color='purple', ls='dashed',  lw=2)
        if n2:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_2))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        if n04:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_04))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_II))**nn_exp,
                     color='red', ls='dashed',   lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_III))**nn_exp,
                 color='cyan', ls='dashed',   lw=2)
      
    plt.plot(eta_n, (alpM_0*comp)**nn_exp, lw=2, color='darkblue')
    if n1:
        plt.plot(eta_n, (alpM_I*comp)**nn_exp, color='purple',  lw=2)
    if n2:
        plt.plot(eta_n, (alpM_I_2*comp)**nn_exp, color='purple',  lw=2)
    if n04:
        plt.plot(eta_n, (alpM_I_04*comp)**nn_exp, color='purple',  lw=2)
    plt.plot(eta_n, (alpM_II*comp)**nn_exp, lw=2,  color='red')
    plt.plot(eta_n, (alpM_III*comp)**nn_exp,  lw=2,  color='cyan')
    
    plt.loglog()
    plt.xlim(1, eta_n_0)
    if figg == 1:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 1e-14, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-34, 'II', color='red')
        plt.ylim(1e-60, 1e1)
        plt.text(1e10, 1e-6, 'RD', color='black')
        plt.text(3e11, 1e-6, 'MD', color='black')
#        plt.title(r'$\Bigl(\alpha_{\rm M}/\alpha_{{\rm M}, 0}\Bigr) \, {\cal H}$',
#                  pad = 15)
        plt.ylabel(r'$\Bigl(\alpha_{\rm M}/\alpha_{{\rm M}, 0}\Bigr) \, {\cal H}$')
    else:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 3e-15, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-21, 'II', color='red')
        plt.plot([], [], color='black',
                 label=r"$k_{{\rm lim}, \alpha_{\rm M}} \, c_{\rm T}" + \
                       r" \, \alpha_{{\rm M}, 0}^{-{1\over2}}$")
        plt.plot([], [], ls='dashed', color='black',
                 label=r"$k_{{\rm lim}, \alpha'_{\rm M}} \, c_{\rm T}" + \
                       r" \, {\alpha_{{\rm M}, 0}^{-{1\over2}}}$")
        plt.legend(fontsize=16, framealpha=1, edgecolor='white')
        plt.ylim(1e-28, 2)
        plt.text(1e10, 1e-26, 'RD', color='black')
        plt.text(1e12, 1e-26, 'MD', color='black')

    plt.xlabel(r'$\eta/\eta_*$')

    plt.vlines(eta_n_EQ, 1e-70, 1e3, color='black')
    plt.vlines(eta_n_L, 1e-70, 1e3, color='black')

    inds = np.where(eta_n < eta_n_EQ)
    inds2 = np.where(eta_n > eta_n_EQ)
    inds3 = np.where(eta_n[inds2] < eta_n_L)
    inds4 = np.where(eta_n[inds2] > eta_n_L)
    plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
    plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                     eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
    plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                     eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)

    plot_sets.axes_lines()

    if ins:
        from mpl_toolkits.axes_grid1.inset_locator import inset_axes
        iax = inset_axes(ax, width="40%", height=1.4, loc=4)
        iax.xaxis.tick_top()
        plt.plot(eta_n, (alpM_I*comp*(1+.5*alpM_I))**nn_exp, color='purple',  lw=2)
        plt.plot(eta_n, (alpM_III*comp*(1+.5*alpM_III))**nn_exp,  lw=2,  color='cyan')
        plt.plot(eta_n, (alpM_0*comp*(1+.5*alpM_0))**nn_exp, lw=2,  color='darkblue')
        plt.plot(eta_n, (alpM_II*comp*(1+.5*alpM_II))**nn_exp, lw=2,  color='red')
        plt.loglog()
        plt.xlim(1e11, eta_n_0)
        plt.ylim(1e-24, 1e-9)
        inds = np.where(eta_n < eta_n_EQ)
        inds2 = np.where(eta_n > eta_n_EQ)
        inds3 = np.where(eta_n[inds2] < eta_n_L)
        inds4 = np.where(eta_n[inds2] > eta_n_L)
        plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
        plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                         eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
        plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                         eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)
        for i in iax.get_xticklabels() + iax.get_yticklabels():
            i.set_fontsize(16)
        plt.xticks([1e12, 1e13])
        plot_sets.axes_lines()
        plt.text(8.5e12, 1e-20, r'$\Lambda$D')

    if save:
        if figg == 1: lsave = 'alphaM_params_EWPT'
        else: lsave = 'params_WKB_lims_EWPT'
        plt.savefig('plots/' + lsave + '.pdf',
                    bbox_inches='tight')
        
def plot_late_time_WKB(save=True):
    
    """
    Function that plots the spectra obtained using the WKB approximation
    in modified gravity for an initial GW background following a smoothed
    double broken power law.
    
    It generates the plots corresponding to figure 2 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP
    (2022).
    
    Figures saved in 'plots/spectrum_WKB_late_times.pdf', 'plots/spectrum_WKB_normalized.pdf'
    """
    
    alpsM0 = np.array([-0.5, -0.3, -0.1, -0.01, 0.5, 0.3, 0.1, 0.01])
    cols = np.array(['blue', 'green', 'red', 'magenta']*2)
    TT_lt_ct = np.zeros((len(k), len(alpsM0)))
    for i in range(0, len(alpsM0)):
        TT_lt_ct[:, i] = ho.WKB_envelope_late_times_const(k, alpT=0, alpM0=alpsM0[i])
        
    S = an.smoothed_dbpl(k, A=1, kb=1, ks=10, a=2, b=0, c=11/3, alpha1=2, alpha2=2)
    
    from matplotlib.patches import Rectangle

    fig, ax = plt.subplots(figsize=(8, 5))
    plt.plot(k, S, color='black', lw=3)
    plot_sets.axes_lines()
    plt.loglog()
    plt.xlim(1e-5, 2e1)
    plt.ylim(7e-7, 1e1)
    plt.xticks(np.logspace(-5, 1, 7))
    plt.yticks(np.logspace(-6, 1, 8))
    plt.xlabel(r'$k$')
    #plt.title(r"$e^{2 {\cal D}} \, S_{h'}^{\rm WKB} (k)/S_{h'}^*$", pad=15)
    plt.ylabel(r"$e^{2 {\cal D}} \, S_{h'}^{\rm WKB} (k)/S_{h'}^*$",
              labelpad=10)

    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, S*TT_lt_ct[:, i], color=cols[i], ls=ls)

    plt.text(2e-5, 4e-5, r'$\alpha_{{\rm M}, 0} = \pm 0.01$',
             color='magenta', fontsize=26)
    plt.text(2e-5, 4e-4, r'$\alpha_{{\rm M}, 0} = \pm 0.1$',
             color='red', fontsize=26)
    plt.text(2e-5, 4e-3, r'$\alpha_{{\rm M}, 0} = \pm 0.3$',
             color='green', fontsize=26)
    plt.text(2e-5, 8e-2, r'$\alpha_{{\rm M}, 0} = \pm 0.5$',
             color='blue', fontsize=26)

    for i in range(0, 4):
        plt.vlines(np.sqrt(abs(alpsM0[i])/2*(1 + .5*alpsM0[i])), 1e-7,
                   1e2, color=cols[i], lw=.8)

    plt.gca().add_patch(Rectangle((0.7,1),9.3,.6,
                        edgecolor='black',
                        facecolor='none',
                        lw=4, alpha=.5))

    ax.annotate("", xy=(3, .8), xytext=(1, 2.5e-3),
                arrowprops=dict(arrowstyle="->"))

    from mpl_toolkits.axes_grid1.inset_locator import inset_axes
    iax = inset_axes(ax, width="35%", height=1.6, loc=4)
    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, S*TT_lt_ct[:, i], color=cols[i], ls=ls)
    plt.plot(k, S, color='black')
    plt.loglog()
    plt.xlim(7e-1, 1e1)
    plt.ylim(1, 2)
    iax.set_yticks([])
    iax.get_yaxis().set_visible(False)
    plt.xticks([])
    plt.yticks([])
    xx = np.logspace(.3, .8)
    plt.plot(xx, 1.75*xx**(-0.06), color='black', lw=.8)
    xx = np.logspace(.35, .75)
    plt.plot(xx, 1.12*xx**(.08), color='black', lw=.8)
    plt.text(3, 1.7, r'$k^{-0.06}$')
    plt.text(3, 1.1, r'$k^{0.08}$')
    
    if save:
        plt.savefig('plots/spectrum_WKB_late_times.pdf',
                    bbox_inches='tight')

    plt.figure(figsize=(8, 5))
    plt.plot(k, k**0, color='black', lw=3)
    plot_sets.axes_lines()
    plt.loglog()
    plt.xlim(1e-2, 2e1)
    plt.ylim(3e-1, 1e1)
    plt.xlabel(r'$k$')

    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, TT_lt_ct[:, i], color=cols[i], ls=ls)

    for i in range(0, 4):
        plt.vlines(np.sqrt(abs(alpsM0[i])/2*(1 + .5*alpsM0[i])), 1e-7, 1e2, color=cols[i],
                   lw=.8)
    #plt.title(r"$\xi^{\rm WKB} (k)$", pad=15)
    plt.ylabel(r"$\xi^{\rm WKB} (k)$", labelpad=10)
    
    if save:
        plt.savefig('plots/spectrum_WKB_normalized.pdf',
                    bbox_inches='tight')
        
def time_evolution_WKB(eta_nn, HH_nn, a_nn, ast, Omega_nn,
                       OmM0, Omega_mat_nn, read=True,
                       save=True):

    """
    Function that computes the D = .5 int alpM HH d eta integral
    for the different choices of alphaM parameterization that appears
    in the WKB approximation for the increase in GW energy density.
    
    Reference: Y. He, A. Roper Pol, A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    If read is False, it computes D and stores it as a pickle variable in
    'WKB/DDs.pkl', otherwise it directly reads it.
    """
    
    alpsM0 = alpsM0_g
    
    if read:
        import pickle
        with open('WKB/DDs.pkl', 'rb') as f:
            DDs = pickle.load(f)
        DDs_0 = DDs.get('0')
        DDs_I = DDs.get('I')
        DDs_I_n2 = DDs.get('I_n2')
        DDs_I_n04 = DDs.get('I_n04')
        DDs_II = DDs.get('II')
        DDs_III = DDs.get('III')
        
    else:
        NN = len(alpsM0)
        DDs_0 = np.zeros((len(eta_nn), NN))
        DDs_I = np.zeros((len(eta_nn), NN))
        DDs_I_n04 = np.zeros((len(eta_nn), NN))
        DDs_I_n2 = np.zeros((len(eta_nn), NN))
        DDs_II = np.zeros((len(eta_nn), NN))
        DDs_III = np.zeros((len(eta_nn), NN))

        for i in range(0, len(alpsM0)):
            alpM0 = alpsM0[i]
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='0')
            DDs_0[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=2)
            DDs_I_n2[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=0.4)
            DDs_I_n04[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=1)
            DDs_I[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='II', Omega=Omega_nn)
            DDs_II[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='III', OmM0=OmM0,
                                                Omega=Omega_nn, Omega_mat=Omega_mat_nn)
            DDs_III[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)

        if save:
            import pickle
            DDs = {'0' : DDs_0, 'I' : DDs_I, 'I_n2' : DDs_I_n2, 'I_n04' : DDs_I_n04,
                   'II' : DDs_II, 'III' : DDs_III, 'alpsM' : alpsM0, 'eta' : eta_nn}
            with open('WKB/DDs.pkl', 'wb') as f:
                pickle.dump(DDs, f)
        
    return DDs_0, DDs_I, DDs_I_n04, DDs_I_n2, DDs_II, DDs_III

def run(rsd='all', dirs={}):
    
    """
    Function that loads the pickle variables of the runs after they have
    been read by the initialize_horndeski.py routine.
    """

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = {}
    if rsd == 'all': dirs = rd('horndeski', dirs={})
    if rsd == 'M0': dirs = rd('horndeski_M0', dirs={})
    if rsd == 'M0_lowk': dirs = rd('horndeski_M0_lowk', dirs={})
    if rsd == 'M1': dirs = rd('horndeski_M1', dirs={})
    if rsd == 'M2': dirs = rd('horndeski_M2', dirs={})
    if rsd == 'M3': dirs = rd('horndeski_M3', dirs={})
    if rsd == 'M3_lowk': dirs = rd('horndeski_M3_lowk', dirs={})
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0 + 'dir_runs/', dirs, quiet=False)
    os.chdir(dir0)

    return runs
        
def plot_time_evolution_EGW(DDs, eta_nn, DDs2=0, value0=False, choice='0', runs=0, ordr=20,
                            txt=True, save=True, save_pl=True, plot=True, read=False,
                            quiet=False):
    
    """
    Function that plots the time evolution of the GW energy density from
    the numerical simulations and using the WKB approximation in modified
    gravity.
    
    It generates the plots corresponding to figure 3 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/time_series_EEGW_choice'#'.pdf'
    """
        
    if plot:
        fig, ax = plt.subplots(figsize=(12, 8))
        plot_sets.axes_lines()
        ax.loglog()
        ax.set_xlim(1, eta_nn[-1])
        ax.set_xlabel(r'$\eta/\eta_*$')
        ax.loglog()
    
    p = '0'
    if choice == '0' or choice == 'III':
        runsA = runs_ng
        alpsM0 = alpsM0_g
        cols = cols_g
        if choice == 'III': p = '3'
    if choice == 'I' or choice == 'II':
        if choice == 'I': p = '1'
        if choice == 'II': p = '2'
        runsA = runs_n2g
        alpsM0 = alpsM02_g
        cols = cols2_g
        if plot:
            from mpl_toolkits.axes_grid1.inset_locator import inset_axes
            iax = inset_axes(ax, width="90%", height=2.5, loc=4)
            plot_sets.axes_lines()
        
    rrs = ['M' + p + i for i in runsA]
    rrs_b = ['M' + p + i + '_LD2' for i in runsA]
        
    for i in range(0, len(rrs)):
        
        alpM0 = alpsM0[i]
        WKB = np.exp(-2*DDs[:, i])
        if choice == 'I' or choice == 'II':
            if choice == 'I':
                if alpM0 < 0.1: DD = DDs[:, i]
                if alpM0 > 0: DD = DDs2[:, i+1]
                WKB = np.exp(-2*DD)
            if choice == 'II':
                if alpM0 > 0: WKB = np.exp(-2*DDs[:, i+1])
                    
        if read:
            
            import pickle
            fll = 'results/ts_' + rrs[i] + '.pkl'
            if not quiet: print('Reading file for time series from %s'%fll)
            with open(fll, 'rb') as f:
                tsd = pickle.load(f)
            tts_corr = np.array(tsd.get('ts'))
            ttsb = np.array(tsd.get('tsb'))
            EGW_num_corr = np.array(tsd.get('EGW'))
            EGWb_norm = np.array(tsd.get('EGWb'))
            
        else:
            
            MM = runs.get(rrs[i])
            sp = MM.spectra
            ts = MM.ts
            ksp, GWs, GWs0, tsp, tts, EEGW, A = spec_tts(sp, ts)
            MMb = runs.get(rrs_b[i])
            spb = MMb.spectra
            tsb = MMb.ts
            kspb, GWsb, GWs0b, tspb, ttsb, EEGWb, Ab = spec_tts(spb, tsb)
            EGWb_norm = EEGWb/EEGW[0]
            rel_err, inds_min, inds_max, tts_corr, rel_err_corr, EGW_num_corr = \
                    rel_error(tts, eta_nn, WKB, EEGW/EEGW[0], order=ordr, tts_lim=0)
            rel_errb, inds_minb, inds_maxb, tts_corrb, rel_err_corrb, EGWb_num_corr = \
                    rel_error(ttsb, eta_nn, WKB, EGWb_norm, order=ordr, tts_lim=0)
            
            if save:
            
                tsd = ({'ts': tts_corr, 'tsb': tts_corrb, 'EGW': EGW_num_corr,
                        'EGWb': EGWb_num_corr, 'rel_err': rel_err_corr,
                        'rel_errb': rel_err_corrb})

                import pickle
                fll = 'results/ts_' + rrs[i] + '.pkl'
                if not quiet: print('Saving file for time series in %s'%fll)
                with open(fll, 'wb') as f:
                    pickle.dump(tsd, f)
        
        if value0:
            value00 = np.interp(eta_nn[-1], ttsb, EGWb_norm)
            print('For run ', rrs[i], 'the value at \eta_0 of EEGW is ',
                  value00)
        
        if plot:
            
            ax.plot(eta_nn, WKB, color=cols[i], alpha=.5)
            ax.plot(tts_corr, EGW_num_corr, color=cols[i], ls='dashed')
            ax.plot(ttsb, EGWb_norm, color=cols[i], ls='dashed')
            if choice == 'I' or choice == 'II':
                iax.plot(tts_corr, EGW_num_corr, color=cols[i], ls='dashed')
                iax.plot(eta_nn, WKB, color=cols[i], alpha=.5)
                iax.plot(ttsb, EGWb_norm, color=cols[i])

    if plot:
        if choice == '0' or choice == 'III':
            ax.set_ylim(1e-5, 1e9)
            ax.set_yticks(np.logspace(-5, 9, 8))
            ax.set_ylabel(r'${\cal E}_{\rm GW} (\eta)/{\cal E}_{\rm GW}^*$')
        if choice == 'I' or choice == 'II':
            ax.set_ylim(4.5e-1, 1.6)
            ax.set_ylabel(r'${\cal E}_{\rm GW} (\eta)/{\cal E}_{\rm GW}^*$',
                          labelpad=-40)
            iax.loglog()
            if choice == 'I':
                iax.set_xlim(1e12, eta_nn[-1])
            if choice == 'II':
                iax.set_xlim(1.3e12, eta_nn[-1])

            iax.set_xticks([1e12, 1e13])
            iax.set_yticks([])
            iax.set_ylim(4.5e-1, 1.6)
            iax.xaxis.tick_top()
            iax.tick_params(axis='both', which='major', pad=10)
            for i in iax.get_xticklabels() + iax.get_yticklabels():
                i.set_fontsize(18)
            iax.set_xticks([1e13, 2e13])
            iax.axes.get_yaxis().set_visible(False)

    if plot and txt:
        if choice == '0':
            plt.text(1e8, 1e6, r'$\alpha_{{\rm M}, 0} = -0.5$',
                     color='blue', fontsize=30)
            plt.text(3e7, 2e3, r'$\alpha_{{\rm M}, 0} = -0.3$',
                     color='green', fontsize=30)
            plt.text(1e10, 5e1, r'$\alpha_{{\rm M}, 0} = -0.1$',
                     color='red', fontsize=30)
            plt.text(5e9, 2.5, r'$\alpha_{{\rm M}, 0} = -0.01$',
                     color='magenta', fontsize=30)
            plt.text(1e10, 5e-3, r'$\alpha_{{\rm M}, 0} = 0.1$',
                     color='purple', fontsize=30)
            plt.text(1e7, 1.5e-4, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=30)
            # place a text box in upper left in axes coords
            plt.text(5, 5e6, 'choice 0', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white',
                               alpha=0.5))

            xx = np.logspace(3, 10)
            plt.plot(xx, 3*xx**(.5), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 5e-7*xx**(.5*2), color='blue', ls='dashed')
            xx = np.logspace(3, 7)
            plt.plot(xx, 2*xx**(.3), color='green', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 2e-4*xx**(.3*2), color='green', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(.1), color='red', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 5e-2*xx**(.1*2), color='red', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(-.1), color='purple', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 1e1*xx**(-.1*2), color='purple', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(-.3), color='orange', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 2e3*xx**(-.3*2), color='orange', ls='dashed')
            plt.text(1e5, 1e4, r'$\sim\!\eta^{-\alpha_{{\rm M}, 0}}$',
                     fontsize=26, color='black')
            plt.text(3e11, 1.3e5, r'$\sim\!\eta^{-2 \alpha_{{\rm M}, 0}}$',
                     fontsize=26, color='black')
            
        if choice == 'I':
            iax.text(8e12, 1.3, r'$\alpha_{{\rm M}, 0} = -0.5$, $n = 2$',
                     color='blue', fontsize=26)
            iax.text(6e12, 1.1, r'$\alpha_{{\rm M}, 0} = -0.3$, $n = 2$',
                     color='green', fontsize=26)
            iax.text(1.5e12, 1.05, r'$\alpha_{{\rm M}, 0} = -0.1$, $n = 2$',
                     color='red', fontsize=26)
            iax.text(7e12, .67, r'$\alpha_{{\rm M}, 0} = 0.1$, $n = 0.4$',
                     color='purple', fontsize=26)
            iax.text(2e12, 6.5e-1, r'$\alpha_{{\rm M}, 0} = 0.3$, $n = 0.4$',
                     color='orange', fontsize=26)
            # place a text box in upper left in axes coords
            ax.text(5, 1.33e0, 'choice I', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
            
        if choice == 'II':
            iax.text(1.05e13, 1.22, r'$\alpha_{{\rm M}, 0} = -0.5$',
                     color='blue', fontsize=26)
            iax.text(8e12, 1.06, r'$\alpha_{{\rm M}, 0} = -0.3$',
                     color='green', fontsize=26)
            iax.text(3e12, 1.05, r'$\alpha_{{\rm M}, 0} = -0.1$',
                     color='red', fontsize=26)
            iax.text(1.1e13, .83, r'$\alpha_{{\rm M}, 0} = 0.1$',
                     color='purple', fontsize=26)
            iax.text(1.3e13, 7e-1, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=26)
            # place a text box in upper left in axes coords
            ax.text(5, 1.33e0, 'choice II', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
            
        if choice == 'III':
            ax.text(1e8, 2e5, r'$\alpha_{{\rm M}, 0} = -0.5$',
                    color='blue', fontsize=30)
            ax.text(5e7, 8e2, r'$\alpha_{{\rm M}, 0} = -0.3$',
                    color='green', fontsize=30)
            ax.text(1e10, 1e2, r'$\alpha_{{\rm M}, 0} = -0.1$',
                    color='red', fontsize=30)
            ax.text(5e9, 2.5, r'$\alpha_{{\rm M}, 0} = -0.01$',
                    color='magenta', fontsize=30)
            ax.text(5e6, 5e-3, r'$\alpha_{{\rm M}, 0} = 0.1$',
                    color='purple', fontsize=30)
            ax.text(1e4, 1.5e-4, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=30)
            xx = np.logspace(3, 10)
            ax.plot(xx, 3*xx**(.5*1.5), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            ax.plot(xx, 1e8*xx**(0), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            ax.plot(xx, 5e4*xx**(0), color='green', ls='dashed')
            ax.text(1e5, 6e5, r'$\sim\!\eta^{-1.5 \, \alpha_{{\rm M}, 0}}$',
                    fontsize=26, color='black')
            ax.text(1.5e12, 1e7, r'$\sim\!\eta^{0}$',
                    fontsize=26, color='black')
            ax.text(5, 5e6, 'choice III', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
                
    if save_pl and plot:
        ffl = 'plots/time_series_EEGW_choice' + choice + '.pdf'
        print('Saving figure %s'%ffl)
        plt.savefig(ffl, bbox_inches='tight')
    
def spec_tts(sp, ts):
    
    """
    Function that reads the variables of a specific run
    and returns the relevant ones.
    
    Arguments:
      sp -- spectra dictionary, part of a run object
      ts -- time series dictionary, part of a run object
      
    Returns:
      ksp -- wave number array of the spectrum
      GWs -- array of spectral strains derivative S_h' vs time and k
      GWs0 -- array of spectral strains derivative S_h' at initial time
      tsp -- array of spectral times
      tts -- array of time series times
      EEGW -- array of time series GW energy density 
      A -- spectral amplitude using the smoothed double broken power law
    """
    
    import scipy.optimize as opt
    
    ksp = sp.get('k')
    GWs = sp.get('GWs')
    GWs0 = GWs[0, :]
    tsp = sp.get('t_GWs')
    tts = ts.get('t')
    EEGW = ts.get('EEGW')
    
    # fit the initial time spectrum to the smoothed double broken
    # power law to infer the amplitude
    popt, pcov = opt.curve_fit(an.smoothed_dbpl, ksp[1:], GWs0[1:],
                                   p0=(1))
    A = popt[0]
    
    return ksp, GWs, GWs0, tsp, tts, EEGW, A

def rel_error(tts, etas, EGW_WKB, EGW_num, order=40, tts_lim=1e3):
    
    """
    Function that computes the relative error in the time
    series of the WKB approximation compared to the numerical
    solutions and removes points out of the curve.
    """

    import scipy.signal as sig
    
    WKB = np.interp(tts, etas, EGW_WKB)
    rel_err = (WKB - EGW_num)/EGW_num
    ind_lim = np.argmin(abs(tts - tts_lim))
    inds_min = sig.argrelmin(rel_err[ind_lim:], order=order)
    inds_max = sig.argrelmax(rel_err[ind_lim:], order=order)
    inds_min += ind_lim
    inds_max += ind_lim
    tts_corr = np.delete(tts, np.append(inds_min, inds_max))
    rel_err_corr = np.delete(rel_err, np.append(inds_min, inds_max))
    EGW_num_corr = np.delete(EGW_num, np.append(inds_min, inds_max))
    
    return rel_err, inds_min, inds_max, tts_corr, rel_err_corr, \
            EGW_num_corr

def plot_time_series_error_WKB(DDs, eta_nn, DDs2=0, choice='0',
                               plot=True, save_pl=True, quiet=True):
    
    """
    Function that plots the error of the time evolution of the GW energy
    density computed using the WKB approximation in modified gravity,
    compared to the results from numerical simulations.
    
    It generates the plots corresponding to figure 4 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era,"
    submitted to JCAP (2022).
    
    It requires to first generate the results for the time series
    using plot_time_evolution_EGW
    
    Figures saved in 'plots/time_series_alpM_choice#_error_WKB.pdf'
    """
    
    if plot:
        
        fig, ax = plt.subplots(figsize=(8, 5))
        ax.set_xscale('log')
        if choice == '0' or choice == 'III':
            ax.set_ylim(-0.06, .15)
            ax.set_yticks(np.linspace(-.05, .15, 5))
        if choice == 'I' or choice == 'II':
            from mpl_toolkits.axes_grid1.inset_locator import inset_axes
            plot_sets.axes_lines()
            if choice == 'I':
                iax = inset_axes(ax, width="58%", height=1.6, loc=1)
                ax.set_ylim(-0.005, 0.01)
                ax.set_yticks(np.linspace(-.005, .01, 7))
            if choice == 'II':
                ax.set_ylim(-0.02, 0.1)
                ax.set_yticks(np.linspace(0, .075, 4))
                iax = inset_axes(ax, width="55%", height=2.2, loc=1)
        ax.set_xlim(1, eta_nn[-1])
        ax.set_xlabel(r'$\eta/\eta_*$')
        ax.set_ylabel(r'$\varepsilon^{\rm WKB} ({\cal E}_{\rm GW})$')
        ax.set_xticks(np.logspace(1, 13, 7))
        plot_sets.axes_lines()
        ax.set_title(r'$\alpha_{\rm M}$ choice %s'%choice, pad=15)
    
    p = '0'
    if choice == '0' or choice == 'III':
        runsA = runs_ng
        alpsM0 = alpsM0_g
        cols = cols_g
        if choice == 'III': p = '3'
    if choice == 'I' or choice == 'II':
        if choice == 'I': p = '1'
        if choice == 'II': p = '2'
        runsA = runs_n2g
        alpsM0 = alpsM02_g
        cols = cols2_g
        
    rrs = ['M' + p + i for i in runsA]
    rrs_b = ['M' + p + i + '_LD2' for i in runsA]
    
    for i in range(0, len(rrs)):
        
        alpM0 = alpsM0[i]
        WKB = np.exp(-2*DDs[:, i])
        if choice == 'I':
            if alpM0 < 0.1: DD = DDs[:, i]
            if alpM0 > 0: DD = DDs2[:, i+1]
            WKB = np.exp(-2*DD)
        if choice == 'II' and alpM0 > 0: WKB = np.exp(-2*DDs[:, i+1])
                    
        import pickle
        fll = 'results/ts_' + rrs[i] + '.pkl'
        if not quiet: print('Reading file for time series from %s'%fll)
        with open(fll, 'rb') as f:
            tsd = pickle.load(f)
        tts_corr = np.array(tsd.get('ts'))
        tts_corrb = np.array(tsd.get('tsb'))
        EGW_num_corr = np.array(tsd.get('EGW'))
        EGWb_num_corr = np.array(tsd.get('EGWb'))
        rel_err_corr = np.array(tsd.get('rel_err'))
        rel_err_corrb = np.array(tsd.get('rel_errb'))

        if plot:
            if alpsM0[i] == -0.01: lbl = r'$\alpha_{{\rm M}, 0} = %.2f$'%alpM0
            else: lbl = r'$\alpha_{{\rm M}, 0} = %.1f$'%alpM0
            ax.plot(tts_corr, rel_err_corr, '.', color=cols[i],
                     label=lbl)
            ax.plot(tts_corrb, rel_err_corrb, '.', color=cols[i])
            if choice=='I' or choice == 'II':
                iax.plot(tts_corr, rel_err_corr, '.', color=cols[i])
                iax.plot(tts_corrb, rel_err_corrb, '.', color=cols[i]) 
    
    if plot:
        lc = 'upper right'
        if choice == 'I' or choice == 'II':
            lc = 'upper left'
            iax.set_xscale('log')
            if choice == 'I':
                iax.set_ylim(-0.005, 0.01)
                iax.set_xlim(1e12, eta_nn[-1])
                iax.set_xticks([1e12, 1e13])
            if choice == 'II':
                iax.set_ylim(-.02, 0.1)
                iax.set_xlim(8e12, eta_nn[-1])
                iax.set_xticks([1e13, 2e13])
            iax.set_yticks([])
            iax.tick_params(axis='both', which='major', pad=8)
            for i in iax.get_xticklabels() + iax.get_yticklabels():
                i.set_fontsize(16)
        ax.legend(frameon=False, fontsize=18, labelcolor='linecolor', loc=lc)
        
        if save_pl:
            ffl = 'plots/time_series_alpM_choice' + choice + '_error_WKB.pdf'
            print('Saving figure %s'%ffl)
            plt.savefig(ffl, bbox_inches='tight')
        
def read_four_runs(runs, eta_nn, a, Omega, Omega_mat, OmM0, DDs, DDs2=0,
                   ch='0', A='A', lowk=True, runs_lowk=0):
    
    """
    Function that reads the 4 runs that have been dedicated to each case:
    1. Normal run
    2. Run with time data points refined and only during LD era (_LD2)
    3. Run with larger domain (smaller k) covering the lowk part of the spectrum
    4. Run with larger domain (smaller k) covering the lowk part of the spectrum
            and with time data points refined and only during LD era (_LD2)
    """
    
    p = '0'
    if ch == '0' or ch == 'III':
        if ch == 'III': p = '3'
        runsA = runs_ng
        ind = np.where([A in i for i in runsA])[0][0]
        runA = 'M' + p + runsA[ind]
        alpM0 = alpsM0_g[ind]
        col = cols_g[ind]
        DD = DDs[:, ind]
    if ch == 'I' or ch == 'II':
        if ch == 'I': p = '1'
        if ch == 'II': p = '2'
        runsA = runs_n2g
        ind = np.where([A in i for i in runsA])[0][0]
        runA = 'M' + p + runsA[ind]
        alpM0 = alpsM02_g[ind]
        col = cols2_g[ind]
        DDDs = DDs
        if alpM0 < 0: DD = DDs[:, ind]
        else:
            if ch == 'I': DD = DDs2[:, ind + 1]
            else: DD = DDs[:, ind + 1]
        
    MM = runs.get(runA)
    sp = MM.spectra
    ts = MM.ts
    MMb = runs.get(runA + '_LD2')
    spb = MMb.spectra
    tsb = MMb.ts
    if lowk:
        MMc = runs_lowk.get(runA + '_lowk')
        spc = MMc.spectra
        tsc = MMc.ts
        MMd = runs_lowk.get(runA + '_lowk_LD2')
        spd = MMd.spectra
        tsd = MMd.ts
        
    alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice=ch, a=a,
                                       Omega=Omega, Omega_mat=Omega_mat,
                                       OmM0=OmM0)
    
    if lowk:
        return sp, ts, spb, tsb, spc, tsc, spd, tsd, DD, \
                alpM0, col, runA, alpM
    else:
        return sp, ts, spb, tsb, DD, alpM0, col, runA, alpM
    
def compute_spectra(runs, eta_nn, HH_nn, a_nn, Omega_nn, Omega_mat_nn, OmM0, DDs,
                    DDs2=0, ch='I', A='A', col='green', plot=True,
                    lowk=True, WKB_sols=False, runs_lowk=0, save=True):
    
    """
    Function that computes the spectra combining the 4 runs for each
    case considered.
    It uses the numerical spectra to obtain the envelope over oscillations
    at each wave number and compensates by the total growth in the GW
    energy density obtained (and verified) from the WKB approximation.
    It also returns the WKB estimated spectra at late times.
    """
        
    #### Numerical spectra of 4 runs for each case
    if lowk:
        sp, ts, spb, tsb, spc, tsc, spd, tsd, DD, alpM0, col, runA, alpM = \
                read_four_runs(runs, eta_nn, a_nn, Omega_nn, Omega_mat_nn,
                               OmM0, DDs, DDs2=DDs2, ch=ch, A=A, lowk=lowk,
                               runs_lowk=runs_lowk)
    else:
        sp, ts, spb, tsb, DD, alpM0, col, runA, alpM = \
                read_four_runs(runs, eta_nn, a_nn, Omega_nn, Omega_mat_nn,
                               OmM0, DDs, DDs2=DDs2, ch=ch, A=A, lowk=lowk)
        
    ksp, GWs, GWs0, tsp, tts, EEGW, A = spec_tts(sp, ts)
    kspb, GWsb, GWs0b, tspb, ttsb, EEGWb, Ab = spec_tts(spb, tsb)
    if lowk:
        kspc, GWsc, GWs0c, tspc, ttsc, EEGWc, Ac = spec_tts(spc, tsc)
        kspd, GWsd, GWs0d, tspd, ttsd, EEGWd, Ad = spec_tts(spd, tsd)
        
    #### Analytical spectra using smoothed double broken power law (has to be
    #### the same parameters as those used in spec_tts to obtain A from the numerical
    #### values)
    S = an.smoothed_dbpl(k, A=1, kb=1, ks=10, a=2, b=0, c=11/3, alpha1=2, alpha2=2)
    g0 = np.sqrt(S)
    h0 = np.sqrt(S/k**2)
    
    #### Compute solutions using WKB approximation
    WKB_sp_lt = ho.WKB_envelope_late_times_const(k, alpT=0, alpM0=alpM0)
    
    #### interpolate WKB functions in time arrays of the simulations
    if WKB_sols:
        SgtGR, SgtmodGR = ho.sol_WKB(k, eta_nn, HH_nn, DD, eta_ini=1, h0=h0, g0=g0,
                                     alpM=alpM, alpM0=alpM0)
        WKB_sp = ho.WKB_envelope(k, eta_nn, HH_nn, DD,
                                 alpM=alpM, alpT=[0], alpM0=alpM0)
        SgtGRt = np.zeros((len(tsp), len(k)))
        SgtmodGRt = np.zeros((len(tsp), len(k)))
        WKB_spt = np.zeros((len(tsp), len(k)))
        SgtGRtb = np.zeros((len(tspb), len(k)))
        SgtmodGRtb = np.zeros((len(tspb), len(k)))
        WKB_sptb = np.zeros((len(tspb), len(k)))
        for i in range(0, len(k)):
            SgtGRt[:, i] = np.interp(tsp, eta_nn, SgtGR[:, i])
            SgtmodGRt[:, i] = np.interp(tsp, eta_nn, SgtmodGR[:, i])
            WKB_spt[:, i] = np.interp(tsp, eta_nn, WKB_sp[:, i])
            SgtGRtb[:, i] = np.interp(tspb, eta_nn, SgtGR[:, i])
            SgtmodGRtb[:, i] = np.interp(tspb, eta_nn, SgtmodGR[:, i])
            WKB_sptb[:, i] = np.interp(tspb, eta_nn, WKB_sp[:, i])
    DDt = np.interp(tsp, eta_nn, DD)
    DDtb = np.interp(tspb, eta_nn, DD)
    if lowk:
        DDtc = np.interp(tspc, eta_nn, DD)
        DDtd = np.interp(tspd, eta_nn, DD)

    #### Growth of GW energy density at times t
    QQ = np.exp(-2*DDt)
    QQb = np.exp(-2*DDtb)
    if lowk:
        QQc = np.exp(-2*DDtc)
        QQd = np.exp(-2*DDtd)
        
    #### Compute the envelope function and the average
    #### over relevant time spans (where k mode is oscillating)
    #### from the numerical simulations
    QQ_ij, kij = np.meshgrid(QQ, ksp, indexing='ij')
    envl, avg = spec.envelope_avg(ksp, tsp, eta_nn[-1], GWs/QQ_ij, lk=10, tini=1)
    QQb_ij, kij = np.meshgrid(QQb, kspb, indexing='ij')
    envlb, avgb = spec.envelope_avg(kspb, tspb, eta_nn[-1], GWsb/QQb_ij, lk=10, tini=1)
    if lowk:
        QQc_ij, kij = np.meshgrid(QQc, kspc, indexing='ij')
        envlc, avgc = spec.envelope_avg(kspc, tspc, eta_nn[-1], GWsc/QQc_ij, lk=10, tini=1)
        QQd_ij, kij = np.meshgrid(QQd, kspd, indexing='ij')
        envld, avgd = spec.envelope_avg(kspd, tspd, eta_nn[-1], GWsd/QQd_ij, lk=10, tini=1)

    #### klim at which WKB is estimated to break down
    klimaM = np.sqrt(abs(alpM0)/2*(1 + .5*alpM0))
    
    if plot:
        plt.plot(k, S*A, color='black', lw=3)
        plt.plot(ksp[1:], GWs[0, 1:])
        plt.plot(k, WKB_sp_lt*S*A, color=col, lw=2, ls='dashed')
        plt.plot(ksp[1:], .5*envl[1:], color=col)
        if lowk:
            plt.plot(kspc[1:], .5*envlc[1:]*A/Ac, color=col)
        plt.vlines(klimaM, 1e-20, 1e0, color=col, ls='dotted')
        
    if lowk: return ksp, kspc, klimaM, WKB_sp_lt*S*A, envl, envlc*A/Ac, S*A
    else: return ksp, klimaM, WKB_sp_lt*S*A, envl, S*A
    
def compute_all_spectra(eta_nn, HH_nn, a_nn, Omega_nn, Omega_mat_nn, OmM0, DDs,
                        runs=0, runs_lowk=0, DDs2=0, save=True, read=False, ch='0'):
    
    """
    Function that computes all spectra for a specific choice of alpM parameterization:
        '0', 'I', 'II' or 'III'
    It returns the results for the different values of alpM0: 'A' to 'F' (choices 0 or III)
    or 'A' to 'E' (choices I and II).
    It returns separately the results for positive and negative values of alpM
    
    If save = True and read = False, then it computes the spectra and saves the results in
            'results/pos_alpM_sp_ch#ch.pkl'
    
    If read = True, then it reads the already computed results.
    """
    
    if read:
        
        import pickle
        fll = 'results/neg_alpM_sp_ch' + ch + '.pkl'
        print('Reading results from pickle variable %s'%fll)
        with open(fll, 'rb') as f:
            neg_alpM_sp_ch = pickle.load(f)
        fll = 'results/pos_alpM_sp_ch' + ch + '.pkl'
        print('Reading results from pickle variable %s'%fll)
        with open(fll, 'rb') as f:
            pos_alpM_sp_ch = pickle.load(f)

    else:
        
        neg_alpM_sp_ch = ({'k': k})
        pos_alpM_sp_ch = ({'k': k})
        if ch == '0' or ch == 'III':
            for i in range(0, len(runs_ng)):
                A = runs_ng[i]
                ksp_A, kspc_A, klimaM_A, WKB_A, env_A, envc_A, S_A = \
                        compute_spectra(runs, eta_nn, HH_nn, a_nn, Omega_nn, Omega_mat_nn,
                                        OmM0, DDs, ch=ch, A=A, plot=False,
                                        lowk=True, runs_lowk=runs_lowk)
                if i < 4:
                    neg_alpM_sp_ch.update({'k%s'%A: ksp_A, 'kc%s'%A: kspc_A, 'klimaM_%s'%A: klimaM_A,
                                          'WKB%s'%A : WKB_A, 'sp_env%s'%A: env_A, 'sp_envc%s'%A: envc_A,
                                          'S%s'%A: S_A})
                else:
                    pos_alpM_sp_ch.update({'k%s'%A: ksp_A, 'kc%s'%A: kspc_A, 'klimaM_%s'%A: klimaM_A,
                                          'WKB%s'%A : WKB_A, 'sp_env%s'%A: env_A, 'sp_envc%s'%A: envc_A,
                                          'S%s'%A: S_A})

        else:
            for i in range(0, len(runs_n2g)):
                A = runs_n2g[i]
                ksp_A, klimaM_A, WKB_A, env_A, S_A = \
                        compute_spectra(runs, eta_nn, HH_nn, a_nn, Omega_nn, Omega_mat_nn,
                                        OmM0, DDs, DDs2=DDs2, ch=ch, A=A, plot=False, lowk=False)
                
                if i < 3:
                    neg_alpM_sp_ch.update({'k%s'%A: ksp_A, 'klimaM_%s'%A: klimaM_A,
                                          'WKB%s'%A : WKB_A, 'sp_env%s'%A: env_A, 'S%s'%A: S_A})
                else:
                    pos_alpM_sp_ch.update({'k%s'%A: ksp_A, 'klimaM_%s'%A: klimaM_A,
                                          'WKB%s'%A : WKB_A, 'sp_env%s'%A: env_A, 'S%s'%A: S_A})
        
        if save:
            
            import pickle
            fll = 'results/neg_alpM_sp_ch' + ch + '.pkl'
            print('Saving results in pickle variable %s'%fll)
            with open(fll, 'wb') as f:
                pickle.dump(neg_alpM_sp_ch, f)
 
            fll = 'results/pos_alpM_sp_ch' + ch + '.pkl'
            print('Saving results in pickle variable %s'%fll)
            with open(fll, 'wb') as f:
                pickle.dump(pos_alpM_sp_ch, f)
                
    return neg_alpM_sp_ch, pos_alpM_sp_ch

def plot_spectra(ks, S, WKB, ksp, env, klimaM, kspc=0, envlc=0, S_p=True, nkk=100,
                 nkk2=100, lowk=True, col='blue', v0=1e-16, v1=1e0, WKB_p=True, lss='solid'):
    
    """
    Function that plots the spectra for one single case of \alpM0 and choice.
    """
    
    if S_p: plt.plot(ks, S, color='black', lw=2)
    if WKB_p: plt.plot(ks, WKB, color=col, lw=.7, ls='dashed')
    kka = np.logspace(np.log10(ksp[1]), np.log10(ksp[-1]), nkk)
    plt.plot(kka, np.interp(kka, ksp[1:], .5*env[1:]), color=col, ls=lss)
    kkc = np.logspace(np.log10(kspc[1]), -3, nkk)
    if lowk: plt.plot(kkc, np.interp(kkc, kspc[1:], .5*envlc[1:]), color=col, ls=lss)
    plt.vlines(klimaM, v0, v1, color=col, lw=.8)
    
def read_values_spectra(spectra, A='A'):
    
    """
    Function that reads the variables of a specific spectra of choice and alpM0.
    """
    
    S = np.array(spectra.get('S%s'%A))
    WKB = np.array(spectra.get('WKB%s'%A))
    ks = np.array(spectra.get('k%s'%A))
    env = np.array(spectra.get('sp_env%s'%A))
    klim = np.array(spectra.get('klimaM_%s'%A))
    kspc = np.array(spectra.get('kc%s'%A))
    envc = np.array(spectra.get('sp_envc%s'%A))
    
    return S, WKB, ks, env, klim, kspc, envc
    
def plot_all_spectra(spectra, neg=True, app=0, kspcD=0, envcD=0, ch='0', save=True, newf=True,
                     lss='solid', txt=True, fact=3.5e-10):
    
    """
    Function that computes the spectra combining the 4 runs for all cases A to D
    for choices 0 and III (negative values of alpha_M)
    It uses the numerical spectra to obtain the envelope over oscillations
    at each wave number and compensates by the total growth in the GW
    energy density obtained (and verified) from the WKB approximation.
    It also returns the WKB estimated spectra at late times.
    
    It generates the plots corresponding to figure 5 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era,"
    submitted to JCAP (2022).
    Negative values of alpM (left panel) if neg is True and positive
    values (right panel) if neg is False.
    
    Figure saved in 'plots/spectra_envelope_choices_0_III.pdf'
    """
    
    if newf:
        
        plt.figure(figsize=(12, 8))
        plt.loglog()
        plot_sets.axes_lines()
        plt.xlabel(r'$k$')
        #plt.title(r"$e^{2 {\cal D}} \, S_{h'}^{\rm num} (k)/S_{h'}^*$", pad=15)
        plt.ylabel(r"$e^{2 {\cal D}} \, S_{h'}^{\rm num} (k)/S_{h'}^*$", labelpad=10)
        plt.vlines(np.sqrt(app), 1e-20, 1e3, color='black')
        plt.ylim(3e-8, 3)
        plt.xlim(1e-7, 1e1)
        plt.xticks(np.logspace(-7, 1, 9))
        plt.yticks(np.logspace(-7, 0, 8))
        if txt:
            plt.text(2.2e-6, 1e-10/fact, r"$k_{{\rm lim}, a''}^{\rm EW}$", fontsize=30)
            plt.text(6e-1, 1e-12/fact, r'$k_{{\rm lim}, \alpha_{\rm M}}$', fontsize=30)
            
            if neg:
                plt.text(1e-3, 4e-11/fact, r'$\alpha_{\rm M} = -0.5$',
                         color='blue', fontsize=24)
                plt.text(4e-5, 7e-14/fact, r'$\alpha_{\rm M} = -0.01$',
                         color='magenta', fontsize=24)
                plt.text(3e-4, 2.3e-13/fact, r'$\alpha_{\rm M} = -0.1$',
                         color='red', fontsize=24)
                plt.text(2e-7, 1.7e-12/fact, r'$\alpha_{\rm M} = -0.3$',
                         color='green', fontsize=24,
                         bbox=dict(boxstyle='round', pad=.3, facecolor='white',
                                   edgecolor='white', alpha=1))
                plt.text(1e-4, 1e-16/fact, 'GR', fontsize=30)

            else:
                plt.text(1.3e-4, 4e-14/fact, r'$\alpha_{\rm M} = 0.3$',
                color='orange', fontsize=24)
                plt.text(1e-5, 2e-13/fact, r'$\alpha_{\rm M} = 0.1$',
                     color='purple', fontsize=24)
                plt.text(8e-3, 1e-14/fact, 'GR', fontsize=30)
                plt.text(1.7e-5, 1e-15/fact, r'$\sim\!k^{1.5}$', fontsize=24)
                xx = np.logspace(-4.7, -3.4)
                plt.plot(xx, 9e-7*(xx/5e-5)**(1.5), lw=.8, color='black')
    
    lowk = False
    if ch == '0' or ch == 'III':
        lowk = True
        ks = np.array(spectra.get('k'))
        
        for i in range(0, len(runs_ng)):
            A = runs_ng[i]
            if neg and i < 4:
                SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                        read_values_spectra(spectra, A=A)
                plot_spectra(k, SA/fact, WKBA/fact, ksA, envA/fact, klimA,
                             kspc=kspcA, envlc=envcA/fact, S_p=True, lowk=lowk,
                             col=cols_g[i], WKB_p=True, lss=lss, v1=1e3)
            if not neg and i > 3:
                SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                        read_values_spectra(spectra, A=A)
                plot_spectra(k, SA/fact, WKBA/fact, ksA, envA/fact, klimA,
                             kspc=kspcA, envlc=envcA/fact, v1=1e3, S_p=True, lowk=True,
                             col=cols_g[i], WKB_p=True, lss=lss, v0=1e-22, nkk=30,
                             nkk2=30)

    if newf: plt.plot([], [], color='black', ls='dotted', label='WKB')
    plt.plot([], [], color='black', ls=lss, label='numerical (choice %s)'%ch)
    plt.legend(loc='lower right', framealpha=1, fontsize=24)
    
    if save:
        ngg = ''
        if not neg: ngg = '_posaM'
        fll = 'plots/spectra_envelope_choices_0_III' + ngg + '.pdf'
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')
        
def interpolate_lowk(kkc, ks, S, ksp, kspc, env):
        
    Sc = np.interp(kkc, ks, S)
    SA = np.interp(ksp, ks, S)
    envk = np.interp(kkc, kspc, env)
    
    return Sc, SA, envk
        
def plot_all_spectra_norm(spectrapos, spectraneg, ch='0', save=True, txt=True, newf=True,
                          ax=0, iax=0, lss='solid'):
    
    """
    Function that computes the spectra combining the 4 runs for all cases A to F
    for choices 0 and III.
    It uses the numerical spectra to obtain the envelope over oscillations
    at each wave number and compensates by the total growth in the GW
    energy density obtained (and verified) from the WKB approximation.
    It also returns the WKB estimated spectra at late times.
    
    It generates the plots corresponding to figure 6 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figure saved in 'plots/spectra_envelope_choices_0_III_norm.pdf'
    """
    
    if newf:
        
        fig, ax = plt.subplots(figsize=(8, 5))
        plt.loglog()
        plot_sets.axes_lines()
        plt.xlabel(r'$k$')
        #plt.title(r"$\xi^{\rm num} (k)$", pad=15)
        plt.ylabel(r"$\xi^{\rm num} (k)$", labelpad=10)
        plt.ylim(1e-1, 1e11)
        plt.xlim(1e-7, 4)
        plt.xticks(np.logspace(-6, 0, 4))
        plt.yticks(np.logspace(0, 10, 6))
        
        if txt:
            xx = np.logspace(-6, -4)
            plt.plot(xx, 1e-2*xx**(-2), color='black', lw=.8)
            plt.text(1e-5, 2e8, r'$\sim\!k^{-2}$', fontsize=24)
            xx = np.logspace(-6.5, -5)
            plt.plot(xx, .8*xx**(-1), color='black', lw=.8)
            plt.text(2e-7, 5e4, r'$\sim\!k^{-1}$', fontsize=24)
            xx = np.logspace(-6.5, -4)
            plt.plot(xx, 2*xx**(-.5), color='black', lw=.8)
            plt.text(3e-6, 2e3, r'$\sim\!k^{-{1\over 2}}$', fontsize=24)
        
        # inset
        from matplotlib.patches import Rectangle
        from mpl_toolkits.axes_grid1.inset_locator import inset_axes

        plt.gca().add_patch(Rectangle((5e-3, 5e-1),2-5e-3,1e1-5e-1,
                                edgecolor='black',
                                facecolor='none',
                                lw=4, alpha=.5))
        plt.gca().annotate("", xy=(.4, 7e3), xytext=(.3, 15),
                    arrowprops=dict(arrowstyle="->"))

        iax = inset_axes(ax, width="40%", height=2, loc=1)
        iax.loglog()
        plot_sets.axes_lines()
        iax.set_xlim(5e-3, 2)
        iax.set_ylim(5e-1, 1e1)
        iax.set_xticks([1])
        iax.set_yticks([1])
        
        if txt:
            
            inds1 = np.where(k<.21)
            inds2 = np.where(k[inds1]>.135)
            plt.plot(k[inds1][inds2], .15/k[inds1][inds2]**2, color='black', lw=.8)
            plt.text(.2, 5, r'$\sim\!k^{-2}$', fontsize=24)
    
    kkc = np.logspace(-7, -3, 100)
    
    if ch == '0' or ch == 'III':
        for i in range(0, len(runs_ng)):
            A = runs_ng[i]
            if i < 4: spectra = spectraneg
            else: spectra = spectrapos
            ks = np.array(spectra.get('k'))
            SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                    read_values_spectra(spectra, A=A)
            SAc, SAA, envkA = \
                    interpolate_lowk(kkc, ks, SA, ksA[1:], kspcA[1:],
                                     .5*envcA[1:])
        
            ax.plot(ksA[1:], .5*envA[1:]/SAA, color=cols_g[i], ls=lss)
            ax.plot(kkc, envkA/SAc, color=cols_g[i], ls=lss)
            iax.plot(ksA[1:], .5*envA[1:]/SAA, color=cols_g[i], ls=lss)
            iax.plot(kkc, envkA/SAc, color=cols_g[i], ls=lss)

    if save:
        fll = 'plots/spectra_envelope_choices_0_III_norm.pdf'
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')
        
    if newf:
        return ax, iax
    
def combine_runs(k1, k2, env1, env2, kdisc=100):
    
    """
    Function that appends two arrays of spectra and interpolates
    the results with kdisc points.
    It can be used to smooth the result from the slopes calculation.
    """
    
    inds = np.where(k1[1:] >= k2[-1])[0]
    kk = np.append(k2[1:], k1[1:][inds])
    envv = np.append(env2[1:], env1[1:][inds])
    
    kks = np.logspace(np.log10(kk[0]), np.log10(kk[-1]), kdisc)
    envvs = np.interp(kks, kk, envv)

    return kks, envvs
    
def plot_spectra_slopes(spectrapos, spectraneg, ch='0', txt=True, newf=True,
                        save=True, lss='solid', kdisc=100):
    
    """
    Function that plots the slopes of the spectra after averaging over
    oscillations (by using the envelope).
    
    It generates the plots corresponding to figure 6 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figure saved in 'plots/slopes_choices0_III.pdf'
    """
    
    if newf:
        plt.figure(1, figsize=(8, 5))
        plt.xscale('log')
        plt.ylim(-.6, 3.75)
        plt.xlim(1e-5, 4)
        plt.xticks(np.logspace(-6, 0, 7))
        plt.yticks([0, 1, 2, 3])
        plt.xlabel(r'$k$')
        #plt.title(r"$\beta \equiv - \frac{\partial  \log \xi^{\rm num} (k)}" + 
        #          r"{\partial \log k}$", pad=20)
        plt.ylabel(r"$\beta \equiv - \frac{\partial  \log \xi^{\rm num} (k)}" + 
                  r"{\partial \log k}$", labelpad=5)
        plot_sets.axes_lines()
        
        if txt:
            plt.hlines(0, 1e-6, 1e1, color='black', lw=.7)
            plt.hlines(2, 1e-6, 1e1, color='black', lw=.7)
    
    if ch == '0' or ch == 'III':
        for i in range(0, len(runs_ng)):
            A = runs_ng[i]
            if i < 4: spectra = spectraneg
            else: spectra = spectrapos
            ks = np.array(spectra.get('k'))
            SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                    read_values_spectra(spectra, A=A)
            #kks, envsA, slopesA = envelope_soles(ks, SA, ksA, kspcA, envA,
            #                                     envcA, col=cols_g[i], ls=lss)
            kks, envsA = combine_runs(ksA, kspcA, envA, envcA, kdisc=kdisc)
            Sks = np.interp(kks, ks, SA)
            slope = spec.slopes_loglog(kks, envsA/Sks)
            plt.plot(kks, -slope, color=cols_g[i], ls=lss)
            
            if newf:
                if alpsM0_g[i] == -0.5 or alpsM0_g[i] == 0.3:
                    slWKB = spec.slopes_loglog(ks, WKBA/SA)
                    plt.plot(ks, -slWKB, color=cols_g[i], ls='dotted')

    if newf: plt.plot([], [], color='black', ls='dotted', label='WKB (choice %s)'%ch)
    plt.plot([], [], color='black', ls=lss, label='numerical (choice %s)'%ch)
    plt.legend(frameon=False, loc='upper left', fontsize=18)

    if save:
        fll = 'plots/slopes_choices0_III.pdf'
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')
    
def plot_spectra_error_WKB(spectrapos, spectraneg, ch='0', err_fill=True,
                           save=True):
    
    """
    Function that computes the error in the spectrum from the WKB estimate
    compared with the resulting averaged saturated spectra obtained from
    the numerical simulations for choices 0 and III.
    
    It generates the plots corresponding to figure 7 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figure saved in 'plots/spectra_envelope_error_WKB_choice#ch.pdf'
    
    Arguments:
        spectrapos -- dictionary with numerical spectra for positive values
                      of alpha_M
        spectraneg -- id for negative values of alpha_M
        ch -- choice of alpha_M parameterization
        err_fill -- option to fill between -15 to 15% error
    """
    
    plt.figure(figsize=(8, 5))
    kkc = np.logspace(-7, -3, 1000)
    kkc2 = np.logspace(-3, 1, 1000)
    plt.xscale('log')
    plt.xlim(1e-7, 1e1)
    plt.ylim(-1.1, .5)
    plt.xticks(np.logspace(-7, 1, 9))
    plt.yticks(np.linspace(-1, .5, 7))
    plt.xlabel(r'$k$')
    plt.ylabel(r"$\varepsilon^{\rm WKB} (S_{h'})$")
    plt.title(r'$\alpha_{\rm M}$ choice %s'%ch, pad=15)
    plot_sets.axes_lines()
    
    if err_fill:
        plt.hlines(.15, 1e-7, 1e1, color='black', ls='dashed')
        plt.hlines(-.15, 1e-7, 1e1, color='black', ls='dashed')
        xx = np.logspace(-7, 1)
        plt.fill_between(xx, xx**0*-.15, xx**0*.15, alpha=.2, color='black')
    
    if ch == '0' or ch == 'III':
        for i in range(0, len(runs_ng)):
            A = runs_ng[i]
            if i < 4: spectra = spectraneg
            else: spectra = spectrapos
            ks = np.array(spectra.get('k'))
            SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                    read_values_spectra(spectra, A=A)
            WKBAA = np.interp(ksA, ks, WKBA)
            WKBAAc = np.interp(kspcA, ks, WKBA)
            err_relA = 2*((WKBAA[1:] - .5*envA[1:])/envA[1:])
            err_relAc = 2*((WKBAAc[1:] - .5*envcA[1:])/envcA[1:])
            plt.plot(kkc, np.interp(kkc, kspcA[1:], err_relAc),
                     '.', color=cols_g[i])
            plt.plot(kkc2, np.interp(kkc2, ksA[1:], err_relA),
                     '.', color=cols_g[i])
            plt.vlines(klimA, -1e1, 1e1, color=cols_g[i], lw=.8)

    if save:
        fll = 'plots/spectra_envelope_error_WKB_choice%s.pdf'%ch
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')
        
def plot_present_time(k, EGW, g=gref, T=Tref, h0=h0_ref, col='blue',
                      cut=True, kc=5, plot=True, ret=False):
    
    if cut: indk_cut = np.where(k < kc)[0]
    else: indk_cut = np.where(k < 1e10)[0]
    f, OmGW = cosmoGW.shift_OmGW_today(k[indk_cut], EGW[indk_cut]*k[indk_cut]/6,
                                       g=g, T=T, h0=h0)
    if plot: plt.plot(f, OmGW, color=col)
    if ret: return OmGW
    
def compute_spectra_OmGW(kk, kGW=10, EEGW=1.):#, q2=10):
    
    # get spectral peak and recompute such that the final peak is at kss
    # and integrated value is EEGW
    S_kk_ref = an.smoothed_dbpl(kk, A=1, kb=1, ks=kGW, a=2, b=0, c=11/3, alpha1=2, alpha2=2)
    ind_max = np.argmax(S_kk_ref*kk)
    kp_ks = kk[ind_max]/kGW
    S_kk_ref = an.smoothed_dbpl(kk, A=1, kb=1, ks=kGW/kp_ks, a=2, b=0, c=11/3, alpha1=2, alpha2=2)
    A = 6*EEGW/np.trapz(S_kk_ref, kk)
    S_kk_ref = an.smoothed_dbpl(kk, A=A, kb=1, ks=kGW/kp_ks, a=2, b=0, c=11/3, alpha1=2, alpha2=2)

    return A, kGW/kp_ks, S_kk_ref
        
def plot_OmegaGW_mod_today(spectrapos, spectraneg, DDs, ch='0', EEGW_st=1, newf=True,
                           dets=True, kGWp=10, T=Tref, g=gref, kc=5, kdisc=1000,
                           fact=3.5e-10, epoch='EWPT', txt=True, save=True, ax=0, iax=0):
    
    """
    Function that generates the plot of the present-time GW spectra obtained for different
    values of alpM0 for a given choice of alphaM parameterization (choice 0 or III are
    available).
    
    It plots the spectra from the numerical simulations assuming the signal has been
    generated at a specific epoch within RD, determined by T and g.
    
    It generates the plots corresponding to figure 8 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/OmGW_detectorsEWPT.pdf' and 'plots/OmGW_detectorsQCDT.pdf'
    
    Arguments:
    
        spectrapos -- 
        spectraneg -- 
        DDs -- array of damping factor as a function of time for different values of alpM
        ch -- choice of alpM parameterization (default 0)
        EEGW_st -- integrated GW energy density normalized by the radiation energy density
                    (default is 1)
        newf -- option for first time to call the function for a specific plot
        dets -- option to plot detector sensitivites (available are LISA, SKA, DECIGO, BBO, PTA, ET)
        kGWp -- value of the peak of the GW spectrum given as a fraction of the Hubble scale
                at the time of generation (default is 10)
        T -- temperature scale at the time of generation
        g -- relativistic dofs at the time of generation
        kc -- wave number at which the numerical results are cut
        kdisc -- number of k discretizations to be used in the resulting arrays from combining
                 two runs with different size of the domain (default 1000 between 1e-7 and 1e-3)
        fact -- numerical spectral amplitude used to normalize the results
        epoch -- choice of epoch of generation (options are 'EWPT' and 'QCDPT')
    """
    
    if newf:
        
        fig, ax = plt.subplots(1, figsize=(8, 5))
        plt.loglog()
        plot_sets.axes_lines()
        plt.xlim(1e-10, 1e1)
        plt.ylim(1e-19, 1e-5)
        plt.xticks(np.logspace(-10, 0, 6))
        plt.yticks(np.logspace(-18, -6, 7))
        plt.xlabel(r'$f$ [Hz]')
        plt.ylabel(r'$h^2 \, \Omega_{\rm GW} (f)$')
        
        if txt and epoch=='EWPT':
            xx = np.logspace(-6.5, -5.5)
            plt.plot(xx, 1e-20*(xx/1e-7)**3, color='black', lw=.8)
            xx = np.logspace(-5, -3.5)
            plt.plot(xx, 2e-14*(xx/1e-4), color='black', lw=.8)
            xx = np.logspace(-1.5, .1)
            plt.plot(xx, 2.5e-18*xx**(-8/3), color='black', lw=.8)
            plt.text(1.5e-6, 1e-17, r'$\sim\!f^3$', fontsize=20)
            plt.text(4e-5, 2e-15, r'$\sim\!f$', fontsize=20)
            plt.text(4e-1, 3e-17, r'$\sim\!f^{-{8\over3}}$', fontsize=18)
            plt.text(5e-7, 3e-12, r'$h^2 e^{2{\cal D}} \, \Omega_{\rm GW} (f)$', fontsize=16)
        
        if dets:
            ### read GW detectors sensitivities and plot
            os.chdir(HOME)
            fs, LISA_Om, LISA_OmPLS = inte.read_sens(SNR=10, T=4, interf='LISA', Xi=False)
            fSKA, OmSKA = inte.read_detector_PLIS_Schmitz(det='SKA', SNR=10, T=4)
            fBBO, OmBBO = inte.read_detector_PLIS_Schmitz(det='BBO', SNR=10, T=4)
            fDECIGO, OmDECIGO = inte.read_detector_PLIS_Schmitz(det='DECIGO', SNR=10, T=4)
            fET, OmET = inte.read_detector_PLIS_Schmitz(det='ET', SNR=10, T=4)
            os.chdir(dir0)
            plt.plot(fs, LISA_OmPLS, alpha=.7, color='grey', lw=2)
            plt.plot(fSKA, OmSKA, alpha=.7, color='grey', lw=2)
            plt.plot(fBBO, OmBBO, alpha=.7, color='grey', lw=2)
            plt.plot(fDECIGO, OmDECIGO, alpha=.7, color='grey', lw=2)
            plt.plot(fET, OmET, alpha=.7, color='grey', lw=2)

            # plot PTA data from observations
            betas = np.linspace(1, 5, 100)
            pta.plot_PTA_all(ff='Om', betas=betas, lines=False, alp_bl=.1, alp_E=.1, alp_g=0,
                             alp_I=.1, alp_P=.1, ret=False, plot=True)
            if txt:
                if epoch == 'QCDPT':
                    plt.text(1.5e-8, 1e-13, 'SKA', fontsize=22, color='gray')
                    plt.text(2e-6, 1e-9, 'LISA', fontsize=22, color='gray')
                    plt.text(2e-9, 1e-7, 'PTA', fontsize=22, color='gray')
                    
                else:
                    plt.text(5e-6, 1e-10, 'LISA', fontsize=22, color='gray')
                    plt.text(1.5e-7, 1e-8, 'SKA', fontsize=22, color='gray')
                    plt.text(3e-2, 5e-14, 'DECIGO', fontsize=16, color='gray')
                    plt.text(3e-3, 2e-17, 'BBO', fontsize=22, color='gray')
                    plt.text(3e-1, 1e-9, 'ET', fontsize=22, color='gray')
                    plt.text(5e-10, 1e-8, 'PTA', fontsize=22, color='gray')
        
        if epoch == 'QCDPT':
            plt.ylim(1e-18, 1e-4)
            plt.xlim(1e-14, 1e-4)
            plt.yticks(np.logspace(-18, -4, 8))
            plt.xticks(np.logspace(-14, -4, 6))
            plt.text(1e-13, 1e-13, r'$h^2 e^{2{\cal D}} \, \Omega_{\rm GW} (f)$', fontsize=16)

            from matplotlib.patches import Rectangle
            plt.gca().add_patch(Rectangle((5e-10,1e-12),5e-9-5e-10,5e-9-1e-12,
                                edgecolor='black',
                                facecolor='none',
                                lw=4, alpha=.5))

            ax.annotate("", xy=(3e-10, 3e-7), xytext=(1e-9, 1e-8),
                        arrowprops=dict(arrowstyle="->"))

            from mpl_toolkits.axes_grid1.inset_locator import inset_axes
            iax = inset_axes(ax, width="40%", height=1.75, loc=2)
            plot_sets.axes_lines(ax=iax)
            iax.loglog()
            plt.xlim(5e-10, 5e-9)
            plt.ylim(1e-12, 5e-9)
            plt.yticks([])
            iax.set_xticks([])
            iax.set_xticks([], minor=True)
            for i in iax.get_xticklabels() + iax.get_yticklabels():
                i.set_fontsize(14)
            if dets:
                pta.plot_PTA_all(ff='Om', betas=betas, lines=False, alp_bl=.4, alp_E=.2, alp_g=0,
                                 alp_I=.3, alp_P=.2, ret=False, plot=True)
                if txt:
                    plt.text(2e-9, 1.5e-11, 'PTA', fontsize=22, color='gray')
                    
    ## generate analytical spectrum using double power law
    ## A_sp and kGW_sp are the parameters used in the model to get
    ## a resulting spectra with integrated value EEGW_st and that
    ## peaks at kGWp
    kk = np.logspace(-4, 8, 50000)
    A_sp, kGW_sp, Skk = compute_spectra_OmGW(kk, kGW=kGWp, EEGW=EEGW_st)

    ## cut the numerical results at k = 5
    if ch == '0' or ch == 'III':
        for i in range(0, len(runs_ng)):
            A = runs_ng[i]
            if i < 4: spectra = spectraneg
            else: spectra = spectrapos
            ks = np.array(spectra.get('k'))
            SA, WKBA, ksA, envA, klimA, kspcA, envcA = \
                    read_values_spectra(spectra, A=A)
            kks, envvs = combine_runs(ksA, kspcA, envA, envcA, kdisc=kdisc)
            plt.sca(ax)
            plot_present_time(kks, .5*envvs*A_sp/fact, g=g, T=T, h0=1.,
                              col=cols_g[i], kc=kc, cut=True, plot=True,
                              ret=False)
            if i == 0:
                OmGW_GR = plot_present_time(kk, Skk, g=g, T=T, h0=1., col='black',
                                            cut=False, plot=True, ret=True)
            if epoch=='QCDPT':
                plt.sca(iax)
                plot_present_time(kks, .5*envvs*A_sp/fact, g=g, T=T, h0=1.,
                                  col=cols_g[i], kc=kc, cut=True, plot=True,
                                  ret=False)
                if i == 0:
                    OmGW_GR = plot_present_time(kk, Skk, g=g, T=T, h0=1., col='black',
                                                cut=False, plot=True, ret=True)
                plt.sca(ax)
    
    if save:
        fll = 'plots/OmGW_detectors' + epoch + '.pdf'
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')
        
    if newf: return ax, iax
    
def plot_amplification_damping(Q, Q_QCD, alpsM0, txt=True, save=True):
    
    """
    Function that plots the amplification (damping) for the 4 different choices
    of alpM parameterization from the time of generation until present time
    given the temperature scale within the RD at which the signal was generated.
    
    It considers the EWPT and the QCDPT as the initial times of generation.
    
    It generates the plots corresponding to figure 9 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/OmGW_detectorsEWPT.pdf' and 'plots/OmGW_amplification.pdf'
    
    Arguments:
        Q -- array of reference amplifications for alpM0 for the 4 choices
             produced at the EWPT
        Q_QCD -- array of reference amplifications for alpM0 for the 4 choices
                 produced at the QCDPT
        alpsM0 -- array of values of alpM at present time
        
    """
    
    fig, ax = plt.subplots(figsize=(8, 5))
    plt.yscale('log')
    plt.ylim(1e-9, 1e9)
    plt.yticks(np.logspace(-8, 8, 9))
    plt.xlim(.55, -.55)
    plt.xlabel(r'$\alpha_{{\rm M}, 0}$')
    plt.ylabel(r'$e^{-2 {\cal D}} (\eta_0)$')
    plot_sets.axes_lines()

    if txt:
        plt.hlines(1, -1, 1, color='black', lw=.8)
        plt.text(-.22, 3e5, 'EW', color='blue')
        plt.text(-.4, 1e3, 'QCD', color='green')
        plt.text(-.18, 3.e-2, r'$|\alpha_{{\rm M}, 0}|$')

    plt.plot([], [], color='black', label='choice 0')
    plt.plot([], [], color='black', ls='dashed', label='choice III')
    plt.plot([], [], color='black', ls='dotted', label='choices I and II')
    plt.legend(frameon=False, fontsize=24)

    lss = np.array(['solid', 'dotted', 'dotted', 'dashed'])
    for i in range(0, 4):
        plt.plot(alpsM0, Q[i]**alpsM0, color='blue', ls=lss[i])
        plt.plot(alpsM0, Q_QCD[i]**alpsM0, color='green', ls=lss[i])

    from matplotlib.patches import Rectangle

    from mpl_toolkits.axes_grid1.inset_locator import inset_axes
    iax = inset_axes(ax, width="50%", height=1.2, loc=4)
    iax.loglog()
    plt.ylim(1e-2, 1e2)
    plt.yticks(np.logspace(-2, 2, 5))
    plt.xlim(5e-3, 2e-1)
    iax.xaxis.tick_top()
    for i in iax.get_xticklabels() + iax.get_yticklabels():
        i.set_fontsize(16)
    iax.set_xticks(np.logspace(-2, -1, 2))
    iax.set_yticks(np.logspace(-2, 2, 5))
    plot_sets.axes_lines()
    
    if txt:
        plt.hlines(1, -1, 1, color='black', lw=.8)
    
    for i in range(0, 4):
        plt.plot(abs(alpsM0), Q[i]**alpsM0, color='blue', ls=lss[i])
        plt.plot(abs(alpsM0), Q_QCD[i]**alpsM0, color='green', ls=lss[i])

    if save:
        fll = 'plots/OmGW_amplification.pdf'
        print('Saving figure in %s'%fll)
        plt.savefig(fll, bbox_inches='tight')