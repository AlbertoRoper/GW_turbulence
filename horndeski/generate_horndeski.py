"""
generate_horndeski.py is a Python routine  that can be used to generate
the plots and compute the postprocessing results of Y. He, A. Roper Pol,
A. Brandenburg, "Modified propagation of gravitational waves from the early
radiation era," submitted to JCAP (2022).

It reads the pickle run variables that can be generated by the routine
initialize_horndeski.py.

The function run() executes the code.

Author: Alberto Roper Pol
created: 01/12/2022
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
import pandas as pd

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'

# import GW_turbulence routines that are relevant for the project
os.chdir(HOME)
from dirs import read_dirs as rd
import plot_sets
import run as r
import interferometry as inte
import cosmoGW
import spectra as spec
import GW_analytical as an
import horndeski as ho
import cosmology as co
import pta
os.chdir(dir0)

# variables that are used globally
alpsM0_g = np.array([-0.5, -0.3, -0.1, -0.01, 0.1, 0.3])
cols_g = np.array(['blue', 'green', 'red', 'magenta', 'purple', 'orange'])
runs_ng = np.array(['A', 'B', 'C', 'D', 'E', 'F'])
alpsM02_g = np.array([-0.5, -0.3, -0.1,0.1, 0.3])
cols2_g = np.array(['blue', 'green', 'red', 'purple', 'orange'])
runs_n2g = np.array(['A', 'B', 'C', 'D', 'E'])
k = np.logspace(-7, 3, 2000)

# reference values and constants
Tref = 100*u.GeV
h0_ref = 0.6372
  
def read_cosmology_results():
    
    """
    Function that reads the cosmology results from the Friedmann solver
    that have already been computed using the routines under the project
    directory cosmology.
    """
    
    #### Read the results from the Friedmann solution
    os.chdir(HOME)
    fl = 'cosmology/friedmann/a_vs_eta.dat'
    df = pd.read_csv(fl, skiprows=1, header=None, names=['eta', 'a', 'HH', 'app_a', 'd'], delimiter=' ')
    a = np.array(df['a'])
    eta = np.array(df['eta'])
    ap_a = np.array(df['HH'])
    app_a = np.array(df['app_a'])
    os.chdir(dir0)
    
    return a, eta, ap_a, app_a
  
def cosmology_normalized_vars(a, eta, ap_a, app_a, T=Tref, h0=h0_ref):
    
    """
    Function that computes the normalized variables in terms of the solutions to
    the Friedmann solver for a specific temperature scale.
    
    Arguments:
        a -- scale factor
        eta -- conformal time
        ap_a -- conformal Hubble rate HH = a'/a
        app_a -- conformal acceleration a''/a
        T -- temperature scale (default is 100 GeV, EWPT)
        h0 -- Hubble rate at present time (default is CMB observation 67.32 km/s/Mpc)
        
    Returns:
        a_n -- normalized scale factor a/a_*
        eta_n -- normalized conformal time eta/eta_*
        HH_n -- normalized conformal Hubble rate HH/HH_*
        app_a_n -- normalized conformal acceleration (a''/a)/HH_*^2
        Omega -- ratio of energy density to critical energy at present time
        w -- equation of state
        eta_n_0 -- normalized conformal present time eta_0/eta_*
        aEQ_n -- normalized scale factor at equipartition aEQ/a_*
        aL_n -- id at dark-energy domination
        a_acc_n -- id at beginning of accelerated universe
        eta_n_EQ -- normalized conformal time at equipartition eta_EQ/eta_*
        eta_n_L -- id at dark-energy domination
        eta_n_acc -- id at beginning of accelerated universe
    """

    os.chdir(HOME)
    # choice of the initial time and computation of scale factor and Hubble rate
    g = co.thermal_g(T=T, s=0)
    ast = co.as_a0_rat(T=T, g=g)
    Hs = co.Hs_val(T=T, g=g)

    # computation of normalized variables
    a_n, eta_n, HH_n, app_a_n, Omega, w, eta_n_0, aEQ_n, \
        aL_n, a_acc_n, eta_n_EQ, eta_n_L, eta_n_acc = \
            co.normalized_variables(a, eta, ap_a, app_a, T=T, h0=h0)
    
    os.chdir(dir0)
    
    return a_n, eta_n, HH_n, app_a_n, Omega, w, eta_n_0, aEQ_n, \
           aL_n, a_acc_n, eta_n_EQ, eta_n_L, eta_n_acc
  
def plot_parameterizations_alpM(eta_n, a, Omega, Om_mat, HH_n, eta_n_EQ, eta_n_L, eta_n_0, OmM0,
                                comp_exp=1, compp=1, nn_exp=1, save=True, primes=False,
                                n2=False, n04=False, n1=True, figg=1):
    
    """
    Function that plots the cosmological time evolution of the alphaM parameterizations.
    
    It generates the plots corresponding to figure 1 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/alphaM_params_EWPT.pdf' and 'plots/params_WKB_lims_EWPT.pdf'
    """
    
    ### parameterizations
    alpM_0, alpM_prime_0 = ho.parameterizations_alpM(eta_n, choice='0')
    alpM_I_2, alpM_prime_I_2 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=2)
    alpM_I, alpM_prime_I = ho.parameterizations_alpM(eta_n, a=a, choice='I')
    alpM_I_04, alpM_prime_I_04 = ho.parameterizations_alpM(eta_n, a=a, choice='I', n=0.4)
    alpM_II, alpM_prime_II = ho.parameterizations_alpM(eta_n, a=a, choice='II', Omega=Omega)
    alpM_III, alpM_prime_III = ho.parameterizations_alpM(eta_n, choice='III', OmM0=OmM0,
                                                         Omega_mat=Om_mat, Omega=Omega)
    
    if figg == 1:
        primes = False
        ins = True
    else:
        primes = True
        ins = False
        comp_exp = 2
        compp = 1/2
        nn_exp = 1/2
        alpM_0 = alpM_0*(1+.5*alpM_0)
        alpM_I = alpM_I*(1+.5*alpM_I)
        alpM_I_2 = alpM_I_2*(1+.5*alpM_I_2)
        alpM_I_04 = alpM_I_04*(1+.5*alpM_I_04)
        alpM_II = alpM_II*(1+.5*alpM_II)
        alpM_III = alpM_III*(1+.5*alpM_III)

    fig, ax = plt.subplots(figsize=(8, 5))

    comp = compp*HH_n**comp_exp

    if primes:
        if n1:
            plt.plot(eta_n, (comp*abs(alpM_prime_I))**nn_exp,
                 color='purple', ls='dashed',  lw=2)
        if n2:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_2))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        if n04:
            plt.plot(eta_n, (comp*abs(alpM_prime_I_04))**nn_exp,
                     color='purple', ls='dashed',  lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_II))**nn_exp,
                     color='red', ls='dashed',   lw=2)
        plt.plot(eta_n, (comp*abs(alpM_prime_III))**nn_exp,
                 color='cyan', ls='dashed',   lw=2)
      
    plt.plot(eta_n, (alpM_0*comp)**nn_exp, lw=2, color='darkblue')
    if n1:
        plt.plot(eta_n, (alpM_I*comp)**nn_exp, color='purple',  lw=2)
    if n2:
        plt.plot(eta_n, (alpM_I_2*comp)**nn_exp, color='purple',  lw=2)
    if n04:
        plt.plot(eta_n, (alpM_I_04*comp)**nn_exp, color='purple',  lw=2)
    plt.plot(eta_n, (alpM_II*comp)**nn_exp, lw=2,  color='red')
    plt.plot(eta_n, (alpM_III*comp)**nn_exp,  lw=2,  color='cyan')
    
    plt.loglog()
    plt.xlim(1, eta_n_0)
    if figg == 1:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 1e-14, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-34, 'II', color='red')
        plt.ylim(1e-60, 1e1)
        plt.text(1e10, 1e-6, 'RD', color='black')
        plt.text(3e11, 1e-6, 'MD', color='black')
        plt.title(r'$\Bigl(\alpha_{\rm M}/\alpha_{{\rm M}, 0}\Bigr) \, {\cal H}$',
                  pad = 15)
    else:
        plt.text(1e12, 1e-11, '0', color='darkblue')
        plt.text(1e10, 3e-15, 'I', color='purple')
        plt.text(1e7, 1e-6, 'III', color='cyan')
        plt.text(1e6, 1e-21, 'II', color='red')
        plt.plot([], [], color='black',
                 label=r"$k_{{\rm lim}, \alpha_{\rm M}} \, c_{\rm T}" + \
                       r" \, \alpha_{{\rm M}, 0}^{-{1\over2}}$")
        plt.plot([], [], ls='dashed', color='black',
                 label=r"$k_{{\rm lim}, \alpha'_{\rm M}} \, c_{\rm T}" + \
                       r" \, {\alpha_{{\rm M}, 0}^{-{1\over2}}}$")
        plt.legend(fontsize=16, framealpha=1, edgecolor='white')
        plt.ylim(1e-28, 2)
        plt.text(1e10, 1e-26, 'RD', color='black')
        plt.text(1e12, 1e-26, 'MD', color='black')

    plt.xlabel(r'$\eta/\eta_*$')

    plt.vlines(eta_n_EQ, 1e-70, 1e3, color='black')
    plt.vlines(eta_n_L, 1e-70, 1e3, color='black')

    inds = np.where(eta_n < eta_n_EQ)
    inds2 = np.where(eta_n > eta_n_EQ)
    inds3 = np.where(eta_n[inds2] < eta_n_L)
    inds4 = np.where(eta_n[inds2] > eta_n_L)
    plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
    plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                     eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
    plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                     eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)

    plot_sets.axes_lines()

    if ins:
        from mpl_toolkits.axes_grid1.inset_locator import inset_axes
        iax = inset_axes(ax, width="40%", height=1.4, loc=4)
        iax.xaxis.tick_top()
        plt.plot(eta_n, (alpM_I*comp*(1+.5*alpM_I))**nn_exp, color='purple',  lw=2)
        plt.plot(eta_n, (alpM_III*comp*(1+.5*alpM_III))**nn_exp,  lw=2,  color='cyan')
        plt.plot(eta_n, (alpM_0*comp*(1+.5*alpM_0))**nn_exp, lw=2,  color='darkblue')
        plt.plot(eta_n, (alpM_II*comp*(1+.5*alpM_II))**nn_exp, lw=2,  color='red')
        plt.loglog()
        plt.xlim(1e11, eta_n_0)
        plt.ylim(1e-24, 1e-9)
        inds = np.where(eta_n < eta_n_EQ)
        inds2 = np.where(eta_n > eta_n_EQ)
        inds3 = np.where(eta_n[inds2] < eta_n_L)
        inds4 = np.where(eta_n[inds2] > eta_n_L)
        plt.fill_between(eta_n[inds], eta_n[inds]**0*1e-70, eta_n[inds]**0*1e5, color='orange', alpha=.5)
        plt.fill_between(eta_n[inds2][inds3], eta_n[inds2][inds3]**0*1e-70,
                         eta_n[inds2][inds3]**0*1e5, color='navy', alpha=.5)
        plt.fill_between(eta_n[inds2][inds4], eta_n[inds2][inds4]**0*1e-70,
                         eta_n[inds2][inds4]**0*1e5, color='grey', alpha=.5)
        for i in iax.get_xticklabels() + iax.get_yticklabels():
            i.set_fontsize(16)
        plt.xticks([1e12, 1e13])
        plot_sets.axes_lines()
        plt.text(8.5e12, 1e-20, r'$\Lambda$D')

    if save:
        if figg == 1: lsave = 'alphaM_params_EWPT'
        else: lsave = 'params_WKB_lims_EWPT'
        plt.savefig('plots/' + lsave + '.pdf',
                    bbox_inches='tight')
        
def plot_late_time_WKB(save=True):
    
    """
    Function that plots the spectra obtained using the WKB approximation
    in modified gravity for an initial GW background following a smoothed
    double broken power law.
    
    It generates the plots corresponding to figure 2 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP
    (2022).
    
    Figures saved in 'plots/spectrum_WKB_late_times.pdf', 'plots/spectrum_WKB_normalized.pdf'
    """
    
    alpsM0 = np.array([-0.5, -0.3, -0.1, -0.01, 0.5, 0.3, 0.1, 0.01])
    cols = np.array(['blue', 'green', 'red', 'magenta']*2)
    TT_lt_ct = np.zeros((len(k), len(alpsM0)))
    for i in range(0, len(alpsM0)):
        TT_lt_ct[:, i] = ho.WKB_envelope_late_times_const(k, alpT=0, alpM0=alpsM0[i])
        
    S = an.smoothed_dbpl(k, A=1, kb=1, ks=10, a=2, b=0, c=11/3, alpha1=2, alpha2=2)
    
    from matplotlib.patches import Rectangle

    fig, ax = plt.subplots(figsize=(8, 5))
    plt.plot(k, S, color='black', lw=3)
    plot_sets.axes_lines()
    plt.loglog()
    plt.xlim(1e-5, 2e1)
    plt.ylim(7e-7, 1e1)
    plt.xticks(np.logspace(-5, 1, 7))
    plt.yticks(np.logspace(-6, 1, 8))
    plt.xlabel(r'$k$')
    plt.title(r"$e^{2 {\cal D}} \, S_{h'}^{\rm WKB} (k)/S_{h'}^*$", pad=15)

    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, S*TT_lt_ct[:, i], color=cols[i], ls=ls)

    plt.text(2e-5, 4e-5, r'$\alpha_{{\rm M}, 0} = \pm 0.01$',
             color='magenta', fontsize=26)
    plt.text(2e-5, 4e-4, r'$\alpha_{{\rm M}, 0} = \pm 0.1$',
             color='red', fontsize=26)
    plt.text(2e-5, 4e-3, r'$\alpha_{{\rm M}, 0} = \pm 0.3$',
             color='green', fontsize=26)
    plt.text(2e-5, 8e-2, r'$\alpha_{{\rm M}, 0} = \pm 0.5$',
             color='blue', fontsize=26)

    for i in range(0, 4):
        plt.vlines(np.sqrt(abs(alpsM0[i])/2*(1 + .5*alpsM0[i])), 1e-7,
                   1e2, color=cols[i], lw=.8)

    plt.gca().add_patch(Rectangle((0.7,1),9.3,.6,
                        edgecolor='black',
                        facecolor='none',
                        lw=4, alpha=.5))

    ax.annotate("", xy=(3, .8), xytext=(1, 2.5e-3),
                arrowprops=dict(arrowstyle="->"))

    from mpl_toolkits.axes_grid1.inset_locator import inset_axes
    iax = inset_axes(ax, width="35%", height=1.6, loc=4)
    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, S*TT_lt_ct[:, i], color=cols[i], ls=ls)
    plt.plot(k, S, color='black')
    plt.loglog()
    plt.xlim(7e-1, 1e1)
    plt.ylim(1, 2)
    iax.set_yticks([])
    iax.get_yaxis().set_visible(False)
    plt.xticks([])
    plt.yticks([])
    xx = np.logspace(.3, .8)
    plt.plot(xx, 1.75*xx**(-0.06), color='black', lw=.8)
    xx = np.logspace(.35, .75)
    plt.plot(xx, 1.12*xx**(.08), color='black', lw=.8)
    plt.text(3, 1.7, r'$k^{-0.06}$')
    plt.text(3, 1.1, r'$k^{0.08}$')
    
    if save:
        plt.savefig('plots/spectrum_WKB_late_times.pdf',
                    bbox_inches='tight')

    plt.figure(figsize=(8, 5))
    plt.plot(k, k**0, color='black', lw=3)
    plot_sets.axes_lines()
    plt.loglog()
    plt.xlim(1e-2, 2e1)
    plt.ylim(3e-1, 1e1)
    plt.xlabel(r'$k$')

    for i in range(0, len(alpsM0)):
        ls = 'solid'
        if alpsM0[i] < 0: ls = 'dashed'
        plt.plot(k, TT_lt_ct[:, i], color=cols[i], ls=ls)

    for i in range(0, 4):
        plt.vlines(np.sqrt(abs(alpsM0[i])/2*(1 + .5*alpsM0[i])), 1e-7, 1e2, color=cols[i],
                   lw=.8)
    plt.title(r"$\xi^{\rm WKB} (k)$", pad=15)
    
    if save:
        plt.savefig('plots/spectrum_WKB_normalized.pdf',
                    bbox_inches='tight')

def time_evolution_WKB(eta_nn, HH_nn, a_nn, ast, Omega_nn,
                       OmM0, Omega_mat_nn, read=True,
                       save=True):

    """
    Function that computes the D = .5 int alpM HH d \eta integral
    for the different choices of alphaM parameterization that appears
    in the WKB approximation for the increase in GW energy density.
    
    Reference: Y. He, A. Roper Pol, A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    If read is False, it computes D and stores it as a pickle variable in
    'WKB/DDs.pkl', otherwise it directly reads it.
    """
    
    alpsM0 = alpsM0_g
    
    if read:
        import pickle
        with open('WKB/DDs.pkl', 'rb') as f:
            DDs = pickle.load(f)
        DDs_0 = DDs.get('0')
        DDs_I = DDs.get('I')
        DDs_I_n2 = DDs.get('I_n2')
        DDs_I_n04 = DDs.get('I_n04')
        DDs_II = DDs.get('II')
        DDs_III = DDs.get('III')
        
    else:
        NN = len(alpsM0)
        DDs_0 = np.zeros((len(eta_nn), NN))
        DDs_I = np.zeros((len(eta_nn), NN))
        DDs_I_n04 = np.zeros((len(eta_nn), NN))
        DDs_I_n2 = np.zeros((len(eta_nn), NN))
        DDs_II = np.zeros((len(eta_nn), NN))
        DDs_III = np.zeros((len(eta_nn), NN))

        for i in range(0, len(alpsM0)):
            alpM0 = alpsM0[i]
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='0')
            DDs_0[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=2)
            DDs_I_n2[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=0.4)
            DDs_I_n04[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='I', a=a_nn*ast, n=1)
            DDs_I[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='II', Omega=Omega_nn)
            DDs_II[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)
            alpM, _ = ho.parameterizations_alpM(eta_nn, alpM0=alpM0, choice='III', OmM0=OmM0,
                                                Omega=Omega_nn, Omega_mat=Omega_mat_nn)
            DDs_III[:, i] = ho.damping_fact(eta_nn, alpM, HH_nn)

        if save:
            import pickle
            DDs = {'0' : DDs_0, 'I' : DDs_I, 'I_n2' : DDs_I_n2, 'I_n04' : DDs_I_n04,
                   'II' : DDs_II, 'III' : DDs_III, 'alpsM' : alpsM0, 'eta' : eta_nn}
            with open('WKB/DDs.pkl', 'wb') as f:
                pickle.dump(DDs, f)
        
    return DDs_0, DDs_I, DDs_I_n04, DDs_I_n2, DDs_II, DDs_III
  
def run(rsd='all', dirs={}):
    
    """
    Function that loads the pickle variables of the runs after they have
    been read by the initialize_horndeski.py routine.
    """

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = {}
    if rsd == 'all': dirs = rd('horndeski', dirs={})
    if rsd == 'M0': dirs = rd('horndeski_M0', dirs={})
    if rsd == 'M1': dirs = rd('horndeski_M1', dirs={})
    if rsd == 'M2': dirs = rd('horndeski_M2', dirs={})
    if rsd == 'M3': dirs = rd('horndeski_M3', dirs={})
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)
    os.chdir(dir0)

    return runs
  
def plot_time_evolution_EGW(runs, DDs, eta_nn, DDs2=0, value0=False,
                            choice='0', txt=True, save=True):
    
    """
    Function that plots the time evolution of the GW energy density from
    the numerical simulations and using the WKB approximation in modified
    gravity.
    
    It generates the plots corresponding to figure 3 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Modified propagation of
    gravitational waves from the early radiation era," submitted to JCAP (2022).
    
    Figures saved in 'plots/time_series_EEGW_choice'#'.pdf'
    """
        
    fig, ax = plt.subplots(figsize=(12, 8))
    plot_sets.axes_lines()
    
    p = '0'
    if choice == '0' or choice == 'III':
        runsA = runs_ng
        alpsM0 = alpsM0_g
        cols = cols_g
        if choice == 'III': p = '3'
    if choice == 'I' or choice == 'II':
        if choice == 'I': p = '1'
        if choice == 'II': p = '2'
        runsA = runs_n2g
        alpsM0 = alpsM02_g
        cols = cols2_g
        from mpl_toolkits.axes_grid1.inset_locator import inset_axes
        iax = inset_axes(ax, width="90%", height=2.5, loc=4)
        plot_sets.axes_lines()
        
    rrs = ['M' + p + i for i in runsA]
    rrs_b = ['M' + p + i + '_LD2' for i in runsA]
        
    for i in range(0, len(rrs)):
        alpM0 = alpsM0[i]
        MM = runs.get(rrs[i])
        sp = MM.spectra
        ts = MM.ts
        ksp, GWs, GWs0, tsp, tts, EEGW, A = spec_tts(sp, ts)
        MMb = runs.get(rrs_b[i])
        spb = MMb.spectra
        tsb = MMb.ts
        kspb, GWsb, GWs0b, tspb, ttsb, EEGWb, Ab = spec_tts(spb, tsb)
        WKB = np.exp(-2*DDs[:, i])
        if choice == 'I' or choice == 'II':
            if choice == 'I':
                if alpM0 < 0.1: DD = DDs[:, i]
                if alpM0 > 0: DD = DDs2[:, i+1]
                WKB = np.exp(-2*DD)
            if choice == 'II':
                if alpM0 > 0: WKB = np.exp(-2*DDs[:, i+1])
        rel_err, inds_min, inds_max, tts_corr, rel_err_corr, EGW_num_corr = \
                rel_error(tts, eta_nn, WKB, EEGW/EEGW[0], order=20, tts_lim=0)
        if value0:
            value00 = np.interp(eta_nn[-1], ttsb, EEGWb/EEGW[0])
            print('For run ', rrs[i], 'the value at \eta_0 of EEGW is ',
                  value00)
        
        ax.plot(eta_nn, WKB, color=cols[i], alpha=.5)
        ax.plot(tts_corr, EGW_num_corr, color=cols[i], ls='dashed')
        ax.plot(ttsb, EEGWb/EEGW[0], color=cols[i], ls='dashed')
        if choice == 'I' or choice == 'II':
            iax.plot(tts_corr, EGW_num_corr, color=cols[i], ls='dashed')
            iax.plot(eta_nn, WKB, color=cols[i], alpha=.5)
            iax.plot(ttsb, EEGWb/EEGW[0], color=cols[i])

    ax.loglog()
    ax.set_xlim(1, eta_nn[-1])
    ax.set_xlabel(r'$\eta/\eta_*$')
    ax.loglog()

    if choice == '0' or choice == 'III':
        ax.set_ylim(1e-5, 1e9)
        ax.set_yticks(np.logspace(-5, 9, 8))
        ax.set_ylabel(r'${\cal E}_{\rm GW} (\eta)/{\cal E}_{\rm GW}^*$')
    if choice == 'I' or choice == 'II':
        ax.set_ylim(4.5e-1, 1.6)
        ax.set_ylabel(r'${\cal E}_{\rm GW} (\eta)/{\cal E}_{\rm GW}^*$',
                      labelpad=-40)
        iax.loglog()
        if choice == 'I':
            iax.set_xlim(1e12, eta_nn[-1])
        if choice == 'II':
            iax.set_xlim(1.3e12, eta_nn[-1])

        iax.set_xticks([1e12, 1e13])
        iax.set_yticks([])
        iax.set_ylim(4.5e-1, 1.6)
        iax.xaxis.tick_top()
        iax.tick_params(axis='both', which='major', pad=10)
        for i in iax.get_xticklabels() + iax.get_yticklabels():
            i.set_fontsize(18)
        iax.set_xticks([1e13, 2e13])
        iax.axes.get_yaxis().set_visible(False)

    if txt:
        if choice == '0':
            plt.text(1e8, 1e6, r'$\alpha_{{\rm M}, 0} = -0.5$',
                     color='blue', fontsize=30)
            plt.text(3e7, 2e3, r'$\alpha_{{\rm M}, 0} = -0.3$',
                     color='green', fontsize=30)
            plt.text(1e10, 5e1, r'$\alpha_{{\rm M}, 0} = -0.1$',
                     color='red', fontsize=30)
            plt.text(5e9, 2.5, r'$\alpha_{{\rm M}, 0} = -0.01$',
                     color='magenta', fontsize=30)
            plt.text(1e10, 7e-3, r'$\alpha_{{\rm M}, 0} = 0.1$',
                     color='purple', fontsize=30)
            plt.text(1e7, 1.5e-4, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=30)
            # place a text box in upper left in axes coords
            plt.text(5, 5e6, 'choice 0', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white',
                               alpha=0.5))

            xx = np.logspace(3, 10)
            plt.plot(xx, 3*xx**(.5), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 5e-7*xx**(.5*2), color='blue', ls='dashed')
            xx = np.logspace(3, 7)
            plt.plot(xx, 2*xx**(.3), color='green', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 2e-4*xx**(.3*2), color='green', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(.1), color='red', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 5e-2*xx**(.1*2), color='red', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(-.1), color='purple', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 1e1*xx**(-.1*2), color='purple', ls='dashed')
            xx = np.logspace(3, 10)
            plt.plot(xx, 1.7*xx**(-.3), color='orange', ls='dashed')
            xx = np.logspace(12, 14)
            plt.plot(xx, 2e3*xx**(-.3*2), color='orange', ls='dashed')
            plt.text(1e5, 1e4, r'$\sim\!\eta^{-\alpha_{{\rm M}, 0}}$',
                     fontsize=26, color='black')
            plt.text(3e11, 1.3e5, r'$\sim\!\eta^{-2 \alpha_{{\rm M}, 0}}$',
                     fontsize=26, color='black')
            
        if choice == 'I':
            iax.text(8e12, 1.3, r'$\alpha_{{\rm M}, 0} = -0.5$, $n = 2$',
                     color='blue', fontsize=26)
            iax.text(6e12, 1.1, r'$\alpha_{{\rm M}, 0} = -0.3$, $n = 2$',
                     color='green', fontsize=26)
            iax.text(1.5e12, 1.05, r'$\alpha_{{\rm M}, 0} = -0.1$, $n = 2$',
                     color='red', fontsize=26)
            iax.text(7e12, .67, r'$\alpha_{{\rm M}, 0} = 0.1$, $n = 0.4$',
                     color='purple', fontsize=26)
            iax.text(2e12, 6.5e-1, r'$\alpha_{{\rm M}, 0} = 0.3$, $n = 0.4$',
                     color='orange', fontsize=26)
            # place a text box in upper left in axes coords
            ax.text(5, 1.33e0, 'choice I', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
            
        if choice == 'II':
            iax.text(1.05e13, 1.22, r'$\alpha_{{\rm M}, 0} = -0.5$',
                     color='blue', fontsize=26)
            iax.text(8e12, 1.06, r'$\alpha_{{\rm M}, 0} = -0.3$',
                     color='green', fontsize=26)
            iax.text(3e12, 1.05, r'$\alpha_{{\rm M}, 0} = -0.1$',
                     color='red', fontsize=26)
            iax.text(1.1e13, .83, r'$\alpha_{{\rm M}, 0} = 0.1$',
                     color='purple', fontsize=26)
            iax.text(1.3e13, 7e-1, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=26)
            # place a text box in upper left in axes coords
            ax.text(5, 1.33e0, 'choice II', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
            
        if choice == 'III':
            ax.text(1e8, 2e5, r'$\alpha_{{\rm M}, 0} = -0.5$',
                    color='blue', fontsize=30)
            ax.text(5e7, 8e2, r'$\alpha_{{\rm M}, 0} = -0.3$',
                    color='green', fontsize=30)
            ax.text(1e10, 1e2, r'$\alpha_{{\rm M}, 0} = -0.1$',
                    color='red', fontsize=30)
            ax.text(5e9, 2.5, r'$\alpha_{{\rm M}, 0} = -0.01$',
                    color='magenta', fontsize=30)
            ax.text(5e6, 5e-3, r'$\alpha_{{\rm M}, 0} = 0.1$',
                    color='purple', fontsize=30)
            ax.text(1e4, 1.5e-4, r'$\alpha_{{\rm M}, 0} = 0.3$',
                     color='orange', fontsize=30)
            xx = np.logspace(3, 10)
            ax.plot(xx, 3*xx**(.5*1.5), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            ax.plot(xx, 1e8*xx**(0), color='blue', ls='dashed')
            xx = np.logspace(12, 14)
            ax.plot(xx, 5e4*xx**(0), color='green', ls='dashed')
            ax.text(1e5, 6e5, r'$\sim\!\eta^{-1.5 \, \alpha_{{\rm M}, 0}}$',
                    fontsize=26, color='black')
            ax.text(1.5e12, 1e7, r'$\sim\!\eta^{0}$',
                    fontsize=26, color='black')
            ax.text(5, 5e6, 'choice III', fontsize=28,
                     bbox=dict(boxstyle='round', facecolor='white', alpha=0.5))
                
    if save:
        plt.savefig('plots/time_series_EEGW_choice' + choice + '.pdf',
                    bbox_inches='tight')
