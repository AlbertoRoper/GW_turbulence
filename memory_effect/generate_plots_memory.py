"""
generate_plots_memory.py is a Python routine  that can be used to generate
the plots of Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
gravitational waves from reheating magnetogeneses".

It reads the pickle run variables that can be generated by the routine
initialize_memory.py.

The function run() executes the code.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'
os.chdir(HOME)

from dirs import read_dirs as rd
import run as r
import plot_sets
import spectra
import cosmoGW
import interferometry as inte
import pta

os.chdir(dir0)

def run():

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = rd('memory_nonhelical_b73')
    dirs = rd('memory_nonhelical_b27')
    dirs = rd('memory_helical_b73')
    dirs = rd('memory_helical_b27')
    dirs = rd('memory_helical_b17')
    dirs = rd('memory_helical_toff')
    dirs = rd('memory_nonhelical_toff')
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)
    os.chdir(dir0)

    return runs

def generate_table_pars(runs, save=True):

    """
    Function that generates the Table I of Y. He, A. Roper Pol, and
    A. Brandenburg, "Leading-order nonlinear gravitational waves from
    reheating magnetogeneses" that contains the parameters regarding
    the end of reheating for each type of simulations.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the table in tableI.csv
                (default True)
    """

    import pandas as pd
    # choose 1 run of each of the series
    names = np.array(['A', 'B', 'C', 'D', 'E'])
    runA = runs.get('A1_l')
    runB = runs.get('B1_l')
    runC = runs.get('C1_l')
    runD = runs.get('D1_l')
    runE = runs.get('E1_l')

    rrs = [runA, runB, runC, runD, runE]

    Ts = []
    gammas = []
    betas = []
    gs = []
    rat_Hs = []
    rat_as = []
    rat_Has = []

    for i in rrs:
        pars = i.pars
        g = pars[1]
        T = pars[0]
        H0 = cosmoGW.H0_val(h0=1.)
        Hs = cosmoGW.Hs_val(g, T*u.GeV)
        rat_H = Hs/H0
        rat_a = cosmoGW.as_a0_rat(g, T*u.GeV)
        rat_Ha = rat_H**2*rat_a**4
        if pars[0] > 1: T = '%i'%pars[0]
        else: T = '%.2f'%pars[0]
        Ts.append(T)
        gs.append('%i'%g)
        gammas.append('%i'%pars[2])
        betas.append(pars[3])
        rat_Hs.append(rat_H)
        rat_as.append(rat_a)
        rat_Has.append('%.4e'%rat_Ha)

    Ts = np.array(Ts)
    gammas = np.array(gammas)
    betas = np.array(betas)
    gs = np.array(gs)
    rat_Hs = np.array(rat_Hs)
    rat_as = np.array(rat_as)
    rat_Has = np.array(rat_Has)

    df = pd.DataFrame({'name': names, 'Tr [GeV]': Ts, 'gamma': gammas,
                       'beta': betas, 'g': gs,
                       '(Hs/H0)^2 (as/a0)^4': rat_Has})

    if save: df.to_csv('tableI.csv')

    return df

def generate_table(runs, save=True, print_tex=False):

    """
    Function that generates the Table II of Y. He, A. Roper Pol, and
    A. Brandenburg, "Leading-order nonlinear gravitational waves from
    reheating magnetogeneses" that contains the relevant results of the runs.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the table in tableII.csv
                (default True)
    """

    import pandas as pd
    import cosmoGW

    name = []
    B0s = []
    kstars = []
    EM_ar = []
    EGW_ar = []
    DEGW_ar = []
    rat_DEGW_ar = []
    hr_ar = []
    Dhr_ar = []
    rat_Dhr_ar = []
    pol_ar = []
    Dpol_ar = []
    rat_Dpol_ar = []

    for i in runs:
        run = runs.get(i)
        t = run.ts.get('t')
        indt = np.argmin(abs(t - 1.))
        EEM = run.ts.get('EEEM')[indt]
        if EEM > .2: EMM = '%.0f'%EEM
        elif EEM > .05: EMM = '%.1f'%EEM
        else: EMM = '%.2f'%EEM
        tk = run.spectra.get('t_EGW')
        indt = np.argmin(abs(tk - 1))
        k = run.spectra.get('k')

        if 'toff' in run.name_run:
            GW = np.trapz(run.spectra.get('EGW_stat'), k)
            hc = np.sqrt(np.trapz(np.trapz(run.spectra.get('GWh')\
                    [np.where(tk > 2)], tk[np.where(tk > 2)], axis=0)/ \
                            (tk[-1] - tk[np.where(tk > 2)][0]), k))
            XiGW = np.trapz(run.spectra.get('helEGW_stat'), k)

        else:
            GW = np.trapz(run.spectra.get('EGW')[indt, :], k)
            hc = np.sqrt(np.trapz(run.spectra.get('GWh')[indt, :], k))
            XiGW = np.trapz(run.spectra.get('helEGW')[indt, :], k)

        pol_l = XiGW/GW

        if '_l' in run.name_run:
            B0s.append('%.1e'%run.B0)
            EM_ar.append(EMM)
            kss = cosmoGW.ks_infla(run.pars[3], run.pars[2], eta=1)
            kstars.append('%.1f'%kss)
            EGW_ar.append('%.6e'%GW)
            hr_ar.append(hc)
            nmm = run.name_run.replace('_l', '')
            if 'toff' in nmm: ser = nmm.replace('_toff', '') + "'"
            else: ser = nmm
            name.append(ser)
            diffEGW = GW_nl - GW
            DEGW_ar.append('%.6e'%diffEGW)
            rdiffEGW = diffEGW/GW_nl
            rat_DEGW_ar.append('%.6e'%rdiffEGW)
            Dhr_ar.append(hc_nl - hc)
            rat_Dhr_ar.append((hc_nl - hc)/hc_nl)
            diff_pol = pol_l - pol_nl
            Dpol_ar.append('%.6e'%diff_pol)
            rdiff_pol = diff_pol/pol_l
            rat_Dpol_ar.append('%.6e'%rdiff_pol)
        else:
            tk = run.spectra.get('t_EGW')
            indt = np.argmin(abs(tk - 1))
            k = run.spectra.get('k')
            GW_nl = np.trapz(run.spectra.get('EGW')[indt, :], k)
            XiGW_nl = np.trapz(run.spectra.get('helEGW')[indt, :], k)
            hc_nl = np.sqrt(np.trapz(run.spectra.get('GWh')[indt, :], k))

            if 'toff' in run.name_run:
                GW_nl = np.trapz(run.spectra.get('EGW_stat'), k)
                hc_nl = np.sqrt(np.trapz(np.trapz(run.spectra.get('GWh')\
                        [np.where(tk > 2)], tk[np.where(tk > 2)],
                                axis=0)/(tk[-1] - \
                                    tk[np.where(tk > 2)][0]), k))
                XiGW_nl = np.trapz(run.spectra.get('helEGW_stat'), k)

            pol_nl = XiGW_nl/GW_nl
            pol_ar.append('%.6f'%pol_nl)

    name = np.array(name)
    inds = np.argsort(name)
    name = name[inds]
    B0s = np.array(B0s)[inds]
    kstars = np.array(kstars)[inds]
    EM_ar = np.array(EM_ar)[inds]
    EGW_ar = np.array(EGW_ar)[inds]
    DEGW_ar = np.array(DEGW_ar)[inds]
    rat_DEGW_ar = np.array(rat_DEGW_ar)[inds]
    hr_ar = np.array(hr_ar)[inds]
    Dhr_ar = np.array(Dhr_ar)[inds]
    rat_Dhr_ar = np.array(rat_Dhr_ar)[inds]
    pol_ar = np.array(pol_ar)[inds]
    Dpol_ar = np.array(Dpol_ar)[inds]
    rat_Dpol_ar = np.array(rat_Dpol_ar)[inds]

    df = pd.DataFrame({'name': name, 'B0': B0s, 'EM': EM_ar,
                       'k_* (1)': kstars, 'EGW': EGW_ar,
                       'Del EGW': DEGW_ar, 'ratio Del EGW': rat_DEGW_ar,
                       'pol': pol_ar, 'Del pol': Dpol_ar,
                       'ratio Del pol': rat_Dpol_ar})

    if save: df.to_csv('tableII.csv')

    if print_tex:

        EM = np.array(df['EM'], dtype='float')
        EGW = np.array(df['EGW'], dtype='float')
        DEGW = np.array(df['Del EGW'], dtype='float')
        rDEGW = np.array(df['ratio Del EGW'], dtype='float')
        PGW = np.array(df['pol'], dtype='float')
        DPGW = np.array(df['Del pol'], dtype='float')
        rDPGW = np.array(df['ratio Del pol'], dtype='float')

        for i in range(0, len(name)):
            nmm = name[i]
            col0 = ''
            col1 = ''
            if "'" in nmm:
                ser = nmm.replace("'", '_l_toff')
                run = runs.get(ser)
                ser = '\,' + nmm
                if 'A' in nmm: col0 = '\\blue{'
                if 'B' in nmm: col0 = '\\green{'
                if 'C' in nmm: col0 = '\\orange{'
                if 'D' in nmm: col0 = '\\red{'
                if 'E' in nmm: col0 = '\\purple{'
                col1 = '}'
            else:
                run = runs.get(nmm + '_l')
                ser = nmm
            ser = col0 + ser + col1
            pars = run.pars
            exp_B0 = np.floor(np.log10(run.B0))
            bas_B0 = run.B0/10**exp_B0
            exp_EGW = np.floor(np.log10(EGW[i]))
            bas_EGW = EGW[i]/10**exp_EGW
            exp_DEGW = np.floor(np.log10(DEGW[i]))
            bas_DEGW = DEGW[i]/10**exp_DEGW
            exp_rDEGW = np.floor(np.log10(rDEGW[i]))
            bas_rDEGW = rDEGW[i]/10**exp_rDEGW
            exp_DPGW = np.floor(np.log10(abs(DPGW[i])))
            bas_DPGW = DPGW[i]/10**exp_DPGW
            exp_rDPGW = np.floor(np.log10(abs(rDPGW[i])))
            bas_rDPGW = rDPGW[i]/10**exp_rDPGW
            if pars[0] > 1000:
                T_exp = np.floor(np.log10(pars[0]))
                T_bas = pars[0]/10**T_exp
                T = "$%i \\times 10^{%i}$"%(T_bas, T_exp)
            elif pars[0] > 1: T = '%i'%pars[0]
            else: T = '%.2f'%pars[0]

            if EM[i] > .2: EMM = '%.0f'%EM[i]
            elif EM[i] > .05: EMM = '%.1f'%EM[i]
            else: EMM = '%.2f'%EM[i]
            aux = ''
            if 'B4' in nmm: aux = '\\hline'

            kstar = cosmoGW.ks_infla(pars[3], pars[2], eta=1)

            print(ser, '&', # T, '&',
                  col0 + "$%.1f \\times 10^{%i}$"%(bas_B0, exp_B0) + col1, '&',
                   col0 + '%s'%EMM + col1, '&',
                   col0 + '$%.1f$'%kstar + col1, '&',
                   col0 + "$%.1f \\times 10^{%i}$"%(bas_EGW, exp_EGW) + col1,
                   '&')
            print(col0 + "$%.1f \\times 10^{%i}$"%(bas_DEGW, exp_DEGW) + col1,
                  '&',
                  col0 + "$%.1f \\times 10^{%i}$"%(bas_rDEGW, exp_rDEGW) + col1,
                  '&')
            print(col0 + '$%.3f$'%PGW[i] + col1, '&',
                  col0 + "$%.1f \\times 10^{%i}$"%(bas_DPGW, exp_DPGW) + col1,
                      '&',
                      col0 + "$%.1f \\times 10^{%i}$"%(bas_rDPGW, exp_rDPGW) + \
                                    col1,
                      '\\\\' + aux)

    return df

def select_runs(runs, A='A'):

    """
    Function that returns linear and nonlinear runs corresponding to the
    type of simulations.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')

    Returns:
        runs_l -- array with linear run variables
        runs_nl -- array with nonlinear run variables
        col -- color corresponding to A for plots
    """

    col = 'blue'
    if A == 'A':
        run1_l = runs.get('A1_l')
        run1_nl = runs.get('A1_nl')
        run2_l = runs.get('A2_l')
        run2_nl = runs.get('A2_nl')
        run3_l = runs.get('A3_l')
        run3_nl = runs.get('A3_nl')
        run4_l = runs.get('A4_l')
        run4_nl = runs.get('A4_nl')

    if A == 'B':
        run1_l = runs.get('B1_l')
        run1_nl = runs.get('B1_nl')
        run2_l = runs.get('B2_l')
        run2_nl = runs.get('B2_nl')
        run3_l = runs.get('B3_l')
        run3_nl = runs.get('B3_nl')
        run4_l = runs.get('B4_l')
        run4_nl = runs.get('B4_nl')
        col = 'darkgreen'

    if A == 'C':
        run1_l = runs.get('C1_l')
        run1_nl = runs.get('C1_nl')
        run2_l = runs.get('C2_l')
        run2_nl = runs.get('C2_nl')
        run3_l = runs.get('C3_l')
        run3_nl = runs.get('C3_nl')
        run4_l = runs.get('C4_l')
        run4_nl = runs.get('C4_nl')
        col = 'orange'

    if A == 'D':
        run1_l = runs.get('D1_l')
        run1_nl = runs.get('D1_nl')
        run2_l = runs.get('D2_l')
        run2_nl = runs.get('D2_nl')
        run3_l = runs.get('D3_l')
        run3_nl = runs.get('D3_nl')
        run4_l = runs.get('D4_l')
        run4_nl = runs.get('D4_nl')
        col = 'red'

    if A == 'E':
        run1_l = runs.get('E1_l')
        run1_nl = runs.get('E1_nl')
        run2_l = runs.get('E2_l')
        run2_nl = runs.get('E2_nl')
        run3_l = runs.get('E3_l')
        run3_nl = runs.get('E3_nl')
        col = 'purple'

    if A != 'E':
        runs_l = [run1_l, run2_l, run3_l, run4_l]
        runs_nl = [run1_nl, run2_nl, run3_nl, run4_nl]
    else:
        runs_l = [run1_l, run2_l, run3_l]
        runs_nl = [run1_nl, run2_nl, run3_nl]

    return runs_l, runs_nl, col

def plot_EGW(runs, A='A', diff=False, save=True):

    """
    Function that plots the resulting GW energy density spectrum at the end
    of inflation (reheating) and compares the result from linear theory to
    the result after adding the leading-order non-linear term (memory effect).

    It generates the plots corresponding to figure 1 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses."
    It generates the left panels if diff = False and the right panels if
    diff = True

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        diff -- option to plot the EGW spectrum or the difference between
                linear and nonlinear when diff = True (default False)
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')
        save -- option to save the plot in plots/EGW_k_'A'_'diff'.pdf
                (default True)
    """

    fig, ax = plt.subplots(figsize=(12, 8))
    plot_sets.axes_lines()
    if diff: ax2 = ax.twinx()
    plot_sets.axes_lines(both=False)

    # chose linear and nonlinear runs corresponding to A
    runs_l, runs_nl, col = select_runs(runs, A=A)
    EEM = [0.02, 0.1, 1, 10]

    if diff:
        for i in range(0, len(runs_l)):
            run_l = runs_l[i]
            t_l = run_l.spectra.get('t_EGW')
            ind_tl = np.argmin(abs(t_l - 1.))
            if abs(t_l[ind_tl] - 1) > 1e-2:
                print('The time t = 1 is not available in the spectra of',
                      ' the run %s, so t = %.2f has been',
                      ' taken'%(run_l.name_run, t_l[ind_tl]))
            EGW_l = run_l.spectra.get('EGW')[ind_tl, 1:]
            k = run_l.spectra.get('k')[1:]
            run_nl = runs_nl[i]
            t_nl = run_nl.spectra.get('t_EGW')
            ind_tnl = np.argmin(abs(t_nl - 1.))
            if abs(t_nl[ind_tnl] - 1) > 1e-2:
                print('The time t = 1 is not available in the spectra of',
                      ' the run %s, so t = %.2f has been',
                      ' taken'%(run.name_run, t_l[ind_tnl]))
            EGW_nl = run_nl.spectra.get('EGW')[ind_tnl, 1:]
            dif = abs(EGW_nl - EGW_l)
            ax.plot(k, dif, color=col, alpha = .1 + i*.3,
                        label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[i])
            good = np.where(EGW_l != 0)
            ax2.plot(k, dif/EGW_nl[good], '.', color=col,
                     alpha = .15 + i*.15)
            ax2.set_ylim(1e-5, 2.)

    else:
        j = 0
        for i in runs_l:
            t_l = i.spectra.get('t_EGW')
            ind_tl = np.argmin(abs(t_l - 1.))
            if abs(t_l[ind_tl] - 1) > 1e-2:
                print('The time t = 1 is not available in the spectra of',
                      ' the run %s, so t = %.2f has been',
                      ' taken'%(i.name_run, t_l[ind_tl]))
            EGW_l = i.spectra.get('EGW')[ind_tl, 1:]
            k = i.spectra.get('k')[1:]
            ax.plot(k, EGW_l, color=col, alpha = .1 + j*.3,
                     label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[j])
            j += 1
        j = 0
        for i in runs_nl:
            t_nl = i.spectra.get('t_EGW')
            ind_tnl = np.argmin(abs(t_nl - 1.))
            if abs(t_nl[ind_tnl] - 1) > 1e-2:
                print('The time t = 1 is not available in the spectra of',
                      ' the run %s, so t = %.2f has been',
                      ' taken'%(i.name_run, t_nl[ind_tnl]))
            EGW_nl = i.spectra.get('EGW')[ind_tnl, 1:]
            k = i.spectra.get('k')[1:]
            ax.plot(k, EGW_nl, color=col, ls='--', alpha=.1 + j*.3)
            j += 1
        fs = 32
        if A == 'A':
            xx = np.linspace(1.2, 5)
            ax.plot(xx, 1e-8*xx, color=col, ls='-.', lw=.8)
            ax.text(1.7, 1e-11, r'$\sim\!k$', color=col, fontsize=fs)
            xx = np.linspace(15, 60)
            ax.plot(xx, 1e-12*(xx/10)**(-32), color=col, ls='-.', lw=.8)
            ax.text(14, 1e-30, r'$\sim\!k^{-32}$', color=col, fontsize=fs)
        if A == 'B':
            xx = np.linspace(1.15, 3)
            ax.plot(xx, 1e-6*xx, color=col, ls='-.', lw=.8)
            ax.text(1.3, 1e-8, r'$\sim\!k$', color=col, fontsize=fs)
            xx = np.linspace(10, 100)
            ax.plot(xx, 2e-1*(xx/10)**(-10), color=col, ls='-.', lw=.8)
            ax.text(27, 6e-5, r'$\sim\!k^{-10}$', color=col, fontsize=fs)
        if A == 'C':
            xx = np.linspace(1.4, 20)
            ax.plot(xx, 1e-10*xx**1.5, color=col, ls='-.', lw=.8)
            ax.text(3.3, 2e-13, r'$\sim\!k^{3/2}$', color=col, fontsize=fs)
            xx = np.linspace(30, 100)
            ax.plot(xx, 1e10*(xx/10)**(-45), color=col, ls='-.', lw=.8)
            ax.text(22, 1e-24, r'$\sim\!k^{-45}$', color=col, fontsize=fs)
        if A == 'D':
            xx = np.linspace(1.25, 8)
            ax.plot(xx, 1e-8*xx**1.5, color=col, ls='-.', lw=.8)
            ax.text(2., 1e-10, r'$\sim\!k^{3/2}$', color=col, fontsize=fs)
            xx = np.linspace(11, 50)
            ax.plot(xx, 1e-7*(xx/10)**(-15), color=col, ls='-.', lw=.8)
            ax.text(10, 6e-15, r'$\sim\!k^{-15}$', color=col, fontsize=fs)
        if A == 'E':
            xx = np.linspace(.2, 2.5)
            ax.plot(xx, 4e-7*xx**1.5, color=col, ls='-.', lw=.8)
            ax.text(.6, 1.3e-8, r'$\sim\!k^{3/2}$', color=col, fontsize=fs)
            xx = np.linspace(8, 50)
            ax.plot(xx, 3e-3*xx**(-4), color=col, ls='-.', lw=.8)
            ax.text(10, 7e-10, r'$\sim\!k^{-4}$', color=col, fontsize=fs)

    if not diff:
        ax.legend(fontsize=24, loc='lower left', frameon=False)
    ax.set_yscale('log')
    ax.set_xscale('log')
    if A == 'E': ax.set_xlim(.1, 9e1)
    else: ax.set_xlim(1, 300)
    if diff: ax2.set_yscale('log')
    run = runs_l[0]
    if run.pars[2] == 0: h = 'non-helical'
    else: h = 'helical'
    b = run.pars[3]
    if A == 'A' or A == 'C' or A == 'E':
        if diff:
            if A == 'E':
                ax.set_ylim(1e-34, 1e2)
                ax.set_yticks(np.logspace(-34, 2, 10))
            else:
                ax.set_ylim(1e-40, 1e2)
                ax.set_yticks(np.logspace(-46, 2, 13))
        else:
            if A == 'E':
                ax.set_ylim(1e-14, 1e1)
                ax.set_yticks(np.logspace(-14, 2, 9))
            else:
                ax.set_ylim(1e-42, 1e2)
                ax.set_yticks(np.logspace(-42, 2, 12))
    else:
        if diff:
            ax.set_ylim(1e-32, 1e2)
            ax.set_yticks(np.logspace(-34, 2, 10))
        else:
            ax.set_ylim(1e-30, 1e2)
            ax.set_yticks(np.logspace(-30, 2, 9))

    if not diff: ax.set_title(r'Series %s: %s runs with $\beta = %.1f$' \
                              %(A, h, b), pad=15)
    ax.set_xlabel('$k$')
    if diff:
        ax.set_ylabel(r'$|\Delta E_{\rm GW} (k)|$')
        ax2.set_ylabel(r'$|\Delta E_{\rm GW} (k)|$' + \
                       r'$/E_{\rm GW}^{\rm nlin} (k)$')
    else: ax.set_ylabel(r'$E_{\rm GW} (k)$')
    dff = ''
    if diff: dff = '_diff'
    if save: plt.savefig('plots/' + 'EGW_k_' + A + dff + '.pdf',
                         bbox_inches='tight')

def plot_PGW(runs, A='A', save=True):

    """
    Function that plots the resulting GW polarization spectrum at the end
    of inflation (reheating) and compares the result from linear theory to
    the result after adding the leading-order non-linear term (memory effect).

    It generates the plots corresponding to figure 2 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')
        save -- option to save the plot in plots/PGW_k_'A'.pdf (default True)
    """

    plt.figure(figsize=(12, 8))

    # chose linear and nonlinear runs corresponding to A
    runs_l, runs_nl, col = select_runs(runs, A=A)
    EEM = [0.02, 0.1, 1, 10]

    j = 0
    for i in runs_l:
        t_l = i.spectra.get('t_EGW')
        ind_tl = np.argmin(abs(t_l - 1.))
        if abs(t_l[ind_tl] - 1) > 1e-2:
            print('The time t = 1 is not available in the spectra of',
                  ' the run %s, so t = %.2f has been',
                  ' taken'%(i.name_run, t_l[ind_tl]))
        EGW_l = i.spectra.get('EGW')[ind_tl, 1:]
        XiGW_l = i.spectra.get('helEGW')[ind_tl, 1:]
        k = i.spectra.get('k')[1:]
        good = np.where(EGW_l != 0)
        plt.plot(k[good], XiGW_l[good]/EGW_l[good],
                 color=col, alpha=.1 + j*.3,
                 label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[j])
        j += 1

    j = 0
    for i in runs_nl:
        t_nl = i.spectra.get('t_EGW')
        ind_tnl = np.argmin(abs(t_nl - 1.))
        if abs(t_nl[ind_tnl] - 1) > 1e-2:
            print('The time t = 1 is not available in the spectra of',
                  ' the run %s, so t = %.2f has been',
                  ' taken'%(i.name_run, t_nl[ind_tnl]))
        EGW_nl = i.spectra.get('EGW')[ind_tnl, 1:]
        XiGW_nl = i.spectra.get('helEGW')[ind_tnl, 1:]
        k = i.spectra.get('k')[1:]
        good = np.where(EGW_nl != 0)
        plt.plot(k[good], XiGW_nl[good]/EGW_nl[good], '--',
                 color=col, alpha=.1 + j*.3)
        j += 1

    run = runs_l[0]
    if run.pars[2] == 0: h = 'non-helical'
    else: h = 'helical'
    b = run.pars[3]
    plt.title(r'Series %s: %s runs with $\beta = %.1f$'%(A, h, b), pad=15)

    plt.xscale('log')
    plt.xlim(1, 300)
    plt.ylim(-.2, 1.1)
    locc = 'lower left'
    if A == 'C': locc = 'lower center'
    if A == 'E': locc = 'lower right'
    plt.legend(loc=locc, fontsize=20, frameon=False)
    if A == 'E': plt.xlim(.2, 100)
    plot_sets.axes_lines()
    plt.xlabel('$k$')
    plt.ylabel(r'${\cal P}_{\rm GW} (k)$')
    ax = plt.gca()
    ax.tick_params(axis='x', pad=15)

    if save: plt.savefig('plots/' + 'PGW_k_' + A + '.pdf',
                         bbox_inches='tight')

def plot_EEGW_vs_EEM(runs, save=True, plot=True, print_tex=False):

    """
    Function that plots the total GW energy density produced as a function
    of the maximum electromagnetic energy density, both for the linearized
    GW equation and the nonlinear contribution corresponding to the
    nonlinear effect.

    It generates the plot corresponding to figure 3 and the tables
    corresponding to table III of  Y. He, A. Roper Pol, and
    A. Brandenburg, "Leading-order nonlinear gravitational waves from
    reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/EEGW_EEM.pdf and
                plots/DEEGW_EEM.pdf (default True)
    """

    import pandas as pd

    df = generate_table(runs, save=False)
    df_pars = generate_table_pars(runs, save=False)
    EEM = np.array(df['EM'], dtype='float')
    EGW = np.array(df['EGW'], dtype='float')
    delEGW = np.array(df['Del EGW'], dtype='float')
    name = np.array(df['name'])
    delpol = np.array(df['ratio Del pol'], dtype='float')
    betas = np.array(df_pars['beta'], dtype='float')
    gammas = np.array(df_pars['gamma'], dtype='float')

    col_A = 'blue'
    col_B = 'darkgreen'
    col_C = 'orange'
    col_D = 'red'
    col_E = 'purple'

    def plot_runA(q, A='A', exp=2, d='two', plot=True,
                  qst='q', kk=True, sc=False, col='blue'):

        bet = np.array(df_pars['beta'][np.where(df_pars['name'] == A)[0]],
                       dtype='float')[0]
        gam = np.array(df_pars['gamma'][np.where(df_pars['name'] == A)[0]],
                       dtype='float')[0]
        kstar = cosmoGW.ks_infla(bet, gam)
        if plot:
            if d == 'two': st = '%.2f'%q
            if d == 'three': st = '%.3f'%q
            if sc:
                xp = np.floor(np.log10(q))
                base = q/10**xp
                if d == 'two': st = r'%.1f \times 10^{%i}'%(base, xp)
                if d == 'three': st = r'%.2f \times 10^{%i}'%(base, xp)
            lbl = r'$%s = %s$'%(qst, st)
            if kk: lbl += ', $k_* = %.1f$'%kstar
            plt.plot(xx, (q*xx)**exp, color=col, lw=.8,
                     label=lbl)

        return q*kstar

    if plot:
        plt.figure(1, figsize=(12, 8))
        plt.figure(2, figsize=(12, 8))
        plt.figure(3, figsize=(12, 8))

    # plot scatter points of EGW, Delta EGW and Delta PGW/PGW vs EM
    f_col = 'none'
    for i in range(0, len(EEM)):
        if 'A' in name[i]:
            col = col_A
            if '2' in name[i]:
                if "'" in name[i]:
                    ratA = np.sqrt(EGW[i])/EEM[i]
                    ratA1 = (delEGW[i])**(1/3)/EEM[i]
                    ratA2 = delpol[i]/EEM[i]
        if 'B' in name[i]:
            col = col_B
            if '2' in name[i]:
                if "'" in name[i]:
                    ratB = np.sqrt(EGW[i])/EEM[i]
                    ratB1 = (delEGW[i])**(1/3)/EEM[i]
                    ratB2 = delpol[i]/EEM[i]
        if 'C' in name[i]:
            col = col_C
            f_col = col
            if '2' in name[i]:
                if "'" in name[i]:
                    ratC = np.sqrt(EGW[i])/EEM[i]
                    ratC1 = (delEGW[i])**(1/3)/EEM[i]
                    ratC2 = delpol[i]/EEM[i]
        if 'D' in name[i]:
            col = col_D
            f_col = col_D
            if '2' in name[i]:
                if "'" in name[i]:
                    ratD = np.sqrt(EGW[i])/EEM[i]
                    ratD1 = (delEGW[i])**(1/3)/EEM[i]
                    ratD2 = delpol[i]/EEM[i]
        if 'E' in name[i]:
            col = col_E
            f_col = col_E
            if '2' in name[i]:
                if "'" in name[i]:
                    ratE = np.sqrt(EGW[i])/EEM[i]
                    ratE1 = (delEGW[i])**(1/3)/EEM[i]
                    ratE2 = delpol[i]/EEM[i]
        if plot:
            if "'" not in name[i]:
                plt.figure(1)
                plt.scatter(EEM[i], EGW[i], facecolors=f_col, color=col)
                plt.figure(2)
                plt.scatter(EEM[i], delEGW[i], facecolors=f_col, color=col)
                plt.figure(3)
                plt.scatter(EEM[i], abs(delpol[i]), facecolors=f_col,
                            color=col)
            else:
                plt.figure(1)
                plt.plot(EEM[i], EGW[i], 'x', color=col)
                plt.figure(2)
                plt.plot(EEM[i], delEGW[i], 'x', color=col)
                plt.figure(3)
                plt.plot(EEM[i], abs(delpol[i]), 'x', color=col)
    xx2 = np.logspace(-1, 2)
    xx = np.logspace(-3, 3)
    xx3 = np.logspace(-1.8, -.9)

    # plot quadratic lines of EGW vs EM and obtain coefficients q and q tilde
    if plot: plt.figure(1)
    q = [.18, .52, .08, .21, .36]
    AA = ['A', 'B', 'C', 'D', 'E', "A'", "B'", "C'",
          "D'", "E'"]
    cols = [col_A, col_B, col_C, col_D, col_E]
    q.append(ratA)
    q.append(ratB)
    q.append(ratC)
    q.append(ratD)
    q.append(ratE)
    q = np.array(q)
    qt = np.zeros(10)
    for l in range(0, 5):
        qt[l] = plot_runA(q[l], A=AA[l], col=cols[l], plot=plot)
        qt[l + 5] = plot_runA(q[l + 5], A=AA[l], plot=False)
        if plot: plt.plot(xx3, (q[l + 5]*xx3)**2, ls='-.',
                          color=cols[l], lw=.8)
    if plot:
        plt.legend(loc='upper left', fontsize=20, frameon=False)
        plt.text(1, 5e-5, r'${\cal E}_{\rm GW} =  (q {\cal E}_{\rm EM})^2$',
                 fontsize=26)
        plot_sets.axes_lines()
        plt.xlabel(r'${\cal E}_{\rm EM}$')
        plt.ylabel(r'${\cal E}_{\rm GW}$')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim(1e-2, 20)
        plt.yticks(np.logspace(-6, 2, 9))
        plt.ylim(1e-6, 1e2)
        plt.fill_between(xx2, xx2**0*1e-7, xx2**0*1e3, color='gray', alpha=.1)

    if save and plot: plt.savefig('plots/EEGW_EEM.pdf',
                                  bbox_inches='tight')

    # plot cubic lines Delta EGW vs EM and obtain coefficients p and p tilde
    if plot: plt.figure(2)
    p = [.033, .23, .047, .18, .37]
    p.append(ratA1*.93)
    p.append(ratB1*.93)
    p.append(ratC1)
    p.append(ratD1*.98)
    p.append(ratE1)
    p = np.array(p)
    pt = np.zeros(10)
    for l in range(0, 5):
        pt[l] = plot_runA(p[l], A=AA[l], exp=3, qst='p', kk=False,
                          col=cols[l], plot=plot)
        pt[l + 5] = plot_runA(p[l + 5], A=AA[l], plot=False)
        if plot: plt.plot(xx3, (p[l + 5]*xx3)**3, ls='-.',
                          color=cols[l], lw=.8)
    if plot:
        plt.legend(loc='upper left', fontsize=20, frameon=False)
        plt.text(1, 1e-7,
                 r'$\Delta {\cal E}_{\rm GW} =  (p {\cal E}_{\rm EM})^3$',
                 fontsize=26)
        plot_sets.axes_lines()
        plt.xlabel(r'${\cal E}_{\rm EM}$')
        plt.ylabel(r'$\Delta {\cal E}_{\rm GW}$')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim(1e-2, 20)
        plt.yticks(np.logspace(-10, 2, 13))
        plt.ylim(3e-11, 1e2)
        plt.fill_between(xx2, xx2**0*1e-12, xx2**0*1e3, color='gray', alpha=.1)

    if save and plot: plt.savefig('plots/DEEGW_EEM.pdf',
                         bbox_inches='tight')

    # plot linear relation Delta PGW/PGW vs EM and obtain coefficients
    # r and r tilde
    if plot: plt.figure(3)
    r = [8.5e-5, 7e-3, 2e-3, 1.5e-2, 4.5e-2]
    r.append(abs(ratA2)*.99)
    r.append(abs(ratB2)*1.05)
    r.append(abs(ratC2)*1.3)
    r.append(abs(ratD2)*.75)
    r.append(abs(ratE2)*.8)
    r = np.array(r)
    rt = np.zeros(10)
    for l in range(0, 5):
        rt[l] = plot_runA(r[l], A=AA[l], exp=1, qst='r', kk=False,
                          sc=True, col=cols[l], plot=plot)
        rt[l + 5] = plot_runA(r[l + 5], A=AA[l], plot=False)
        if plot: plt.plot(xx3, r[l + 5]*xx3, ls='-.',
                          color=cols[l], lw=.8)
    if plot:
        plt.legend(loc='upper left', fontsize=20, frameon=False)
        plt.text(1, 1e-5, r'$|\Delta {\cal P}_{\rm GW}| = $' + \
                 r' $ r |{\cal P}_{\rm GW}| \, {\cal E}_{\rm EM}$',
                 fontsize=26)
        plot_sets.axes_lines()
        plt.xlabel(r'${\cal E}_{\rm EM}$')
        plt.ylabel(r'$|\Delta {\cal P}_{\rm GW}/{\cal P}_{\rm GW}|$')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim(1e-2, 20)
        plt.yticks(np.logspace(-6, 0, 7))
        plt.ylim(3e-7, 1e1)
        plt.fill_between(xx2, xx2**0*1e-7, xx2**0*1e1, color='gray', alpha=.1)

    df2 = pd.DataFrame({'run': AA, 'q': q, 'qt': qt,
                        'p': p, 'pt': pt,
                        'r': r, 'rt': rt})
    if save:
        df2.to_csv('tableIII.csv')
        if plot:
            plt.savefig('plots/ratDPGW_EEM.pdf',
                        bbox_inches='tight')

    if print_tex:

        nms = np.array(df2['run'])
        q = np.array(df2['q'])
        qt = np.array(df2['qt'])
        p = np.array(df2['p'])
        pt = np.array(df2['pt'])
        r = np.array(df2['r'])
        rt = np.array(df2['rt'])

        inds = np.argsort(nms)
        for i in inds:
            nmm = '%s'%nms[i]
            if 'toff' in nms[i]: nmm = nmm.replace('_toff', "'")
            exp_r = np.floor(np.log10(abs(r[i])))
            bas_r = r[i]/10**exp_r
            exp_rt = np.floor(np.log10(abs(rt[i])))
            bas_rt = rt[i]/10**exp_rt
            print(nmm, '&', '$(%.2f, %.2f)$'%(q[i], p[i]), '&',
                  '$(%.2f, %.2f)$'%(qt[i], pt[i]), '&')
            print('$%.1f \\times 10^{%i}$'%(bas_r, exp_r), '&',
                 '$%.1f \\times 10^{%i}$'%(bas_rt, exp_rt), '\\\\')

    return df2

def plot_timeseries_EGW(runs, lin=False, pol=False, diff=False, shift=0.,
                        old=False, A='A', col='blue'):

    """
    Function to plot a specific time series called in
    overshoot_ts (arguments are the same).
    """

    run_nl = runs.get(A + '2_nl_toff')
    EGW_nl = run_nl.spectra.get('EGW_mean')
    t_nl = run_nl.spectra.get('t_EGW')

    if pol:
        XiGW_nl = run_nl.spectra.get('helEGW_mean')
        P_nl = XiGW_nl/EGW_nl
    if old:
        run_old = runs.get(A + '2_nl')
        EGW_old = run_old.spectra.get('EGW_mean')
        t_old = run_old.spectra.get('t_EGW')
        if pol:
            XiGW_old = run_old.spectra.get('helEGW_mean')
            P_old = XiGW_old/EGW_old

    if lin or diff:
        run_l = runs.get(A + '2_l_toff')
        EGW_l = run_l.spectra.get('EGW_mean')
        t_l = run_l.spectra.get('t_EGW')
        if pol:
            XiGW_l = run_l.spectra.get('helEGW_mean')
            P_l = XiGW_l/EGW_l
        if old:
            run_old_l = runs.get(A + '2_l')
            t_old_l = run_old_l.spectra.get('t_EGW')
            EGW_old_l = run_old_l.spectra.get('EGW_mean')
            if pol:
                XiGW_old_l = run_old_l.spectra.get('helEGW_mean')
                P_old_l = XiGW_old_l/EGW_old_l

    if diff:
        t_nl2 = t_nl - shift
        t_lnl, EGW_nl, EGW_l = r.interpolate_ts(t_nl2, t_l, EGW_nl, EGW_l)
        diff_EGW_nl = EGW_nl - EGW_l
        good = np.where(t_lnl > 2)[0]
        diffEGW_stat = np.trapz(diff_EGW_nl[good], t_lnl[good])/\
                            (t_lnl[-1] - t_lnl[good][0])

        plt.figure(1)
        # plot positive and negative values of Delta EGW with different
        # line styles
        spectra.plot_neg_pos(t_lnl, diff_EGW_nl, ls1='solid', lw1=1,
                             ls2=':', lw2=2, col=col)
        plt.hlines(diffEGW_stat, -2, 20, color=col, ls='-.')
        indt_1 = np.argmin(abs(t_lnl - 1.))
        plt.plot(t_lnl[indt_1], diff_EGW_nl[indt_1], 'o', color=col)
        plt.hlines(diff_EGW_nl[indt_1], -2, 2, ls='-.', color=col,
                   lw=.7)
        print(A, ', max: ', max(diff_EGW_nl), r', value at $\eta = 1$:',
              diff_EGW_nl[indt_1], r', average value over $\eta$:',
              diffEGW_stat)

        # plot only helical runs (pars[2] = 1)
        if pol:
            t_nl2 = t_nl - shift
            t_lnl, P_nl, P_l = r.interpolate_ts(t_nl2, t_l, P_nl, P_l)
            diff_PGW = (P_l - P_nl)/P_l
            good = np.where(t_lnl > 2)[0]
            diffPGW_stat = np.trapz(diff_PGW[good], t_lnl[good])/\
                                (t_lnl[-1] - t_lnl[good][0])
            plt.figure(2)
            if diffPGW_stat > 0:
                plt.hlines(diffPGW_stat, -2, 20, color=col, ls='-.')
            else:
                plt.hlines(-diffPGW_stat, -2, 20, color=col, ls='dotted')
            plt.plot(t_lnl[indt_1], abs(diff_PGW[indt_1]), 'o',
                     color=col)
            plt.hlines(abs(diff_PGW)[indt_1], -2, 2, ls='-.', color=col,
                       lw=.7)
            # plot positive and negative values with different line styles
            spectra.plot_neg_pos(t_lnl, diff_PGW, ls1='solid', lw1=1,
                                 ls2=':', lw2=2, col=col)

        if old:
            t_old2 = t_old - shift
            t_old_lnl, EGW_old, EGW_old_l = \
                    r.interpolate_ts(t_old2, t_old_l, EGW_old, EGW_old_l)
            diff_old = EGW_old - EGW_old_l
            plt.figure(1)
            plt.plot(t_old_lnl, diff_old, '.', color=col)
            if pol:
                plt.figure(2)
                t_old_lnl, P_old, P_old_l = \
                        r.interpolate_ts(t_old, t_old_l, P_old, P_old_l)
                diff_PGW_old = (P_old_l - P_old)/P_old_l
                plt.plot(t_old_lnl, diff_PGW_old, '.', color=col)
    else:
        ind_tnl = np.argmin(abs(t_nl - 1))
        k_nl = run_nl.spectra.get('k')
        EGW_stat = np.trapz(run_nl.spectra.get('EGW_stat'), k_nl)
        plt.figure(1)
        plt.plot(t_nl, EGW_nl, color=col)
        plt.hlines(EGW_stat, -2, 20, color=col, ls='-.')
        if old:
            plt.plot(t_old, EGW_old, '.', color=col)
        indt_1 = np.argmin(abs(t_nl - 1))
        plt.plot(t_nl[indt_1], EGW_nl[indt_1], 'o',
                 color=col)
        plt.hlines(EGW_nl[indt_1], -2, 2, color=col, ls='-.', lw=.7)
        print(A, ', max EEGW: ', max(EGW_nl), r', value at $\eta = 1$:',
              EGW_nl[indt_1], r', average value over $\eta$:',
              EGW_stat)
        jf = 2
        if lin:
            plt.figure(jf)
            plt.plot(t_l, EGW_l, color=col)
            plt.plot(t_nl - shift, EGW_nl, lw=.7, ls='--', color=col)
            if old:
                plt.plot(t_old_l, EGW_old_l, '.', color=col)
            jf += 1
        if pol:# and run_nl.pars[2] == 1:
            plt.figure(jf)
            plt.plot(t_nl, P_nl, color=col)
            plt.plot(t_nl[indt_1], P_nl[indt_1], color=col)
            if old:
                plt.plot(t_old, P_old, '.', color=col)

def overshoot_ts(runs, lin=False, pol=False, diff=False, shift=0,
                 old=False, save=True, extra=False):

    """
    Function that plots the timeseries of the GW energy density up to the end
    of inflation (reheating) and at later times (for which we have sourced off
    the GW production) for runs A2 to E2.

    It generates the plots corresponding to figure 4 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/overshoot_ts.pdf
                or plots/overshoot_ts_diff.pdf (if diff = True)
                (default True)
        lin -- option to plot the linear GW energy density, instead of the
               nonlinear (default False)
        pol -- option to plot the time evolution of the total polarization
               (default False)
        diff -- option to plot the time evolution of the difference in GW
                energy density between nonlinear and linear contributions
                (default False)
        shift -- shift in time of the nonlinear solution (default 0)
        old -- option to overplot results of runs from 0 to 1 (default 0)
        extra -- option to add inset plot to zoom in in a specific region
                 (used for the figure) (default False)
    """

    from mpl_toolkits.axes_grid.inset_locator import inset_axes
    import matplotlib.patches as patches

    plt.figure(1, figsize=(12, 8))
    jf=2
    if lin:
        plt.figure(jf, figsize=(12, 8))
        jf += 1
    if pol:
        plt.figure(jf, figsize=(12, 8))
    plot_timeseries_EGW(runs, diff=diff, old=old, pol=pol, lin=lin,
                        shift=shift,
                        A='E', col='purple')
    plot_timeseries_EGW(runs, diff=diff, old=old, pol=pol, lin=lin,
                        shift=shift,
                        A='D', col='red')
    plot_timeseries_EGW(runs, diff=diff, old=old, pol=pol, lin=lin,
                        shift=shift,
                        A='C', col='orange')
    plot_timeseries_EGW(runs, diff=diff, old=old, pol=pol, lin=lin,
                        shift=shift,
                        A='B', col='green')
    plot_timeseries_EGW(runs, diff=diff, old=old, pol=pol, lin=lin,
                        shift=shift)
    plt.figure(1)
    plot_sets.axes_lines()
    if diff:
         y0 = 1e-9
         y1 = 3e-4
    else:
        y0 = 6e-6
        y1 = 5e-3
    plt.vlines(1, y0, y1, color='black', ls='-.')
    plt.vlines(2, y0, y1, color='black', ls='-.')
    plt.yscale('log')
    plt.xlabel(r'$\eta$')
    if diff: plt.ylabel(r'$\Delta {\cal E}_{\rm GW}$')
    else: plt.ylabel(r'${\cal E}_{\rm GW}^{\rm nlin}$')
    plt.ylim(y0, y1)
    plt.xlim(0, 10)
    plt.xticks(np.linspace(0, 10, 11))

    fs=24
    if not diff:
        plt.text(5.25, 1.25e-4, "A2'", color='blue', fontsize=fs)
        plt.text(5.25, 1e-3, "B2'", color='green', fontsize=fs)
        plt.text(5.25, 7e-5, "C2'", color='orange', fontsize=fs)
        plt.text(5.25, 4e-4, "D2'", color='red', fontsize=fs)
        plt.text(5.25, 2.8e-3, "E2'", color='purple', fontsize=fs)
        dff = ''
        if extra:
            # this is an inset axes over the main axes
            ax = plt.gca()
            plt.annotate('', xy=(3.5, 5.5e-5), xytext=(2.5, 1.4e-3),
                         arrowprops=dict(facecolor='black', shrink=0.,
                                         width=.2, alpha=.3),)
            inset_axes = inset_axes(ax,
                            width="40%", # width = 30% of parent_bbox
                            height=1.8, # height : 1 inch
                            loc=8)
            plt.xticks([])
            plt.yticks([])
            run_nl = runs.get('B2_nl_toff')
            run_l = runs.get('B2_l_toff')
            EGW_nl = run_nl.spectra.get('EGW_mean')
            t_nl = run_nl.spectra.get('t_EGW')
            EGW_l = run_l.spectra.get('EGW_mean')
            t_l = run_l.spectra.get('t_EGW')
            plt.plot(t_l, EGW_l, color='darkgreen', alpha=.6)
            plt.plot(t_nl, EGW_nl, color='darkgreen', ls='--')
            k = run_nl.spectra.get('k')
            EGW_stat = run_nl.spectra.get('EGW_stat')
            plt.hlines(np.trapz(EGW_stat, k), 2, 4, color='darkgreen',
                       ls='-.', alpha=.6)
            ax.add_patch(patches.Rectangle((2, 1.4e-3), 2, 8e-4,
                                           edgecolor='black', alpha=.7,
                                           linewidth=1.5, facecolor='none'))
            plt.xlim(2, 4)
            plt.ylim(1.4e-3, 2.2e-3)
    else:
        plt.text(5.75, 3.5e-7, "A2'", color='blue', fontsize=fs)
        plt.text(5.1, 9e-6, "B2'", color='green', fontsize=fs)
        plt.text(5.25, 6e-9, "C2'", color='orange', fontsize=fs)
        plt.text(6.3, 3.5e-6, "D2'", color='red', fontsize=fs)
        plt.text(5.25, 6e-5, "E2'", color='purple', fontsize=fs)
        dff = '_diff'

    if save:
        plt.savefig('plots/' + 'overshoot_ts' + dff + '.pdf',
                    bbox_inches='tight')

    jf = 2
    if lin and not diff:
        plt.figure(jf)
        jf += 1
        plot_sets.axes_lines()
        if diff:
             y0 = 1e-9
             y1 = 3e-4
        else:
            y0 = 2e-5
            y1 = 5e-3
        plt.vlines(1, y0, y1, color='black', ls='-.')
        plt.vlines(2, y0, y1, color='black', ls='-.')
        plt.yscale('log')
        plt.xlabel(r'$\eta$')
        plt.ylabel(r'${\cal E}_{\rm GW}$')
        plt.ylim(y0, y1)
        plt.xlim(0, 10)
        plt.xticks(np.linspace(0, 10, 11))

        if save:
            plt.savefig('plots/' + 'overshoot_ts_lin.pdf',
                        bbox_inches='tight')

    if pol:
        plt.figure(jf)
        plot_sets.axes_lines()
        if diff:
            plt.yscale('log')
            y0 = 1e-7
            y1 = 1e0
        else:
            y0 = -.6
            y1 = 1.1
        plt.vlines(1, y0, y1, color='black', ls='-.')
        plt.vlines(2, y0, y1, color='black', ls='-.')
        plt.xlabel(r'$\eta$')
        if diff: plt.ylabel(r'$\Delta {\cal P}_{\rm GW}/{\cal P}_{\rm GW}$')
        else:
            plt.ylabel(r'${\cal P}_{\rm GW}^{\rm nlin}$')
        plt.xlim(0, 10)
        plt.xticks(np.linspace(0, 10, 11))
        plt.ylim(y0, y1)
        if save:
            plt.savefig('plots/' + 'overshoot_ts_PGW' + dff + '.pdf',
                        bbox_inches='tight')

def plot_EGW_k(runs, lin=False, diff=False, A='A', col='blue'):

    """
    Function to plot one of the spectra shown using overshoot_EGW.
    """

    run_nl = runs.get(A + '2_nl_toff')
    k_nl = run_nl.spectra.get('k')[1:]
    t_nl = run_nl.spectra.get('t_EGW')
    indt_nl = np.argmin(abs(t_nl - 1))
    EGW_nl = run_nl.spectra.get('EGW')[:, 1:]
    EGW_nl_stat = run_nl.spectra.get('EGW_stat')[1:]

    if not diff and not lin:
        plt.plot(k_nl, EGW_nl[indt_nl, :], color=col, lw = .7, alpha = .6)
        plt.plot(k_nl, EGW_nl_stat, '--', color=col)

    else:
        run_l = runs.get(A + '2_l_toff')
        k_l = run_l.spectra.get('k')[1:]
        t_l = run_l.spectra.get('t_EGW')
        indt_l = np.argmin(abs(t_l - 1))
        EGW_l = run_l.spectra.get('EGW')[:, 1:]
        EGW_l_stat = run_l.spectra.get('EGW_stat')[1:]

        if diff:
            diff_EGW = EGW_nl[indt_nl, :] - EGW_l[indt_l, :]
            diff_EGW_stat = EGW_nl_stat - EGW_l_stat
            plt.plot(k_nl, abs(diff_EGW)/EGW_nl[indt_nl, :],
                     color=col, alpha=.6, lw=.6)
            plt.plot(k_nl, abs(diff_EGW_stat)/EGW_nl_stat, '--',
                     color=col)
        else:
            plt.plot(k_l, EGW_l[indt_l], color=col)
            plt.plot(k_l, EGW_l_stat, '-.', color=col)

def overshoot_EGW(runs, lin=False, diff=False, save=True):

    """
    Function that plots the GW energy density spectra and compares them at the
    end of reheating and their saturated values for runs A2 to E2.

    It generates the plots corresponding to figure 5 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/overshoot_ts.pdf
                or plots/overshoot_EGW_k.pdf (if diff = True)
                (default True)
        lin -- option to plot the linear spectra, instead of the
               nonlinear (default False)
        diff -- option to plot the the difference in the spectra of GW
                energy density between nonlinear and linear contributions
                (default False)
    """

    from mpl_toolkits.axes_grid.inset_locator import inset_axes

    fig, ax = plt.subplots(figsize=(12, 8))
    plot_EGW_k(runs, diff=diff, lin=lin)
    plot_EGW_k(runs, A='B', col='green', diff=diff, lin=lin)
    plot_EGW_k(runs, A='C', col='orange', diff=diff, lin=lin)
    plot_EGW_k(runs, A='D', col='red', diff=diff, lin=lin)
    plot_EGW_k(runs, A='E', col='purple', diff=diff, lin=lin)
    ax.set_xlabel('$k$')
    if not diff: ax.set_ylabel(r'$E_{\rm GW}^{\rm nlin} (k)$')
    if diff: ax.set_ylabel(r'$\Delta E_{\rm GW} (k)/E_{\rm GW}^{\rm nlin}$')
    plot_sets.axes_lines()
    ax.tick_params(axis='x', labelsize=28)
    ax.tick_params(axis='y', labelsize=28)
    ax.set_yscale('log')
    ax.set_xscale('log')
    plt.xlim(.2, 300)
    if not diff:
        plt.ylim(1e-38, 1e-2)
        plt.yticks(np.logspace(-38, -2, 10))
        plt.text(3.6e1, 1e-32, "A2'", color='blue')
        plt.text(1.5e2, 1e-19, "B2'", color='green')
        plt.text(4.5e1, 1e-10, "C2'", color='orange')
        plt.text(1.8e2, 1e-25, "D2'", color='red')
        plt.text(5e1, 1e-6, "E2'", color='purple')

        # this is an inset axes over the main axes
        inset_axes = inset_axes(ax,
                        width="50%", # width = 30% of parent_bbox
                        height=4.0, # height : 1 inch
                        loc=3)
        plot_EGW_k(runs, lin=lin)
        plot_EGW_k(runs, A='B', col='green', lin=lin)
        plot_EGW_k(runs, A='C', col='orange', lin=lin)
        plot_EGW_k(runs, A='D', col='red', lin=lin)
        plot_EGW_k(runs, A='E', col='purple', lin=lin)
        plt.yscale('log')
        plt.xscale('log')
        plot_sets.axes_lines()
        plt.xlim(.6, 50)
        plt.ylim(2e-9, 2e-3)
        ax = plt.gca()
        ax.yaxis.tick_right()
        ax.xaxis.tick_top()
        ax.tick_params(axis='x', labelsize=14)
        ax.tick_params(axis='y', labelsize=14, pad=10)
        ax.set_xticks(np.logspace(0, 1, 2))
        ax.set_yticks(np.logspace(-8, -3, 6))
        plt.text(.8, 6e-9, r'$E_{\rm GW} (k)$', fontsize=24)
        dff = ''
    else:
        plt.ylim(1e-4, 2)
        dff = 'diff'

    if save:
        plt.savefig('plots/' + 'overshoot_EGW_k' + dff + '.pdf',
                    bbox_inches='tight')

def Pol_EGW(runs, A='A', col='blue'):

    """
    Function that plots one of the polarization spectra shown in
    overshoot_PGW
    """

    run_nl = runs.get(A + '2_nl_toff')
    k_nl = run_nl.spectra.get('k')[1:]
    t_nl = run_nl.spectra.get('t_EGW')
    indt_nl = np.argmin(abs(t_nl - 1))
    EGW_nl = run_nl.spectra.get('EGW')[:, 1:]
    XiGW_nl = run_nl.spectra.get('helEGW')[:, 1:]
    run_l = runs.get(A + '2_l_toff')
    k_l = run_l.spectra.get('k')[1:]
    t_l = run_l.spectra.get('t_EGW')
    indt_l = np.argmin(abs(t_l - 1))
    EGW_l = run_l.spectra.get('EGW')[:, 1:]
    XiGW_l = run_l.spectra.get('helEGW')[:, 1:]

    good = np.where(t_nl > 2)[0]
    EGW_nl_stat = np.trapz(EGW_nl[good, :], t_nl[good], axis=0)/ \
                            (t_nl[-1] - t_nl[good][0])
    XiGW_nl_stat = np.trapz(XiGW_nl[good, :], t_nl[good], axis=0)/ \
                            (t_nl[-1] - t_nl[good][0])
    good = np.where(t_l > 2)[0]
    EGW_l_stat = np.trapz(EGW_l[good, :], t_l[good], axis=0)/ \
                            (t_l[-1] - t_l[good][0])
    XiGW_l_stat = np.trapz(XiGW_l[good, :], t_l[good], axis=0)/ \
                            (t_l[-1] - t_l[good][0])

    plt.plot(k_nl, XiGW_nl[indt_nl, :]/EGW_nl[indt_nl, :],
             color=col, lw=.7, alpha=.6)
    plt.plot(k_nl, XiGW_nl_stat/EGW_nl_stat, ls='--', color=col)
    plt.plot(k_l, XiGW_l_stat/EGW_l_stat, ls='dotted', color=col)

def overshoot_PGW(runs, save=True):

    """
    Function that plots the GW polarization spectra and compares them at the
    end of reheating and their saturated values for runs A2 to E2.

    It generates the plots corresponding to figure 6 of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/overshoot_PGW_k.pdf
                or plots/overshoot_PGW_k.pdf (if diff = True)
                (default True)
    """

    plt.figure(figsize=(12, 8))
    plot_sets.axes_lines()
    Pol_EGW(runs, A='C', col='orange')
    Pol_EGW(runs, A='D', col='red')
    Pol_EGW(runs, A='E', col='purple')
    plt.xscale('log')
    plt.ylim(-.2, 1.1)
    plt.xlabel('$k$')
    plt.ylabel(r'${\cal P}_{\rm GW}^{\rm nlin}$')
    plt.text(70, .05, "C2'", color='orange')
    plt.text(70, .5, "C2", color='orange')
    plt.text(180, .5, r"C$2^{\rm lin}$", color='orange')
    plt.text(.35, .2, "E2'", color='purple')
    plt.text(1, .7, "D2'", color='red')
    dff = ''
    if save:
        plt.savefig('plots/' + 'overshoot_PGW_k' + dff + '.pdf',
                    bbox_inches='tight')

def plot_OmGW_f(run_l, run_nl, T, g, diff=True,
                sp='EGW', col='blue', toff=True):

    """
    Function that plots each of the runs shown in plot_OmGW_vs_f
    """

    t_l = run_l.spectra.get('t_' + sp)
    ind_tl = np.argmin(abs(t_l - 1.))
    if abs(t_l[ind_tl] - 1) > 1e-2:
        print('The time t = 1 is not available in the spectra of',
              ' the run %s, so t = %.2f has been',
              ' taken'%(run_l.name_run, t_l[ind_tl]))
    EGW_l = run_l.spectra.get(sp)[ind_tl, 1:]
    if toff:
        EGW_l = run_l.spectra.get(sp + '_stat')[1:]
    k_l = run_l.spectra.get('k')[1:]
    f_l, OmGW_l = cosmoGW.shift_OmGW_today(k_l, EGW_l*k_l, T, g)
    t_nl = run_nl.spectra.get('t_' + sp)
    ind_tnl = np.argmin(abs(t_nl - 1.))
    if abs(t_nl[ind_tnl] - 1) > 1e-2:
        print('The time t = 1 is not available in the spectra of',
              ' the run %s, so t = %.2f has been',
              ' taken'%(run_nl.name_run, t_nl[ind_tnl]))
    EGW_nl = run_nl.spectra.get(sp)[ind_tnl, 1:]
    if toff:
        EGW_nl = run_nl.spectra.get(sp + '_stat')[1:]
    k_nl = run_nl.spectra.get('k')[1:]
    f_nl, OmGW_nl = cosmoGW.shift_OmGW_today(k_nl, EGW_nl*k_nl, T, g)

    if 'hel' in sp:
         OmGW_nl = abs(OmGW_nl)
         OmGW_l = abs(OmGW_l)

    plt.plot(f_nl, OmGW_nl, color=col)

    if not diff:
        plt.plot(f_l, OmGW_l, color=col, ls='-.')
    else:
        # plot positive and negative values with different line styles
        diff_OmGW = OmGW_nl - OmGW_l
        sgn = np.sign(diff_OmGW)
        converge = False
        sgn0 = sgn[0]
        i = 0
        lw = 1
        while not converge:
            sign = False
            i0 = i
            while not sign and not converge:
                if sgn0 == 1:
                    ls = '-.'
                    lw = 1
                else:
                    ls = 'dotted'
                    lw = .6
                if i==len(sgn) - 2: converge=True
                if sgn[i] != sgn0:
                    sign = True
                    sgn0 = sgn[i]
                i += 1
            plt.plot(f_nl[i0:i+1], abs(diff_OmGW[i0:i+1]),
                     color=col, ls=ls, lw=lw)

def plot_OmGW_vs_f(runs, save=True):

    """
    Function that plots the resulting GW energy density spectrum at the end
    of inflation (reheating) as an observable at the present time and compares
    it with LISA sensitivity, NANOGrav 12.5 yr results, and other GW detectors.
    It plots the leading-order nonlinear term as a GW spectrum separately
    for comparison.

    It generates the plot corresponding to figure 7 (left panel) of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/OmGW_f_detectors.pdf
                (default True)
    """

    plt.figure(figsize=(12, 8))

    CWD = os.getcwd()
    os.chdir('..')
    dir = 'detector_sensitivity'

    # read LISA PLS
    fs, LISA_Om, LISA_OmPLS = inte.read_sens(SNR=10, T=4)
    fs = fs*u.Hz

    # read SKA
    f_SKA, hc_SKA = inte.read_csv(dir, 'SKA', b='hc')
    f_SKA = f_SKA*u.Hz
    Om_SKA = cosmoGW.hc_OmGW(f_SKA, hc_SKA, d=-1)

    # read Gaia and Theia
    f_Gaia, Om_Gaia = inte.read_csv(dir, 'Gaia_PLS_SNR10')
    ff = np.logspace(np.log10(f_Gaia[0]), np.log10(f_Gaia[-1]), 100)
    Om_Gaia = 10**np.interp(ff, f_Gaia, np.log10(Om_Gaia))
    f_Gaia = ff*u.Hz
    f_Theia, Om_Theia = inte.read_csv(dir, 'Theia_PLS_SNR10')
    f_Theia = f_Theia*u.Hz

    # read DECIGO
    f_DECIGO, Om_DECIGO = inte.read_csv(dir, 'DECIGO_PLS_SNR10')
    ff = np.logspace(np.log10(f_DECIGO[0]), np.log10(f_DECIGO[-1]), 100)
    Om_DECIGO = 10**np.interp(ff, f_DECIGO, np.log10(Om_DECIGO))
    f_DECIGO = ff*u.Hz

    # read AEDGE and AION
    f_AEDGE, Om_AEDGE = inte.read_csv(dir, 'AEDGE')
    f_AION, Om_AION = inte.read_csv(dir, 'AION')

    # read constrains from binary resonance
    f_MSP, Om_MSP = inte.read_csv(dir, 'binaries_MSPs_2038')
    f_LLR, Om_LLR = inte.read_csv(dir, 'binaries_LLR_2038')
    f_SLR, Om_SLR = inte.read_csv(dir, 'binaries_SLR_2038')

    # read muAres
    fs_mu, muAres_Om, muAres_OmPLS = inte.read_sens(interf='muAres',
                                                 SNR=10, T=4)

    # read NANOGrav data
    os.chdir('runs_nonhelical_ini')
    _ = pta.read_PTA_data(beta_b=False, Omega_b=False, return_all=True)
    gamma_NG_sPL_1s, A1_NG_sPL_1s, A2_NG_sPL_1s = [_[3], _[4], _[5]]
    betas = np.linspace(-2, 5, 100)
    colors = ['blue']*len(betas)
    _ = pta.CP_delay(betas, colors, obs='NANOGrav_singlePL_1s',
             plot=False)
    fNG = _[0]
    OmGW_NG_a = _[3]
    OmGW_NG_b = _[6]
    _ = pta.CP_delay(betas, colors, obs='NANOGrav_brokenPL_1s',
             plot=False)
    fNGb = _[0]
    OmGW_NGb_a = _[3]
    OmGW_NGb_b = _[6]
    os.chdir(CWD)

    lww = .6
    plt.plot(fs, LISA_OmPLS, color='limegreen', lw=lww)
    plt.plot(fs, LISA_Om, color='limegreen', ls='-.', lw=lww)
    plt.plot(f_SKA, Om_SKA, color='black', lw=lww)
    plt.plot(f_Gaia, Om_Gaia, color='navy', lw=lww)
    plt.plot(f_Theia, Om_Theia, color='navy', lw=lww)
    plt.plot(f_DECIGO, Om_DECIGO, color='darkred', lw=lww)
    plt.plot(f_AEDGE, Om_AEDGE, color='peru', lw=lww)
    plt.plot(f_AION, Om_AION, color='peru', lw=lww)
    plt.plot(f_MSP, Om_MSP, color='darkviolet', lw=lww)
    plt.plot(f_LLR, Om_LLR, color='darkviolet', lw=lww)
    plt.plot(fs_mu, muAres_OmPLS, color='cyan', lw=lww)
    #plt.plot(f_SLR, Om_SLR, color='darkviolet', lw=.8)
    minOm, maxOm = pta.get_min_max(fNG, OmGW_NG_a, OmGW_NG_b)
    plt.fill_between(fNG, minOm, maxOm, color='blue', alpha=.3)
    plt.text(6e-9, 1.3e-5, 'NANOGrav 12.5yr', color='blue',
             fontsize=14, alpha=.7)
    plt.text(2e-4, 2e-13, 'LISA', color='limegreen',
             fontsize=16, alpha=.7)
    plt.text(6e-8, 2e-10, 'SKA', color='black',
             fontsize=16, alpha=.7)
    plt.text(2e-7, 5e-10, 'Theia', color='navy',
             fontsize=16, alpha=.7)
    plt.text(1.8e-9, 4e-9, 'Gaia', color='navy',
             fontsize=16, alpha=.7)
    plt.text(3e-2, 3e-17, 'DECIGO', color='darkred',
             fontsize=16, alpha=.7)
    plt.text(1.e-1, 1.5e-14, 'AEDGE', color='peru',
             fontsize=16, alpha=.7)
    plt.text(2.5e-2, 9e-13, 'AION', color='peru',
             fontsize=16, alpha=.7)
    plt.text(2e-5, 5e-6, 'MSPs', color='darkviolet',
             fontsize=16, alpha=.7)
    plt.text(1.7e-6, 1e-7, 'LLR', color='darkviolet',
             fontsize=16, alpha=.7)
    plt.text(2e-4, 3e-17, r'$\mu$Ares', color='cyan',
             fontsize=16)

    # choose toff runs
    runA_l = runs.get('A2_l_toff')
    runA_nl = runs.get('A2_nl_toff')
    runB_l = runs.get('B2_l_toff')
    runB_nl = runs.get('B2_nl_toff')
    runC_l = runs.get('C2_l_toff')
    runC_nl = runs.get('C2_nl_toff')
    runD_l = runs.get('D2_l_toff')
    runD_nl = runs.get('D2_nl_toff')
    runE_l = runs.get('E2_l_toff')
    runE_nl = runs.get('E2_nl_toff')

    col_A = 'blue'
    col_B = 'darkgreen'
    col_C = 'orange'
    col_D = 'red'
    col_E = 'purple'

    # Note that T and g are different for every run
    # pars[0] is the temperature in GeV and pars[1] is g
    plot_OmGW_f(runA_l, runA_nl, runA_l.pars[0]*u.GeV,
                runA_l.pars[1], col=col_A, toff=True)
    plot_OmGW_f(runB_l, runB_nl, runB_l.pars[0]*u.GeV,
                runB_l.pars[1], col=col_B, toff=True)
    plot_OmGW_f(runC_l, runC_nl, runC_l.pars[0]*u.GeV,
                runC_l.pars[1], col=col_C, toff=True)
    plot_OmGW_f(runD_l, runD_nl, runD_l.pars[0]*u.GeV,
                runD_l.pars[1], col=col_D, toff=True)
    plot_OmGW_f(runE_l, runE_nl, runE_l.pars[0]*u.GeV,
                runE_l.pars[1], col=col_E, toff=True)

    plot_sets.axes_lines()
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('$f$ [Hz]')
    plt.ylabel(r'$h_0^2 \Omega_{\rm GW} (f)$')
    plt.xticks(np.logspace(-9, 0, 10))
    plt.xlim(1e-9, 1e0)
    plt.yticks(np.logspace(-18, -4, 15))
    plt.ylim(1e-18, 1e-4)

    plt.text(6e-5, 1e-14, "A2'", color='blue')
    plt.text(1.5e-7, 2e-17, "B2'", color='darkgreen')
    plt.text(3e-6, 1e-16, "C2'", color='orange')
    plt.text(1e-7, 8e-14, "D2'", color='red')
    plt.text(2.5e-3, 1e-9, "E2'", color='purple')

    if save: plt.savefig('plots/' + 'OmGW_f_detectors.pdf',
                         bbox_inches='tight')

def plot_XiGW_vs_f(runs, diff=False, save=True):

    """
    Function that plots the resulting helical GW energy density spectrum at
    the end of inflation (reheating) as an observable at the present time
    and compares it with LISA sensitivity to polarization and that of the
    LISA-Taiji network.
    It plots the leading-order nonlinear term as a GW spectrum separately
    for comparison.

    It generates the plot corresponding to figure 7 (right panel) of
    Y. He, A. Roper Pol, and A. Brandenburg, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the plot in plots/XiGW_f_detectors.pdf
                (default True)
    """

    plt.figure(figsize=(12, 8))

    CWD = os.getcwd()
    os.chdir('..')
    dir = 'detector_sensitivity'
    # read LISA and Taiji PLS
    fs, LISA_Om, LISA_OmPLS, LISA_Xi, LISA_XiPLS = \
            inte.read_sens(SNR=10, T=4, interf='LISA', Xi=True)
    fs_comb, LISA_Taiji_Xi, LISA_Taiji_XiPLS = \
            inte.read_sens(SNR=10, T=4, interf='comb')
    fs = fs*u.Hz
    fs_comb = fs_comb*u.Hz
    os.chdir(CWD)

    lww = .6
    plt.plot(fs, LISA_XiPLS, color='limegreen', lw=lww)
    plt.plot(fs, LISA_Xi, color='limegreen', ls='-.', lw=lww)
    plt.plot(fs_comb, LISA_Taiji_XiPLS, color='darkred', lw=lww)
    plt.text(7e-4, 1e-9, 'LISA', color='limegreen',
             fontsize=16, alpha=.7)
    plt.text(1e-5, 1e-9, r'LISA--Taiji', color='darkred',
             fontsize=16, alpha=.7)

    # choose toff runs
    runA_l = runs.get('A2_l_toff')
    runA_nl = runs.get('A2_nl_toff')
    runB_l = runs.get('B2_l_toff')
    runB_nl = runs.get('B2_nl_toff')
    runC_l = runs.get('C2_l_toff')
    runC_nl = runs.get('C2_nl_toff')
    runD_l = runs.get('D2_l_toff')
    runD_nl = runs.get('D2_nl_toff')
    runE_l = runs.get('E2_l_toff')
    runE_nl = runs.get('E2_nl_toff')

    col_A = 'blue'
    col_B = 'darkgreen'
    col_C = 'orange'
    col_D = 'red'
    col_E = 'purple'

    # Note that T and g are different for every run
    # pars[0] is the temperature in GeV and pars[1] is g
    plot_OmGW_f(runA_l, runA_nl, runA_l.pars[0]*u.GeV,
                runA_l.pars[1], col=col_A, sp='helEGW',
                diff=diff)
    plot_OmGW_f(runB_l, runB_nl, runB_l.pars[0]*u.GeV,
                runB_l.pars[1], col=col_B, sp='helEGW',
                diff=diff)
    plot_OmGW_f(runC_l, runC_nl, runC_l.pars[0]*u.GeV,
                runC_l.pars[1], col=col_C, sp='helEGW',
                diff=diff)
    plot_OmGW_f(runD_l, runD_nl, runD_l.pars[0]*u.GeV,
                runD_l.pars[1], col=col_D, sp='helEGW',
                diff=diff)
    plot_OmGW_f(runE_l, runE_nl, runE_l.pars[0]*u.GeV,
                runE_l.pars[1], col=col_E, sp='helEGW',
                diff=diff)

    plot_sets.axes_lines()
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('$f$ [Hz]')
    plt.ylabel(r'$h_0^2\,\Xi_{\rm GW} (f)$')
    plt.xticks(np.logspace(-9, 0, 10))
    plt.xlim(1e-9, 1e0)
    plt.yticks(np.logspace(-14, -4, 11))
    plt.ylim(1e-14, 1e-6)

    plt.text(3e-5, 1e-11, "A2'", color='blue')
    plt.text(8e-9, 2e-13, "B2'", color='darkgreen')
    plt.text(5e-7, 1e-10, "C2'", color='orange')
    plt.text(4.5e-8, 1e-9, "D2'", color='red')
    plt.text(1.5e-1, 1e-8, "E2'", color='purple')

    if save: plt.savefig('plots/' + 'XiGW_f_detectors.pdf',
                         bbox_inches='tight')
