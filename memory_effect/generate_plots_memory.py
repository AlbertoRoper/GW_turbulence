"""
generate_plots_memory.py is a Python routine  that can be used to generate
the plots of Y. He, A. Brandenburg, and A. Roper Pol, "Leading-order nonlinear
gravitational waves from reheating magnetogeneses".

It reads the pickle run variables that can be generated by the routine
initialize_memory.py.

The function run() executes the code.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '/..'
os.chdir(HOME)

from dirs import read_dirs as rd
import run as r
import plot_sets
import spectra

os.chdir(dir0)

def run():

    os.chdir(HOME)
    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = rd('memory_nonhelical_b73')
    dirs = rd('memory_nonhelical_b27')
    dirs = rd('memory_helical_b73')
    dirs = rd('memory_helical_b27')
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)
    os.chdir(dir0)

    return runs

def select_runs(runs, A='A'):

    """
    Function that returns linear and nonlinear runs corresponding to the
    type of simulations.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')

    Returns:
        runs_l -- array with linear run variables
        runs_nl -- array with nonlinear run variables
        col -- color corresponding to A for plots
    """

    col = 'blue'
    if A == 'A':
        run1_l = runs.get('A1_l')
        run1_nl = runs.get('A1_nl')
        run2_l = runs.get('A2_l')
        run2_nl = runs.get('A2_nl')
        run3_l = runs.get('A3_l')
        run3_nl = runs.get('A3_nl')
        run4_l = runs.get('A4_l')
        run4_nl = runs.get('A4_nl')

    if A == 'B':
        run1_l = runs.get('B1_l')
        run1_nl = runs.get('B1_nl')
        run2_l = runs.get('B2_l')
        run2_nl = runs.get('B2_nl')
        run3_l = runs.get('B3_l')
        run3_nl = runs.get('B3_nl')
        run4_l = runs.get('B4_l')
        run4_nl = runs.get('B4_nl')
        col = 'darkgreen'

    if A == 'C':
        run1_l = runs.get('C1_l')
        run1_nl = runs.get('C1_nl')
        run2_l = runs.get('C2_l')
        run2_nl = runs.get('C2_nl')
        run3_l = runs.get('C3_l')
        run3_nl = runs.get('C3_nl')
        run4_l = runs.get('C4_l')
        run4_nl = runs.get('C4_nl')
        col = 'orange'

    if A == 'D':
        run1_l = runs.get('D1_l')
        run1_nl = runs.get('D1_nl')
        run2_l = runs.get('D2_l')
        run2_nl = runs.get('D2_nl')
        run3_l = runs.get('D3_l')
        run3_nl = runs.get('D3_nl')
        run4_l = runs.get('D4_l')
        run4_nl = runs.get('D4_nl')
        col = 'darkred'

    runs_l = [run1_l, run2_l, run3_l, run4_l]
    runs_nl = [run1_nl, run2_nl, run3_nl, run4_nl]

    return runs_l, runs_nl, col

def plot_EGW(runs, A='A', diff=False, save=True):

    """
    Function that plots the resulting GW energy density spectrum at the end
    of inflation (reheating) and compares the result from linear theory to
    the result after adding the leading-order non-linear term (memory effect).

    It generates the plots corresponding to figure 1 of
    Y. He, A. Brandenburg, and A. Roper Pol, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".
    It generates the left panels if diff = False and the right panels if
    diff = True

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        diff -- option to plot the EGW spectrum or the difference between
                linear and nonlinear when diff = True (default False)
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')
        save -- option to save the plot in plots/EGW_k_'A'_'diff'.pdf (default True)
    """

    fig, ax = plt.subplots(figsize=(12, 8))
    if diff: ax2 = ax.twinx()

    # chose linear and nonlinear runs corresponding to A
    runs_l, runs_nl, col = select_runs(runs, A=A)
    EEM = [10, 1, 0.1, 0.02]

    if diff:
        for i in range(0, 4):
            run_l = runs_l[i]
            EGW_l = run_l.spectra.get('EGW')[-1, :]
            run_nl = runs_nl[i]
            EGW_nl = run_nl.spectra.get('EGW')[-1, :]
            if A == 'A' or A == 'B':
                ax.plot(abs(EGW_nl - EGW_l), color=col, alpha = 1 - i*.3,
                        label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[i])
            else:
                ax.plot(EGW_nl - EGW_l, color=col, alpha = 1 - i*.3,
                        label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[i])
            good = np.where(EGW_l != 0)
            ax2.plot(EGW_nl[good]/EGW_l[good], '.', color=col,
                     alpha = .6 - i*.15)

    else:
        j = 0
        for i in runs_l:
            EGW_l = i.spectra.get('EGW')[-1, :]
            ax.plot(EGW_l, color=col, alpha = 1 - j*.3,
                     label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[j])
            j += 1
        j = 0
        for i in runs_nl:
            EGW = i.spectra.get('EGW')[-1, :]
            ax.plot(EGW, color=col, ls='--', alpha = 1 - j*.3)
            j += 1

    if not diff:
        ax.legend(fontsize=18, loc='lower left', frameon=False)
    ax.set_yscale('log')
    ax.set_xscale('log')
    ax.set_xlim(1, 300)
    if diff: ax2.set_yscale('log')
    plot_sets.axes_lines()
    if A == 'A' or A == 'B':
        h = 'non-helical'
        if diff:
            ax.set_ylim(1e-44, 1e2)
            ax.set_yticks(np.logspace(-46, 2, 13))
        else:
            ax.set_ylim(1e-42, 1e2)
            ax.set_yticks(np.logspace(-42, 2, 12))
    else:
        h = 'helical'
        if diff:
            ax.set_ylim(1e-32, 1e2)
            ax.set_yticks(np.logspace(-34, 2, 10))
        else:
            ax.set_ylim(1e-30, 1e2)
            ax.set_yticks(np.logspace(-30, 2, 9))
    if A == 'A' or A == 'C': b = 7.3
    else: b = 2.7

    ax.set_title(r'%s runs with $\beta = %.1f$'%(h, b), pad=15)
    ax.set_xlabel('$k$')
    if diff:
        if A == 'A' or A == 'B': ax.set_ylabel(r'$|\Delta E_{\rm GW} (k)|$')
        else: ax.set_ylabel(r'$\Delta E_{\rm GW} (k)$')
        ax2.set_ylabel(r'$E_{\rm GW}^{\rm nlin}$' + \
                       r'$ (k)/E_{\rm GW}^{\rm lin} (k)$')
    else: ax.set_ylabel(r'$E_{\rm GW} (k)$')
    dff = ''
    if diff: dff = '_diff'
    if save: plt.savefig('plots/' + 'EGW_k_' + A + dff + '.pdf',
                         bbox_inches='tight')

def plot_PGW(runs, A='A', save=True):

    """
    Function that plots the resulting GW polarization spectrum at the end
    of inflation (reheating) and compares the result from linear theory to
    the result after adding the leading-order non-linear term (memory effect).

    It generates the plots corresponding to figure 2 of
    Y. He, A. Brandenburg, and A. Roper Pol, "Leading-order nonlinear
    gravitational waves from reheating magnetogeneses".

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        A -- option to chose the type of runs to be plotted (default 'A',
             other options are 'B', 'C', 'D')
        save -- option to save the plot in plots/PGW_k_'A'.pdf (default True)
    """

    plt.figure(figsize=(12, 8))

    # chose linear and nonlinear runs corresponding to A
    runs_l, runs_nl, col = select_runs(runs, A=A)
    EEM = [10, 1, 0.1, 0.02]

    j = 0
    for i in runs_l:
        EGW_l = i.spectra.get('EGW')[-1, :]
        XiGW_l = i.spectra.get('helEGW')[-1, :]
        good = np.where(EGW_l != 0)
        plt.plot(XiGW_l[good]/EGW_l[good],
                 color=col, alpha=1 - j*.3,
                 label=r'${\cal E}_{\rm EM} = %.2f$'%EEM[j])
        j += 1

    j = 0
    for i in runs_nl:
        EGW = i.spectra.get('EGW')[-1, :]
        XiGW = i.spectra.get('helEGW')[-1, :]
        good = np.where(EGW != 0)
        plt.plot(XiGW[good]/EGW[good], '--',
                 color=col, alpha=1 - j*.3)
        j += 1

    if A == 'A' or A == 'B': h = 'non-helical'
    else: h = 'helical'
    if A == 'A' or A == 'C': b = 7.3
    else: b = 2.7
    plt.title(r'%s runs with $\beta = %.1f$'%(h, b), pad=15)

    plt.xscale('log')
    plt.xlim(1, 300)
    if A=='C':
        plt.ylim(-1, 1.1)
        plt.legend(loc='lower right', fontsize=18, frameon=False)
    if A=='D':
        plt.ylim(-.2, 1.1)
        plt.legend(loc='center right', fontsize=18, frameon=False)
    plot_sets.axes_lines()
    plt.xlabel('$k$')
    plt.ylabel(r'${\cal P}_{\rm GW} (k)$')
    ax = plt.gca()
    ax.tick_params(axis='x', pad=15)

    if save: plt.savefig('plots/' + 'PGW_k_' + A + '.pdf',
                         bbox_inches='tight')
