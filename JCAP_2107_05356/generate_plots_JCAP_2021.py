"""
generate_plots_JCAP_2021.py is a Python routine that can be used
to generate the plots of A. Roper Pol, S. Mandal, A. Brandenburg, and
T. Kahniashvili, "Polarization of gravitational waves from helical MHD
turbulent sources," https://arxiv.org/abs/2107.05356.

It reads the pickle run variables that can be generated by the routines
initialize_JCAP_2021.py, initialize_PRR_2021.py, and initialize_PRD_2020.py

The function run() executes the code.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u

# get working directory, where the runs and routines should be stored
dir0 = os.getcwd() + '/'
HOME = dir0 + '..'
os.chdir(HOME)

from dirs import read_dirs as rd
import plot_sets
import run as r
import interferometry as inte
import cosmoGW
import spectra

os.chdir(dir0)

def run():

    os.chdir(HOME)

    # import dictionary with the names identifying
    # the runs and pointing to the corresponding directory
    dirs = {}
    dirs = rd('JCAP_2021_ini', dirs)
    dirs = rd('JCAP_2021_dri', dirs)
    R = [s for s in dirs]

    # read the runs stored in the pickle variables
    runs = r.load_runs(R, dir0, dirs, quiet=False)

    dirs_PRR = {}
    dirs_PRR = rd('PRR_2021_K', dirs_PRR)
    dirs_PRR = rd('PRR_2021_M', dirs_PRR)
    R_PRR = [s for s in dirs_PRR]

    # read the runs stored in the pickle variables
    dir0_PRR = dir0 + '../PRR_2011_05556/'
    runs_PRR = r.load_runs(R_PRR, dir0_PRR, dirs_PRR, quiet=False)

    dirs_PRD = {}
    dirs_PRD = rd('PRD_2020_ini', dirs_PRD)
    dirs_PRD = rd('PRD_2020_hel', dirs_PRD)
    dirs_PRD = rd('PRD_2020_noh', dirs_PRD)
    dirs_PRD = rd('PRD_2020_ac', dirs_PRD)
    R_PRD = [s for s in dirs_PRD]

    # read the runs stored in the pickle variables
    dir0_PRD = dir0 + '../PRD_1903_08585/'
    runs_PRD = r.load_runs(R_PRD, dir0_PRD, dirs_PRD, quiet=False)

    os.chdir(dir0)

    return runs, runs_PRR, runs_PRD

def generate_table(runs, save=True, print_tex=False):

    """
    Function that generates the Table I of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356, containing the
    parameters of the simulations and the characteristic values of magnetic and
    GW results.

    Arguments:
        runs -- variable that contains the memory project runs with the
                stored spectra
        save -- option to save the table in tableI.csv
                (default True)
    """

    import pandas as pd

    types = []
    sigmas = []
    EMmaxs = []
    OmGWstat = []
    PMs = []
    PGWs = []
    ks = []
    ns = []
    etas = []

    for i in runs:
        run = runs.get(i)
        types.append(run.type)
        sigmas.append(run.sig)
        EMmaxs.append(run.EMmax)
        OmGWstat.append(run.GWstat)
        PMs.append(run.PM)
        PGWs.append(run.PGW)
        ks.append(run.k)
        ns.append(run.n)
        etas.append(run.eta)

    types = np.array(types)
    sigmas = np.array(sigmas)
    EMmaxs = np.array(EMmaxs)
    OmGWstat = np.array(OmGWstat)
    PMs = np.array(PMs)
    PGWs = np.array(PGWs)
    ks = np.array(ks)
    ns = np.array(ns)
    etas = np.array(etas)

    df = pd.DataFrame({'Type': types, 'sigma': sigmas, 'EEM^max': EMmaxs,
                       'Omega_GW^stat': OmGWstat, 'PPM': PMs,
                       'PPGW': PGWs, 'kf': ks, 'n': ns, 'eta': etas})

    if save: df.to_csv('tableI.csv')

    if print_tex:

        for i in range(0, len(types)):

            exp_EM = np.floor(np.log10(EMmaxs[i]))
            bas_EM = EMmaxs[i]/10**exp_EM
            exp_EGW = np.floor(np.log10(OmGWstat[i]))
            bas_EGW = OmGWstat[i]/10**exp_EGW
            exp_eta = np.floor(np.log10(etas[i]))
            bas_eta = etas[i]/10**exp_eta
            if sigmas[i] == '-0.01' or sigmas[i] == '-1':
                PM_s = '$\!\!\!%.3f$'%PMs[i]
                sig_s = '$\!\!\!%s$'%sigmas[i]
            else:
                PM_s = '\ $%.2f$'%PMs[i]
                sig_s = '\ $%s$'%sigmas[i]
            if sigmas[i] == '-1': PGW_s = '$\!\!%.2f$'%PGWs[i]
            else: PGW_s = '\ $%.2f$'%PGWs[i]

            print(types[i], '&', sig_s, '&',
                  "$%.2f \\times 10^{%i}$"%(bas_EM, exp_EM), '&',
                  "$%.2f \\times 10^{%i}$"%(bas_EGW, exp_EGW), '&',
                  PM_s, '&', PGW_s, '&', ks[i], '&', ns[i], '&',
                  "$%.0f \\times 10^{%i}$"%(bas_eta, exp_eta), '\\\\')

    return df

def plot_st(k, sp, hel=False, yks=False, N=5, Ay=1., Ay2=[],
            Ax=[], inds_show=[], inds_show_txt=[], fb=False, min_sp=[],
            max_sp=[], min_sp_pos=[], max_sp_pos=[], min_sp_neg=[],
            max_sp_neg=[], yv=False, color='black', marg=1.02, diff0 = 0.1):

    """
    Function to plot the spectrum selected, with options to plot positive
    and negative values in different colors for helical spectra.

    Arguments:
        k -- array of wave numbers
        sp -- array of spectral values
        hel -- option to separate positive and negative values for spectral
               functions (red shows positive and blue shows negative)
               (default False)
        yks -- option to plot power law fits above (or below) spectra
               (default True)
        N -- number of power law fits to be used (default 5)
        Ay -- factor multiplied to the power law fits for visualization
              (default 1)
        Ax, Ay2 -- factors multiplied to the x, y positions of the text k^{a/b}
                   of the power law fits. It should be given as an array of
                   length N (default values are 1s)
        inds_show -- indices of the discretized spectra in power law fits where
                     we show the power law fit (default all of them)
        inds_show_txt -- indices of the discretized spectra in power law fits
                         where we show the text k^{a/b}Â (default all of them)
        fb -- option to use filled plot between maximum and minimum of
              spectra (default False)
        min_sp, max_sp -- if fb is selected we need to provide the minimum
                          and maximum of the spectral functions
        min_sp_pos, min_sp_neg, max_sp_pos, max_sp_neg -- if fb and hel are
                selected, we need to provide the maximum and minimum of
                the spectral functions (both for the positive and negative
                values)
        yv -- option to plot vertical lines over the oscillations at the
              data points (default False)
        color -- color of the spectra lines of the plot (default 'black'),
                 this option does not change the color of positive and negative
                 values of helical spectra
        marg -- factor that indicates the length of the power law fits shown,
                in the interval (k0*marg, k1/marg) to show that the power laws
                are discretized
        diff0 -- margin allowed to approximate the power law exponent to
                 a fraction for the text shown k^{a/b} (default 0.1)
    """

    if len(Ay2) == 0: Ay2 = [1.]*N
    if len(Ax) == 0: Ax = [1.]*N

    if hel:
        k_pos, k_neg, sp_pos, sp_neg, color = spectra.red_blue_func(k, sp)
        plt.plot(k_pos, sp_pos, '.', color='red')
        plt.plot(k_neg, abs(sp_neg), '.', color='blue')
        plt.plot(k, abs(sp), color='black', ls='dotted')
        # fb option to plot shaded regions between minimum and maximum
        # of oscillations of the helical GW energy density spectra
        if fb or yv:
            if len(min_sp_pos)*len(max_sp_pos)*len(min_sp_neg)* \
                    len(max_sp_neg) == 0:
                print('\n with the arguments hel=True and fb=True or yv=True',
                      ' you need to provide min_sp_pos, max_sp_pos',
                      ' min_sp_neg, and max_sp_neg')
            else:
                if fb:
                    plt.fill_between(k, min_sp_pos, max_sp_pos, alpha=0.1,
                                    color='red')
                    plt.fill_between(k, min_sp_neg, max_sp_neg, alpha=0.1,
                                    color='blue')
                if yv:
                    for i in range(0, len(k)):
                        plt.vlines(k[i], min_sp_neg[i], max_sp_neg[i],
                                   color='blue', ls='dashed', lw=0.6)
                        plt.vlines(k[i], min_sp_pos[i], max_sp_pos[i],
                                   color='red', ls='dashed', lw=0.6)

    else:
        plt.plot(k, sp, color=color, lw=2)
        # fb option to plot shaded regions between minimum and maximum
        # of oscillations of the helical GW energy density spectra
        if fb or yv:
            if len(min_sp)*len(max_sp) == 0:
                print('\n with the arguments hel=False and fb=True or yv=True',
                      ' you need to provide min_sp and max_sp_pos')
            else:
                if fb:
                    plt.fill_between(k, min_sp, max_sp, alpha=0.1, color=color)
                if yv:
                    for i in range(0, len(k)):
                        plt.vlines(k[i], min_sp[i], max_sp[i], color=color,
                                   ls='dashed', lw=0.6)

    if yks:
        ks, sp_ks, aks, km, sp_m, kps, c = spectra.compute_yks(k, abs(sp), N)
        show = np.zeros(N)
        show_txt = np.zeros(N)
        if len(inds_show) > N:
            print('the indices selected in inds_show cannot be more than',
                  ' the number of discretized power laws N')
            inds_show = np.array(range(0, N))
        if len(inds_show) == 0: show += 1
        else: show[inds_show] = 1
        if len(inds_show_txt) > N: inds_show = np.array(range(0, N))
        else: show_txt[inds_show_txt] = 1
        kps = np.logspace(np.log10(ks[0]), np.log10(ks[-1]), N + 1)
        for i in range(0, N):
            str_exp = '$k^{%.0f}$'%aks[i]
            for j in range(0, 6):
                str_exp, diff = spectra.str_exp(str_exp, aks[i],
                                                j + 1, diff=diff0)
                if diff < diff0: break
                else: diff0 = diff
            if show[i]:
                kss = np.logspace(np.log10(kps[i]*marg),
                                  np.log10(kps[i + 1]/marg))
                plt.plot(kss, kss**aks[i]*10**c[i]*Ay,
                         color='black', lw=.6)
            if show_txt[i]:
                txt = plt.text(km[i]*Ax[i], sp_m[i]*Ay*Ay2[i],
                               str_exp, size=30)

def plot_EM_EGW(run, save=True):

    """
    Function that plots the magnetic energy and helicity spectra at the time
    of maximum magnetic energy density.
    It also plots the GW energy density and helicity spectra, averaging over
    times after the GW energy has entered a stationary oscillatory stage (this
    needs to be previously computed and stored in the run variable, see
    initialize_JCAP_2021.py).

    It corresponds to figures 1-3 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        run -- variable run with spectral information
        save -- option to save the figure in plots/'name_run'EM_EGW.pdf'
                (default True)
    """

    # auxiliary functions used in plot_EM_EGW
    def init_Ay2_Ax(N, Ay, Ax):
        return N, N*[Ay], N*[Ax]

    # chose indices to show power law fits and text with k^(a/b) for magnetic
    # spectrum EM(k)
    def indices_EM(nm, Ax, Ay):
        if 'i' in nm:
            inds_show = [0, 1, 4, 5, 6, 7, 8, 9, 10]
            inds_show_txt = [0, 6]
            Ay[0] *= 8; Ay[6] *= 2
            if '3' in nm or '5' in nm:
                inds_show_txt = [0, 7]
                Ay[7] *= .5
                if '5' in nm: Ay[0] *= 2
            if nm == 'i_s1':
                inds_show_txt = [1, 7]
                Ay[1] *= 20; Ax[1] *= .7; Ay[7] *= .5
        else:
            if '001' in nm:
                inds_show = [0, 1, 4, 6, 8, 9, 10, 11]
                inds_show_txt = [1, 4, 6, 10]
                Ay[1] *= 6; Ax[1] *=.7; Ay[4] *= 25; Ay[6] *= 2;
                Ay[10] *= 1/6000
            else:
                inds_show = [0, 1, 5, 6, 7, 8, 9, 10, 11]
                inds_show_txt = [0, 5, 7, 10, 11]
                Ay[0] *= 5; Ay[5] *= 3.5; Ay[7] *= 1/10; Ay[10] *= 6e-5;
                Ay[11] *= 1e-6; Ax[11] *= .9
                if '5' in nm:
                    inds_show_txt = [1, 5, 7, 10, 11]
                    Ay[1] *= 10; Ax[1] *= .8; Ay[10] *= 1/8; Ay[11] *= 1/5
                if '7' in nm:
                    inds_show_txt = [0, 5, 7, 9, 10]
                    Ay[5] *= .5; Ay[7] *= 3e-1; Ay[9] *= 1e-4; Ay[10] *= 3e-2
                if '1' in nm:
                    inds_show_txt = [0, 5, 7, 9, 10]
                    Ay[0] *= 2; Ax[0] *= .9; Ay[5] *= .3; Ay[7] *= 1e-1
                    Ay[9] *= 4e-5; Ay[10] *= 1e-2; Ax[10] *= 1.1
        return inds_show, inds_show_txt, Ax, Ay

    # chose indices to show power law fits and text with k^(a/b) for magnetic
    # helicity spectrum HM(k)
    def indices_HM(nm, Ax, Ay):
        inds_show = []
        inds_show_txt = []
        if 'i' in nm:
            inds_show = [1, 4, 5, 6, 7, 8]
            inds_show_txt = [1]
            Ay[1] *= 80
            #Ay[2] *= 100; Ax[2] *= .8
            if '3' in nm or '5' in nm:
                inds_show = [0, 1, 4, 5, 6, 7, 8]
                inds_show_txt = [0, 1]
                if '3' in nm: Ay[0] *= 8
                if '5' in nm: Ay[0] *= 5
        else:
            if '001' not in nm:
                inds_show = [0, 4, 5, 6, 7, 8]
                inds_show_txt = [0, 4, 6, 8]
                Ay[0] *= 8; Ax[4] *= .7; Ay[6] *= 3e-4
                Ay[8] *= 4e-7; Ax[8] *= .7
                if '5' in nm:
                    Ax[6] *= .7; Ay[6] *= 15; Ax[8] *= .7; Ay[8] *= 2
                if '7' in nm:
                    Ay[4] *= .5; Ax[6] *= .7; Ay[6] *= 7; Ax[8] *= .9
                if '1' in nm:
                    Ax[6] *= .7; Ay[6] *= 3; Ay[8] *= 2e-1; Ax[8] *= .8
        return inds_show, inds_show_txt, Ax, Ay

    # chose indices to show power law fits and text with k^(a/b) for GW
    # spectrum EGW(k)
    def indices_EGW(nm, Ax, Ay):
        if 'i' in nm:
            inds_show = [0, 2, 4, 6, 7, 8, 9, 10]
            inds_show_txt = [0, 2, 4, 9]
            Ay[4] *= .6; Ay[9] *= 3e-4
            if '5' in nm:
                inds_show_txt = [0, 2, 4, 7]
                Ay[7] *= 8e-3
            if nm == 'i_s1':
                Ay[2] *= 1.8; Ay[4] *= 4
                Ay2_HGW[3] *= 2.5
        else:
            if '001' in nm:
                inds_show = [0, 2, 3, 5, 6, 7, 8, 9]
                inds_show_txt = [0, 2, 7]
                Ay[2] *= .5; Ay[7] *= 5e-5
            else:
                inds_show = [0, 1, 2, 3, 6, 7, 8, 9, 10, 11]
                inds_show_txt = [0, 2, 8]
                Ay[2] *= .5; Ay[8] *= 2e-6
                if '5' in nm:
                    inds_show_txt = [0, 2, 7, 10]
                    Ay[2] *= 1.5; Ay[7] *= 1e-5; Ay[10] *= 3e-10
                if '7' in nm or '1' in nm:
                    inds_show_txt = [0, 2, 7, 9]
                    Ay[2] *= 2
                    Ay[7] *= 3e-6; Ay[9] *= 3e-9
        return inds_show, inds_show_txt, Ax, Ay

    # chose indices to show power law fits and text with k^(a/b) for GW
    # helicity spectrum HGW(k)
    def indices_HGW(nm, Ax, Ay):
        inds_show = []
        inds_show_txt = []
        if 'i' in nm:
            inds_show = [3, 5, 6, 7, 8]
            inds_show_txt = [3]
            if '3' in nm or '5' in nm:
                inds_show = [1, 2, 3, 5, 6, 7, 8]
                if '3' in nm:
                    inds_show_txt = [1, 2, 3]
                    Ay[1] *= .3; Ay[2] *= 1.5; Ay[3] *= 3.5
                if '5' in nm:
                    inds_show_txt = [2, 3]
                    Ax[2] *= .9; Ay[3] *= 1.5
                if nm == 'i_s1': Ay[3] *= 2.5
        else:
            if '001' not in nm:
                inds_show = [2, 5, 6, 7, 8, 9]
                inds_show_txt = [2, 6]
                Ay[6] *= 1e-6; Ax[6] *= .8
                if '5' in nm:
                    inds_show_txt = [2, 5]
                    Ay[2] *= 2; Ay[5] *= 1.3e-4; Ax[5] *= .7
                if '7' in nm or '1' in nm:
                    Ay[2] *= 1.3; Ay[6] *= .35; Ax[6] *= .9
        return inds_show, inds_show_txt, Ax, Ay

    plt.rcParams.update({'xtick.labelsize': 'xx-large',
                         'ytick.labelsize': 'xx-large',
                         'axes.labelsize': 'xx-large'})

    name = run.name_run
    k = run.spectra.get('k')[1:]
    t = run.spectra.get('t_helmag')
    # read magnetic spectra
    if run.turb == 'k':
        EM = np.array(run.spectra.get('kin')[:, 1:], dtype='float')
        HkM = np.array(run.spectra.get('helkin_comp')[:, 1:], dtype='float')
    if run.turb == 'm':
        EM = np.array(run.spectra.get('mag')[:, 1:], dtype='float')
        HkM = np.array(run.spectra.get('helmag_comp')[:, 1:], dtype='float')
    # read GW spectra
    min_GWs = np.array(run.spectra.get('EGW_min_sp'), dtype='float')
    max_GWs = np.array(run.spectra.get('EGW_max_sp'), dtype='float')
    mean_GWs = np.array(run.spectra.get('EGW_stat_sp'), dtype='float')
    min_pos_HGWs = abs(np.array(run.spectra.get('helEGW_pos_min_sp'),
                                dtype='float'))
    min_neg_HGWs = abs(np.array(run.spectra.get('helEGW_neg_min_sp'),
                                dtype='float'))
    max_pos_HGWs = abs(np.array(run.spectra.get('helEGW_pos_max_sp'),
                                dtype='float'))
    max_neg_HGWs = abs(np.array(run.spectra.get('helEGW_neg_max_sp'),
                                dtype='float'))
    mean_HGWs = np.array(run.spectra.get('helEGW_stat_sp'), dtype='float')

    # get time that corresponds to maximum of magnetic energy density tini
    dtk = t[1] - t[0]
    indt = np.where(abs(t - run.tini) <= dtk/2)[0][0]

    fig, ax = plt.subplots(figsize=(12,10))
    plt.xscale('log')
    plt.yscale('log')
    #plt.text(3e4, 4e-23, '$k$', fontsize=30)
    plt.xlabel('$k$')
    TT = 'M'
    if run.turb == 'k': TT = 'K'
    plt.title(r'$E_{\rm %s, GW} (k)$ and $H_{\rm %s, GW} (k)$'%(TT, TT),
              fontsize=30, pad=15)

    # specific options for the plots
    N_EM, Ay2_EM, Ax_EM = init_Ay2_Ax(12, 2., 1.)
    N_HM, Ay2_HM, Ax_HM = init_Ay2_Ax(10, .04, 1.)
    N_EGW, Ay2_EGW, Ax_EGW = init_Ay2_Ax(12, 2.5, 1.)
    N_HGW, Ay2_HGW, Ax_HGW = init_Ay2_Ax(10, .08, .8)
    Ay_HGW = .2
    Ay_HM = .2
    if 'i' in name:
        xleg = 1.5e4
        yleg = 5e-13
    else:
        xleg = 8e2
        yleg = 5e-20

    if '001' in name: yks_H = False
    else: yks_H = True
    # choose indices for which to show the power law fits and the power law
    # text above the fit for each of the runs
    inds_show_EM, inds_show_txt_EM, Ax_EM, Ay2_EM = \
            indices_EM(name, Ax_EM, Ay2_EM)
    inds_show_HM, inds_show_txt_HM, Ax_HM, Ay2_HM = \
            indices_HM(name, Ax_HM, Ay2_HM)
    inds_show_EGW, inds_show_txt_EGW, Ax_EGW, Ay2_EGW = \
            indices_EGW(name, Ax_EGW, Ay2_EGW)
    inds_show_HGW, inds_show_txt_HGW, Ax_HGW, Ay2_HGW = \
            indices_HGW(name, Ax_HGW, Ay2_HGW)

    if 'i' in name: str_typ = 'ini'
    else: str_typ = 'forc'
    if name == 'M0': sig_val = '0'
    if '01' in name and 'i' in name: sig_val = '0.1'
    if '01' in name and 'M' in name: sig_val = '0.1'
    if '01' in name and 'K' in name: sig_val = '0.1'
    if '3' in name: sig_val = '0.3'
    if '5' in name: sig_val = '0.5'
    if '7' in name: sig_val = '0.7'
    if name == 'i_s1': sig_val = '1'
    if name == 'M1' or name == 'K1': sig_val = '1'
    if '001' in name and 'f' in name:
        if 'neg' in name: sig_val = '-0.01'
        else: sig_val = '0.01'
    if name == 'f_s1_neg': sig_val = '-1'
    str_leg = r'$\sigma^{\rm %s}_{\rm M}=%s$'%(str_typ, sig_val)

    plot_st(k, EM[indt, :], yks=True, N=N_EM, inds_show=inds_show_EM,
            inds_show_txt=inds_show_txt_EM, Ay=4, Ay2=Ay2_EM, Ax=Ax_EM)

    plot_st(k, HkM[indt, :], hel=True, yks=yks_H, N=N_HM,
            inds_show=inds_show_HM, inds_show_txt=inds_show_txt_HM,
            Ay=Ay_HM, Ay2=Ay2_HM, Ax=Ax_HM)

    plot_st(k, mean_GWs, fb=True, yv=True, min_sp=min_GWs, max_sp=max_GWs,
            yks=True, N=N_EGW, inds_show=inds_show_EGW, Ax=Ax_EGW,
            inds_show_txt=inds_show_txt_EGW, Ay=4, Ay2=Ay2_EGW)

    plot_st(k, mean_HGWs, hel=True, fb=True, yv=True, min_sp_neg=min_neg_HGWs,
            max_sp_neg=max_neg_HGWs, min_sp_pos=min_pos_HGWs,
            max_sp_pos=max_pos_HGWs, yks=yks_H, N=N_HGW,
            inds_show=inds_show_HGW, inds_show_txt=inds_show_txt_HGW,
            Ay=Ay_HGW, Ay2=Ay2_HGW, Ax=Ax_HGW)

    handles = []
    line_mag, = ax.plot([], [], '-', color='black', label=r'$E_{\rm %s}(k)$'%TT)
    line_helpos, = ax.plot([], [], '.',
                           label=r'$+\frac{1}{2} k H_{\rm %s}(k)$'%TT,
                           color='red')
    line_helneg, = ax.plot([], [], '.',
                           label=r'$-\frac{1}{2} k H_{\rm %s}(k)$'%TT,
                           color='blue')
    line_GW, = ax.plot([], [], color='black', label=r'$E_{\rm GW}(k)$')
    line_HGWpos, = ax.plot([], [], '.', label=r'$+H_{\rm GW} (k)$',
                           color='red')
    line_HGWneg, = ax.plot([], [], '.', label=r'$-H_{\rm GW}(k)$',
                           color='blue')
    handles = [line_mag, line_helpos, line_helneg]
    lgd1 = ax.legend(handles=handles, loc='upper right', fontsize=23,
                     frameon=False)
    handles2 = [line_GW, line_HGWpos, line_HGWneg]
    lgd2 = plt.legend(handles=handles2, loc='lower left', fontsize=23,
                      frameon=False)
    ax = plt.gca()
    ax.add_artist(lgd1)

    plt.yticks([1e-21, 1e-19, 1e-17, 1e-15, 1e-13, 1e-11, 1e-9,
                1e-7, 1e-5, 1e-3])
    plot_sets.axes_lines()
    plt.tick_params(axis='y', direction='out', length=10)

    plt.text(xleg, yleg, str_leg, fontsize=30,
             bbox=dict(facecolor='white', edgecolor='black',
                       boxstyle='round,pad=.5'))

    plt.xlim(100, 8e4)
    plt.ylim(1e-21, 1e-3)
    if save: plt.savefig('plots/' + run.name_run + 'EM_EGW.pdf',
                         bbox_inches='tight')

def assign_col(nm):
    # select colors
    col = ''
    if '5' in nm: col='orange'
    if 'f_s001' in nm: col='black'
    if nm == 'f_s1_neg': col='blue'
    if nm == 'i_s1': col='red'
    if nm == 'i_s01': col='green'
    if '3' in nm: col = 'darkgreen'
    if '7' in nm: col = 'darkorange'
    if nm=='M0' or nm =='K0': col='black'
    if nm=='M01_c' or nm=='K01_c': col='green'
    if nm=='M03' or nm=='K03': col='darkgreen'
    if 'M1' in nm or 'K1' in nm: col='red'
    if 'ac' in nm: col='blue'
    if 'noh' in nm: col='black'
    if 'ini' in nm or 'hel' in nm: col='red'
    if col == '':
        print(nm + 'has not been considered, assigned to color blue')
        col = 'blue'
    return col

def plot_helicity_vs_t(runs, type='ini', save=True):

    """
    Function that generates the plot of the total magnetic or kinetic helicity
    as a function of time.

    It corresponds to figure 4 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        runs -- dictionary that includes the run variables
        type -- selects the types of runs to be plotted (default 'ini', other
                option is 'forc'), i.e., runs with an initial magnetic field
                ('ini') or runs in which the magnetic field is initially driven
                during the simulation ('forc')
        save -- option to save the figure in plots/sigmaM_vs_t_'type'.pdf'
                (default True)
    """

    if type == 'ini': RR = ['i_s01', 'i_s03', 'i_s05', 'i_s07', 'i_s1']
    elif type == 'forc':
        RR = ['f_s001', 'f_s001_neg', 'f_s03', 'f_s05', 'f_s07', 'f_s1_neg']
    elif type == 'kin': RR = ['K0', 'K01_c', 'K03', 'K05', 'K1']
    elif type == 'mag': RR = ['M0', 'M01_c', 'M03', 'M05', 'M1']

    plt.figure(figsize=(12,8))

    for i in RR:
        run = runs.get(i)
        col = assign_col(i)
        if run.turb == 'm': sp = 'mag'
        if run.turb == 'k': sp = 'kin'
        t = np.array(run.spectra.get('t_hel' + sp), dtype='float')[:, 0]
        t2 = run.spectra.get('t_' + sp)
        EM = np.array(run.spectra.get(sp), dtype='float')
        HkM = run.spectra.get('hel' + sp + '_comp')
        k = run.spectra.get('k')
        EMs_mean = np.trapz(EM, k, axis=1)
        HMs_mean = np.trapz(HkM, k, axis=1)
        EMs_mean = np.interp(t, t2, EMs_mean)
        eps = abs(HMs_mean)/EMs_mean
        plt.plot(t - 1, eps, '.', color=col)
        if col == 'black': sig = 0
        if col == 'green': sig = 0.1
        if col == 'darkgreen': sig = 0.3
        if col == 'orange': sig = 0.5
        if col == 'darkorange': sig = 0.7
        if col == 'red' or col == 'blue': sig = 1.
        eps = 2*sig/(1 + sig**2)
        plt.hlines(eps, 1e-5, 5, color=col, ls='dashed', lw=0.5)

    if type == 'ini': tp = 'ini'
    else: tp = 'forc'
    #line_s0, line_s001, line_s01, line_s03, line_s05, line_s07, \
    #        line_s1, line_s1_neg, = get_lines_sig(tp)
    #hdls1 = [line_s001, line_s01, line_s03, line_s05, line_s07, line_s1,]
    #plt.legend(handles=hdls1, fontsize=24, loc='center left')
    MM = 'M'
    if type == 'kin': MM = 'K'
    sig_s = r'$\sigma_{\rm %s}^{\rm %s} = $'%(MM, tp)
    if type != 'forc':
        plt.text(2.5e-3, .12, sig_s + ' 0.1', color='green', fontsize=24)
        if type != 'ini':
            plt.text(2.5e-3, -.08, sig_s + ' 0', color='black', fontsize=24)
    else:
        plt.text(2.5e-3, .04, sig_s + ' $\pm 0.01$', color='black', fontsize=24)
    plt.text(2.5e-3, .47, sig_s + ' 0.3', color='darkgreen', fontsize=24)
    plt.text(2.5e-3, .72, sig_s + ' 0.5', color='orange', fontsize=24)
    if type == 'ini' or type == 'forc':
        plt.text(2.5e-3, .86, sig_s + ' 0.7', color='darkorange', fontsize=24)
    if type != 'forc':
        plt.text(2.5e-3, 1.04, sig_s + ' $1$', color='red', fontsize=24)
    else:
        plt.text(2.5e-3, 1.04, sig_s + ' $-1$', color='blue', fontsize=24)

    plot_sets.axes_lines()
    plt.xscale('log')
    plt.xlim(2e-3, 5e-1)
    plt.ylim(-.1, 1.13)
    if type == 'mag' or type == 'kin':
        plt.ylim(-.15, 1.13)
        plt.xlim(2e-3, 1.5e0)
    plt.xlabel('$\delta t=t-1$')
    plt.ylabel(r'$|{\cal P}_{\rm M}(t)|$')
    plt.yticks(np.linspace(0, 1, 5))

    if save: plt.savefig('plots/sigmaM_vs_t_' + type + '.pdf',
                         bbox_inches='tight')

def plot_PGW(runs, PPh='GW', type='ini', save=True):

    """
    Function that plots the GW polarization spectra, averaging over
    times after the GW energy and helicity have entered stationary oscillatory
    stages (this needs to be previously computed and stored in the run variable,
    see initialize_JCAP_2021.py).

    It corresponds to figure 5 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        runs -- dictionary of variables run with spectral information
        type -- selects the types of runs to be plotted (default 'ini', other
                option is 'forc'), i.e., runs with an initial magnetic field
                ('ini') or runs in which the magnetic field is initially driven
                during the simulation ('forc')
        save -- option to save the figure in plots/PGW_'type'_sigma.pdf'
                (default True)
    """

    plt.rcParams.update({'xtick.labelsize': 'xx-large',
                         'ytick.labelsize': 'xx-large',
                         'axes.labelsize': 'xx-large'})

    if type == 'ini': RR = ['i_s01', 'i_s03', 'i_s05', 'i_s07', 'i_s1']
    elif type == 'forc':
        RR = ['f_s001', 'f_s001_neg', 'f_s03', 'f_s05', 'f_s07', 'f_s1_neg']
    elif type == 'kin': RR = ['K0', 'K01_c', 'K03', 'K05', 'K1']
    elif type == 'mag': RR = ['M0', 'M01_c', 'M03', 'M05', 'M1']
    if PPh == 'GW': PP = 'GW'
    if PPh == 'h': PP = 'h'

    fig, ax = plt.subplots(figsize=(12,10))

    for i in RR:
        # select colors
        col = assign_col(i)
        run = runs.get(i)
        k = run.spectra.get('k')[1:]
        PGW = run.spectra.get('P' + PP + '_stat_sp')
        PGW_min = run.spectra.get('P' + PP + '_min_sp')
        PGW_max = run.spectra.get('P' + PP + '_max_sp')
        plt.plot(k, PGW, color=col, lw=2)
        plt.fill_between(k, PGW_min, PGW_max, alpha=0.3, color=col)
        for i in range(0, len(k)):
            plt.vlines(k[i], PGW_min[i], PGW_max[i], color=col, lw=0.6,
                       ls='dashed')

    plot_sets.axes_lines()
    plt.xscale('log')
    plt.xlabel('$k$')
    plt.ylabel(r'${\cal P}_{\rm %s} (k)$'%PP)

    sigs = []
    plt.xlim(120, 5e4)
    tp = 'forc'
    if type == 'forc':
        sigs = ['0.01', '-0.01', '0.3', '0.5', '0.7', '-1']
        cols = ['black', 'black', 'darkgreen', 'orange', 'darkorange', 'blue']
        plt.ylim(-1.15, 1.15)
        plt.yticks(np.linspace(-1, 1, 9))
        if PPh == 'GW':
            xxs = [7e2, 7e2, 7e2, 8e3, 2.5e3, 7e2]
            yys = [.2, -.25, .4, .55, .9, -.9, -.9]
            plt.text(3e4, -0.9, '(b)', fontsize=30)
        else:
            xxs = [5e2, 5e2, 5e2, 4e3, 3e3, 5e2]
            yys = [.25, -.25, .5, .5, .7, -.8]
            plt.text(3e4, -0.9, '(d)', fontsize=30)
    else:
        if type == 'ini':
            tp = 'ini'
            sigs = ['0.1', '0.3', '0.5', '0.7', '1']
            cols = ['green', 'darkgreen', 'orange', 'darkorange', 'red']
            if PPh == 'GW':
                xxs = [1e4, 1e4, 1e4, 1e4, 1e3]
                yys = [.3, .5, .75, 1.05, 1.05]
                plt.text(3e4, -0.35, '(a)', fontsize=30)
            else:
                xxs = [1.5e4, 1.5e4, 1.5e4, 1.5e4, 1e3]
                yys = [0.05, 0.35, 0.62, 1.05, 1.05]
                plt.text(3e4, -0.35, '(c)', fontsize=30)
        else:
            line_s0, line_s001, line_s01, line_s03, line_s05, line_s07, \
                    line_s1, line_s1_neg, = get_lines_sig(tp)
            hdls = [line_s1, line_s05, line_s03, line_s01, line_s0,]
            plt.legend(handles=hdls, fontsize=24, loc='upper right',
                       frameon=False)
            plt.xlim(120, 3e4)
        plt.ylim(-.5, 1.2)

    for i in range(0, len(sigs)):
        plt.text(xxs[i], yys[i],
                 r'$\sigma_{\rm M}^{\rm %s}=%s$'%(tp, sigs[i]),
                 fontsize=30, color=cols[i])


    if save: plt.savefig('plots/P' + PPh + '_' + type + '_sigma.pdf',
                         bbox_inches='tight')

def get_lines_sig(tp):

    sigs = r'\sigma_{\rm M}^{\rm %s} ='%tp
    line_s0, = plt.plot([], [], color='black', lw=3,
                        label=r'$%s 0$'%sigs)
    line_s001, = plt.plot([], [], color='black', lw=3,
                         label=r'$%s \pm 0.01$'%sigs)
    line_s01, = plt.plot([], [], color='green', lw=3, label=r'$%s 0.1$'%sigs)
    line_s03, = plt.plot([], [], color='darkgreen', lw=3,
                         label=r'$%s 0.3$'%sigs)
    line_s05, = plt.plot([], [], color='orange', lw=3, label=r'$%s 0.5$'%sigs)
    line_s07, = plt.plot([], [], color='darkorange', lw=3,
                         label='$%s 0.7$'%sigs)
    line_s1, = plt.plot([], [], color='red', lw=3, label=r'$%s 1$'%sigs)
    line_s1_neg, = plt.plot([], [], color='blue', lw=3, label=r'$%s -1$'%sigs)

    return (line_s0, line_s001, line_s01, line_s03, line_s05, line_s07,
            line_s1, line_s1_neg,)

def plot_PGW_vs_PM(runs, save=True):

    """
    Function that generates the plot of the total GW polarization PGW as a
    function of the total fractional helicity of the sourcing magnetic PM or
    velocity PK field.

    It corresponds to figure 6 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        runs -- dictionary that includes the run variables
        save -- option to save the figure in plots/PGW_vs_PM.pdf'
                (default True)
    """


    plt.figure(figsize=(12,8))

    for i in runs:
        run = runs.get(i)
        k = run.spectra.get('k')
        EGW = run.spectra.get('EGW_stat_sp')
        HGW = run.spectra.get('helEGW_stat_sp')
        t = run.spectra.get('t_mag')
        indt = 0
        EM = run.spectra.get('mag')[indt, :]
        HM = run.spectra.get('helmag_comp')[indt, :]
        PM = np.trapz(HM, k)/np.trapz(EM, k)
        PGW = np.trapz(HGW, k[1:])/np.trapz(EGW, k[1:])
        if 'i' in i: plt.plot(abs(PM), abs(PGW), 'o', color='blue')
        else: plt.plot(abs(PM), abs(PGW), 'x', color='red')
        col = assign_col(i)
        if col == 'black': sig = 0
        if col == 'green': sig = 0.1
        if col == 'darkgreen': sig = 0.3
        if col == 'orange': sig = 0.5
        if col == 'darkorange': sig = 0.7
        if col == 'red' or col == 'blue': sig = 1.
        if col == 'blue': col = 'red'
        eps = 2*sig/(1 + sig**2)
        plt.vlines(eps, 0, 2*eps/(1 + eps**2), color=col, ls='dashed', lw=0.5)

    plot_sets.axes_lines()
    plt.xlim(0, 1.05)
    plt.ylim(0, 1.1)
    plt.xlabel(r'$|{\cal P}_{\rm M}|$')
    plt.ylabel(r'$|{\cal P}_{\rm GW}|$')
    xx = np.linspace(0, 1.1)
    plt.plot(xx, xx, lw=.5, ls='dashed', color='black')
    plt.plot(xx, 2*xx/(1 + xx**2), lw=.5, ls='dashed', color='black')
    plt.text(.06, .75, r'${\cal P}_{\rm GW}=2 {\cal P}_{\rm M}' + \
                            r'/\bigl(1 + {\cal P}_{\rm M}^2\bigr)$',
             fontsize=24, bbox=dict(facecolor='white', edgecolor='black',
                                    boxstyle='round,pad=.2'))
    plt.text(.3, .2, r'${\cal P}_{\rm GW}={\cal P}_{\rm M} = 2' + \
                            r'\sigma_{\rm M}/\bigl(1 + \sigma_{\rm M}^2\bigr)$',
             fontsize=24, bbox=dict(facecolor='white', edgecolor='black',
                                    boxstyle='round,pad=.2'))
    #plt.legend(fontsize=14)
    line_ini, = plt.plot([], [], 'o', color='blue', label='initial')
    line_forc, = plt.plot([], [], 'x', color='red', label='forcing (short)')
    hdls = [line_ini, line_forc,]
    plt.legend(handles=hdls, fontsize=24, loc='upper left', frameon=False)
    ax = plt.gca()
    ax.tick_params(axis='x', pad=20)
    ax.tick_params(axis='y', pad=10)

    if save: plt.savefig('plots/PGW_vs_PM.pdf', bbox_inches='tight')

def plot_efficiency(runs, save=True):

    """
    Function that generates the plot of the GW production efficiency for
    different runs as a function of time.

    It corresponds to figure 10 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        runs -- dictionary that includes the run variables
        save -- option to save the figure in plots/OmGW_efficiency_vs_t.pdf'
                (default True)
    """

    plt.figure(figsize=(12,8))

    RR = ['i_s01', 'i_s03', 'i_s05', 'i_s07', 'i_s1', 'f_s001', 'f_s001_neg',
          'f_s03', 'f_s05', 'f_s07', 'f_s1_neg', 'M0', 'M01_c', 'M03', 'M05',
          'M1', 'ini1', 'ini2', 'ini3', 'hel1', 'hel2', 'hel3', 'hel4',
          'noh1', 'noh2', 'ac1', 'ac2', 'ac3']

    for i in RR:
        # select colors
        col = assign_col(i)
        run = runs.get(i)

        t = run.ts.get('t')
        EGW = run.ts.get('EEGW')
        if run.turb=='m':
            Om = run.OmMmax
            kf = run.kfM
        if run.turb=='k':
            Om = run.OmKmax
            kf = run.kfK
        if abs(kf - 510.9) < 10 or 'M' in i: kf = 708
        if abs(kf - 5999) < 100: kf=7000
        lww = 1.
        ls = 'solid'
        if 'M' in i: lww = .6
        if 'ac' in i or 'hel' in i:
            lww = .8; ls = 'dotted'
        if 'ini' in i or 'noh' in i:
            lww = .8; ls = 'dotted'
        plt.plot(t-1, np.sqrt(EGW)/Om*kf, color=col, ls=ls, lw=lww)


    line_s0, line_s001, line_s01, line_s03, line_s05, line_s07, \
            line_s1, line_s1_neg, = get_lines_sig('')
    hdls1 = [line_s001, line_s01, line_s03, line_s05, line_s07, line_s1,]
    plt.text(.2, np.sqrt(.4), 'initial')
    plt.text(.08, 3.1, 'forcing (short)')
    plt.text(.007, 6, 'forcing (short, $k_*\sim 60$)')
    plt.text(1.2, np.sqrt(30), 'forcing (long)')
    plt.text(2e-1, 10, 'acoustic')
    plt.legend(handles=hdls1, fontsize=24, framealpha=1)

    plot_sets.axes_lines()
    plt.xlim(6e-3, 4)
    plt.ylim(1e-1, 2e1)
    plt.xlabel('$\delta t=t-1$')
    plt.ylabel(r'$k_*\, \Omega_{\rm GW}^{1/2} (t)/{\cal E}_{\rm M,K}^{\rm max}$')
    plt.yscale('log')
    plt.xscale('log')

    if save: plt.savefig('plots/OmGW_efficiency_vs_t.pdf', bbox_inches='tight')

def plot_OmGW_vs_f(runs, type='ini', T=1e5*u.MeV, g=100, SNR=10, Td=4, OmM=.1,
                   Xi=False, save=True):

    """
    Function that generates the plot of the GW energy density frequency
    spectra at present time compared to the LISA, Taiji, BBO, and DECIGO
    sensitivities and power law sensitivities (PLS).

    It produces figure 11-13 of A. Roper Pol, S. Mandal, A. Brandenburg,
    and T. Kahniashvili, "Polarization of gravitational waves from helical MHD
    turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        runs -- dictionary that includes the run variables
        type -- selects the types of runs to be plotted (default 'ini', other
                option is 'forc'), i.e., runs with an initial magnetic field
                ('ini') or runs in which the magnetic field is initially driven
                during the simulation ('forc')
        T -- temperature scale (in natural units) at the time of turbulence
             generation (default 100 GeV, i.e., electroweak scale)
        g -- number of relativistic degrees of freedom at the time of
             turbulence generation (default 100, i.e., electroweak scale)
        SNR -- signal-to-noise ratio (SNR) of the resulting PLS (default 10)
        Td -- duration of the mission (in years) of the resulting PLS
              (default 4)
        save -- option to save the resulting figure as
                plots/'OmGW'_'type'_detectors_'Om'.pdf (default True)
                where 'OmGW' = OmGW or XiGW (for Xi False and True,
                respectively), 'Om' = OmM005 or OmM01, and 'type' is 'ini'
                or 'forc'
    """

    # read LISA and Taiji sensitivities
    CWD = os.getcwd()
    os.chdir('..')
    if Xi:
        fs, LISA_Om, LISA_OmPLS, LISA_Xi, LISA_XiPLS = \
                inte.read_sens(SNR=SNR, T=Td, Xi=True)
        fs_Tai, Taiji_Om, Taiji_OmPLS, Taiji_Xi, Taiji_XiPLS = \
                inte.read_sens(SNR=SNR, T=Td, interf='Taiji', Xi=True)
        fs_comb, LISA_Taiji_Xi, LISA_Taiji_XiPLS = \
                inte.read_sens(SNR=SNR, T=Td, interf='comb')
        fs_comb = fs_comb*u.Hz
    else:
        fs, LISA_Om, LISA_OmPLS = inte.read_sens(SNR=SNR, T=Td)
        fs_Tai, Taiji_Om, Taiji_OmPLS = inte.read_sens(SNR=SNR, T=Td,
                                                       interf='Taiji')
        dir = 'detector_sensitivity'
        f_DECIGO, DECIGO_OmPLS = inte.read_csv(dir, 'DECIGO_PLS_SNR10')
        ff_D = np.logspace(np.log10(f_DECIGO[0]), np.log10(f_DECIGO[-1]), 100)
        DECIGO_OmPLS = 10**np.interp(ff_D, f_DECIGO, np.log10(DECIGO_OmPLS))
        f_DECIGO = ff_D*u.Hz
        f_BBO, BBO_OmPLS = inte.read_detector_PLIS_Schmitz(det='BBO', SNR=SNR,
                                                           T=Td)
        f_BBO = f_BBO*u.Hz
    fs = fs*u.Hz
    fs_Tai = fs_Tai*u.Hz
    os.chdir(CWD)

    # internal function to compute f, OmGW as present time observables
    def shift_Omega(run, T, g, ratio, Xi, sp='stat'):
        hel = ''
        if Xi: hel = 'hel'
        EGW = np.array(run.spectra.get(hel + 'EGW_' + sp + '_sp'),
                       dtype='float')*ratio**2
        k = run.spectra.get('k')[1:]
        OmGW = EGW*k
        f, OmGW = cosmoGW.shift_OmGW_today(k, OmGW, T, g)
        return f, OmGW

    plt.rcParams.update({'xtick.labelsize': 'xx-large',
                         'ytick.labelsize': 'xx-large',
                         'axes.labelsize': 'xx-large'})

    if type == 'ini': RR = ['i_s01', 'i_s03', 'i_s05', 'i_s07', 'i_s1']
    elif type == 'forc':
        RR = ['f_s001', 'f_s001_neg', 'f_s03', 'f_s05', 'f_s07', 'f_s1_neg']
    elif type == 'kin': RR = ['K0', 'K01_c', 'K03', 'K05', 'K1']
    elif type == 'mag': RR = ['M0', 'M01_c', 'M03', 'M05', 'M1']

    fig, ax = plt.subplots(figsize=(12,10))

    for i in RR:
        # select colors
        col = assign_col(i)
        run = runs.get(i)

        ratio = OmM/run.Ommax
        f, OmGW = shift_Omega(run, T, g, ratio, Xi, sp='stat')
        _, OmGW_min = shift_Omega(run, T, g, ratio, Xi, sp='min')
        _, OmGW_max = shift_Omega(run, T, g, ratio, Xi, sp='max')

        plt.plot(f, abs(OmGW), color=col, lw=3)
        #if 'i_s1' not in i:
        #if type == 'ini' or type == 'forc':
        plt.fill_between(f, OmGW_min, OmGW_max, alpha=0.1, color=col)
        for i in range(0, len(f)):
            plt.vlines(f.value[i], OmGW_min[i], OmGW_max[i], color=col,
                       lw=0.6, ls='dashed')

    if type == 'ini': tp = 'ini'
    else: tp = 'forc'
    line_s0, line_s001, line_s01, line_s03, line_s05, line_s07, \
            line_s1, line_s1_neg, = get_lines_sig(tp)
    if type == 'ini': hdls = [line_s01, line_s03, line_s05, line_s07, line_s1,]
    elif type == 'forc':
        hdls = [line_s001, line_s03, line_s05, line_s07, line_s1_neg,]
    else:
        hdls = [line_s0, line_s01, line_s03, line_s05, line_s1,]
    plt.legend(handles=hdls, fontsize=24, loc='upper right', framealpha=1)

    Om = '0.1'
    if OmM == .05: Om = '0.05'
    xb = 2e-3
    yb = 8e-11
    if Xi:
        xb = 1e-3
        yb = 1e-17
    MM = 'M'
    if type == 'kin': MM = 'K'
    plt.text(xb, yb, r'${\cal E}^{\rm max}_{\rm %s} = %s$'%(MM, Om),
             fontsize=30, bbox=dict(facecolor='white', edgecolor='black',
                                    boxstyle='round,pad=.5'))

    if type == 'ini':
        xB = 1.2e-2; yB = 1e-16
        xD = 2e-3; yD = 6e-16
        if OmM == 0.1: pan = '(a)'
        else: pan = '(c)'
    else:
        xB = 3e-2; yB = 3e-17
        xD = 2.5e-2; yD = 1e-15
        if OmM == 0.1: pan = '(b)'
        else: pan = '(d)'
        if type == 'kin': pan = '(a)'
        if type == 'mag': pan = '(b)'

    if Xi:
        plt.plot(fs, LISA_XiPLS, color='lime', ls='-.', lw=1)
        plt.text(1.1e-3, 5e-11, 'LISA', fontsize=30, color='lime')
        plt.plot(fs_Tai, Taiji_XiPLS, color='crimson', ls='-.', lw=1)
        plt.text(1e-2, 4e-11, 'Taiji', fontsize=30, color='crimson')
        plt.plot(fs_comb, LISA_Taiji_XiPLS, color='navy', ls='-.', lw=1)
        plt.text(1e-2, 2e-13, r'LISA--Taiji', fontsize=30, color='navy')
    else:
        plt.plot(fs, LISA_OmPLS, color='lime', ls='-.', lw=1)
        plt.text(7e-3, 4e-12, 'LISA', fontsize=30, color='lime')
        plt.plot(fs_Tai, Taiji_OmPLS, color='crimson', ls='-.', lw=1)
        plt.text(1.3e-2, 1e-13, 'Taiji', fontsize=30, color='crimson')
        plt.plot(f_BBO, BBO_OmPLS, color='navy', ls='-.', lw=1)
        plt.text(xB, yB, 'BBO', fontsize=30, color='navy')
        plt.plot(f_DECIGO, DECIGO_OmPLS, color='royalblue', ls='-.', lw=1)
        plt.text(xD, yD, 'DECIGO', fontsize=30, color='royalblue')

    plt.text(4e-4, 4e-18, pan, fontsize=30)

    plot_sets.axes_lines()
    plt.xscale('log')
    plt.yscale('log')
    plt.xlim(3e-4, 2e-1)
    plt.ylim(1e-18, 1e-8)
    plt.xlabel('$f$ [Hz]')
    if Xi: plt.ylabel(r'$h_0^2 |\Xi_{\rm GW} (f)|$')
    else: plt.ylabel(r'$h_0^2 \Omega_{\rm GW} (f)$')

    Om_save = 'OmM01'
    if OmM == 0.05: Om_save = 'OmM005'
    OmGW_s = 'OmGW'
    if Xi: OmGW_s = 'XiGW'
    if save:
        plt.savefig('plots/%s_%s_detectors_%s.pdf'%(OmGW_s, type, Om_save),
                    bbox_inches='tight')

def plot_PM_beltrami(save=True):

    """
    Function that plots the analytical relations between the GW polarization P
    and the source helicity PM (for magnetic) for the Beltrami field model,
    compared to the empirical fit obtained in the numerical simulations.

    It produces figure 14 (appendix A) of A. Roper Pol, S. Mandal,
    A. Brandenburg, and T. Kahniashvili, "Polarization of gravitational waves
    from helical MHD turbulent sources," https://arxiv.org/abs/2107.05356.

    Arguments:
        save -- option to save the figure in plots/PM_beltrami.pdf'
                (default True)
    """

    plt.figure(figsize=(12,8))

    sigma = np.linspace(0, 1, 100)
    Sh_sig = .5+2*sigma**2/(1+sigma**2)**2
    Pm_sig = 2*sigma/(1+sigma**2)
    Sh_sig = .5*(1 + Pm_sig**2)
    Ph_sig = Pm_sig/Sh_sig

    plt.plot(sigma, Pm_sig, ls='dotted', color='red',
             label=r'${\cal P}_{\rm M}$')
    plt.plot(sigma, Sh_sig, ls='-.', color='blue',
             label=r'$\left(1 + {\cal P}_{\rm M}^2\right)/2$')
    plt.plot(sigma, Ph_sig, color='black', lw=.8,
             label=r'$2 {\cal P}_{\rm M}/\left(1 + {\cal P}_{\rm M}^2\right)$')

    plot_sets.axes_lines()
    plt.xlim(0, 1)
    plt.ylim(0, 1.1)
    plt.legend(fontsize=28, loc='lower right', frameon=False)
    plt.xlabel('$\sigma$')
    plt.ylabel(r'$\cal P$')
    ax = plt.gca()
    ax.tick_params(axis='x', pad=20)
    plt.yticks(np.linspace(0, 1, 5))

    if save: plt.savefig('plots/PM_beltrami.pdf', bbox_inches='tight')
